<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PEtab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li><li><a class="tocitem" href="../Beer_julia_import/">Providing the model as a Julia file instead of an SBML File</a></li><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/API_choosen.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabModel</code></pre><p>A Julia-compatible representation of a PEtab-specified problem.</p><p>Created by <code>readPEtabModel</code>, this object contains helper functions for setting up cost, gradient, and Hessian computations, as well as handling potential model events (callbacks).</p><p><strong>Note1:</strong> Several of the functions in <code>PEtabModel</code> are not intended to be accessed by the user. For example, <code>compute_h</code> (and similar functions) require indices that are built in the background to efficiently map parameters between experimental (simulation) conditions. Rather, <code>PEtabModel</code> holds all information needed to create a <code>PEtabODEProblem</code>, and in the future, <code>PEtabSDEProblem</code>, etc.</p><p><strong>Note2:</strong> <code>ODEProblem.p</code> refers to the parameters for the underlying <code>DifferentialEquations.jl</code> <code>ODEProblem</code>.</p><p><strong>Fields</strong></p><ul><li><code>modelName</code>: The model name extracted from the PEtab YAML file.</li><li><code>compute_h</code>: Computes the observable <code>h</code> for a specific time point and simulation condition.</li><li><code>compute_u0!</code>: Computes in-place initial values using <code>ODEProblem.p</code> for a simulation condition; <code>compute_u0!(u0, p)</code>.</li><li><code>compute_u0</code>: Computes initial values as above, but not in-place; <code>u0 = compute_u0(p)</code>.</li><li><code>compute_σ</code>: Computes the noise parameter <code>σ</code> for a specific time point and simulation condition.</li><li><code>compute_∂h∂u!</code>: Computes the gradient of <code>h</code> with respect to <code>ODEModel</code> states (<code>u</code>) for a specific time point and simulation condition.</li><li><code>compute_∂σ∂u!</code>: Computes the gradient of <code>σ</code> with respect to <code>ODEModel</code> states (<code>u</code>) for a specific time point and simulation condition.</li><li><code>compute_∂h∂p!</code>: Computes the gradient of <code>h</code> with respect to <code>ODEProblem.p</code>.</li><li><code>compute_∂σ∂p!</code>: Computes the gradient of <code>σ</code> with respect to <code>ODEProblem.p</code>.</li><li><code>computeTStops</code>: Computes the event times in case the model has <code>DiscreteCallbacks</code> (events).</li><li><code>convertTspan::Bool</code>: Tracks whether the time span should be converted to <code>Dual</code> numbers for <code>ForwardDiff.jl</code> gradients, in case the model has <code>DiscreteCallbacks</code> and the trigger time is a parameter set to be estimated.</li><li><code>dirModel</code>: The directory where the model.xml and PEtab files are stored.</li><li><code>dirJulia</code>: The directory where the Julia-model files created by parsing the PEtab files (e.g., SBML file) are stored.</li><li><code>odeSystem</code>: A <code>ModellingToolkit.jl</code> ODE system obtained from parsing the model SBML file.</li><li><code>parameterMap</code>: A <code>ModellingToolkit.jl</code> parameter map for the ODE system.</li><li><code>stateMap</code>: A <code>ModellingToolkit.jl</code> state map for the ODE system describing how the initial values are computed, e.g., whether or not certain initial values are computed from parameters in the <code>parameterMap</code>.</li><li><code>parameterNames</code>: The names of the parameters in the <code>odeSystem</code>.</li><li><code>stateNames</code>: The names of the states in the <code>odeSystem</code>.</li><li><code>pathMeasurements</code>: The path to the PEtab measurements file.</li><li><code>pathConditions</code>: The path to the PEtab conditions file.</li><li><code>pathObservables</code>: The path to the PEtab observables file.</li><li><code>pathParameters</code>: The path to the PEtab parameters file.</li><li><code>pathSBML</code>: The path to the PEtab SBML file.</li><li><code>pathYAML</code>: The path to the PEtab YAML file.</li><li><code>modelCallbackSet</code>: This stores potential model callbacks or events.</li><li><code>checkIfCallbackIsActive</code>: Piecewise SBML statements are transformed to DiscreteCallbacks that are activated at a specific time-point. The piecewise callback has a default value at t0 and is only triggered when reaching t<em>activation. If t</em>activation ≤ 0 (never reached when solving the model), this function checks whether the callback should be triggered before solving the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/PEtab_structs.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.readPEtabModel" href="#PEtab.readPEtabModel"><code>PEtab.readPEtabModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readPEtabModel(pathYAML::String;
               forceBuildJuliaFiles::Bool=false,
               verbose::Bool=true,
               ifElseToEvent::Bool=true,
               jlFilePath::String=&quot;&quot;)::PEtabModel</code></pre><p>Parses a PEtab specified problem with a YAML-file located at <code>pathYAML</code> into a Julia-accessible format.</p><p>When parsing a PEtab problem, several things happen under the hood:</p><ol><li>The SBML file is translated into <code>ModelingToolkit.jl</code> format to allow for symbolic computations of the ODE-model Jacobian. Piecewise and model events are further written into <code>DifferentialEquations.jl</code> callbacks.</li><li>The observable PEtab table is translated into a Julia file with functions for computing the observable (<code>h</code>), noise parameter (<code>σ</code>), and initial values (<code>u0</code>).</li><li>To allow gradients via adjoint sensitivity analysis and/or forward sensitivity equations, the gradients of <code>h</code> and <code>σ</code> are computed symbolically with respect to the ODE model&#39;s states (<code>u</code>) and parameters (<code>odeProblem.p</code>).</li></ol><p>All of this happens automatically, and resulting files are stored under <code>petabModel.dirJulia</code>. To save time, <code>forceBuildJlFiles=false</code> by default, which means that Julia files are not rebuilt if they already exist.</p><p>In case a Julia model files is provided instead of a SBML file provide file path under <code>jlFilePath</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pathYAML::String</code>: Path to the PEtab problem YAML file.</li><li><code>forceBuildJuliaFiles::Bool=false</code>: If <code>true</code>, forces the creation of Julia files for the problem even if they already exist.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, displays verbose output during parsing.</li><li><code>ifElseToEvent::Bool=true</code>: If <code>true</code>, rewrites <code>if-else</code> statements in the SBML model as event-based callbacks.</li><li><code>jlFilePath::String=&quot;&quot;</code>: Path to an existing Julia file. Should only be provided if a Julia model file is availble.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">petabModel = readPEtabModel(&quot;path/to/petab/problem.yaml&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/Create_PEtab_model.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>PEtabODEProblem</p><p>Everything needed to setup an optimization problem (compute cost, gradient, hessian and parameter bounds) for a PEtab model.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parameter vector θ is always assumed to be on the parameter scale specified in the PEtab parameters file. If needed, θ is transformed to the linear scale inside the function call.</p></div></div><p><strong>Fields</strong></p><ul><li><code>computeCost</code>: For θ computes the negative likelihood (objective to minimize)</li><li><code>computeChi2</code>: For θ compute χ2 value</li><li><code>computeGradient!</code>: For θ computes in-place gradient computeGradient!(gradient, θ)</li><li><code>computeGradient</code>: For θ computes out-place gradient gradient = computeGradient(θ)</li><li><code>computeHessian!</code>: For θ computes in-place hessian-(approximation) computeHessian!(hessian, θ)</li><li><code>computeHessian</code>: For θ computes out-place hessian-(approximation) hessian = computeHessian(θ)</li><li><code>computeSimulatedValues</code>: For θ compute the corresponding model (simulated) values to the measurements in the same order as in the Measurements PEtab table</li><li><code>computeResiduals</code>: For θ compute the residuals (h<em>model - h</em>observed)^2 / σ^2 in the same order as in the Measurements PEtab table</li><li><code>gradientMethod</code>: The method used to compute the gradient (either :ForwardDiff, :ForwardEquations, :Adjoint, or :Zygote).</li><li><code>hessianMethod</code>: The method used to compute or approximate the Hessian (either :ForwardDiff, :BlocForwardDiff, or :GaussNewton).</li><li><code>nParametersToEstimate</code>: The number of parameters to estimate.</li><li><code>θ_estNames</code>: The names of the parameters in θ.</li><li><code>θ_nominal</code>: The nominal values of θ as specified in the PEtab parameters file.</li><li><code>θ_nominalT</code>: The nominal values of θ on the parameter scale (e.g., log) as specified in the PEtab parameters file.</li><li><code>lowerBounds</code>: The lower parameter bounds on the parameter scale for θ as specified in the PEtab parameters file.</li><li><code>upperBounds</code>: The upper parameter bounds on the parameter scale for θ as specified in the PEtab parameters file.</li><li><code>petabModel</code>: The PEtabModel used to construct the PEtabODEProblem.</li><li><code>odeSolverOptions</code>: The options for the ODE solver specified when creating the PEtabODEProblem.</li><li><code>odeSolverGradientOptions</code>: The options for the ODE solver gradient specified when creating the PEtabODEProblem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/PEtab_structs.jl#L234-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createPEtabODEProblem" href="#PEtab.createPEtabODEProblem"><code>PEtab.createPEtabODEProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">createPEtabODEProblem(petabModel::PEtabModel; &lt;keyword arguments&gt;)</code></pre><p>Given a <code>PEtabModel</code> creates a <code>PEtabODEProblem</code> with potential user specified options.</p><p>The keyword arguments (described below) allow the user to choose cost, gradient, and Hessian methods, ODE solver options, and other tuneable options that can potentially make computations more efficient for some &quot;edge-case&quot; models. Please refer to the documentation for guidance on selecting the most efficient options for different types of models.</p><p>If a keyword argument is not set, a suitable default option is chosen based on the number of model parameters.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Every problem is unique, so even though the default settings often work well they might not be optimal.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>odeSolverOptions::ODESolverOptions</code>: Options for the ODE solver when computing the cost, such as solver and tolerances.</li><li><code>odeSolverGradientOptions::ODESolverOptions</code>: Options for the ODE solver when computing the gradient, such as the ODE solver options used in adjoint sensitivity analysis. Defaults to <code>odeSolverOptions</code> if not set to nothing.</li><li><code>ssSolverOptions::SteadyStateSolverOptions</code>: Options for finding steady-state for models with pre-equilibrium. Steady-state can be found via simulation or rootfinding, which can be set using <code>SteadyStateSolverOptions</code> (see documentation). If not set, defaults to simulation with <code>wrms &lt; 1</code> termination.</li><li><code>ssSolverGradientOptions::SteadyStateSolverOptions</code>: Options for finding steady-state for models with pre-equilibrium when computing gradients. Defaults to <code>ssSolverOptions</code> value if not set.</li><li><code>costMethod::Symbol=:Standard</code>: Method for computing the cost (objective). Two options are available: <code>:Standard</code>, which is the most efficient, and <code>:Zygote</code>, which is less efficient but compatible with the Zygote automatic differentiation library.</li><li><code>gradientMethod=nothing</code>: Method for computing the gradient of the objective. Four options are available:<ul><li><code>:ForwardDiff</code>: Compute the gradient via forward-mode automatic differentiation using ForwardDiff.jl. Most efficient for models with ≤50 parameters. The number of chunks can be optionally set using <code>chunkSize</code>.</li><li><code>:ForwardEquations</code>: Compute the gradient via the model sensitivities, where <code>sensealg</code> specifies how to solve for the sensitivities. Most efficient when the Hessian is approximated using the Gauss-Newton method and when the optimizer can reuse the sensitivities (<code>reuseS</code>) from gradient computations in Hessian computations (e.g., when the optimizer always computes the gradient before the Hessian).</li><li><code>:Adjoint</code>: Compute the gradient via adjoint sensitivity analysis, where <code>sensealg</code> specifies which algorithm to use. Most efficient for large models (≥75 parameters).</li><li><code>:Zygote</code>: Compute the gradient via the Zygote package, where <code>sensealg</code> specifies which sensitivity algorithm to use when solving the ODE model. This is the most inefficient option and not recommended.</li></ul></li><li><code>hessianMethod=nothing</code>: method for computing the Hessian of the cost. There are three available options:<ul><li><code>:ForwardDiff</code>: Compute the Hessian via forward-mode automatic differentiation using ForwardDiff.jl. This is often only computationally feasible for models with ≤20 parameters but can greatly improve optimizer convergence.</li><li><code>:BlockForwardDiff</code>: Compute the Hessian block approximation via forward-mode automatic differentiation using ForwardDiff.jl. The approximation consists of two block matrices: the first is the Hessian for only the dynamic parameters (parameter part of the ODE system), and the second is for the non-dynamic parameters (e.g., noise parameters). This is computationally feasible for models with ≤20 dynamic parameters and often performs better than BFGS methods.</li><li><code>:GaussNewton</code>: Approximate the Hessian via the Gauss-Newton method, which often performs better than the BFGS method. If we can reuse the sensitivities from the gradient in the optimizer (see <code>reuseS</code>), this method is best paired with <code>gradientMethod=:ForwardEquations</code>.</li></ul></li><li><code>sparseJacobian::Bool=false</code>: When solving the ODE du/dt=f(u, p, t), whether implicit solvers use a sparse Jacobian. Sparse Jacobian often performs best for large models (≥100 states).</li><li><code>specializeLevel=SciMLBase.FullSpecialize</code>: Specialization level when building the ODE problem. It is not recommended to change this parameter (see https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/).</li><li><code>sensealg</code>: Sensitivity algorithm for gradient computations. The available options for each gradient method are:<ul><li><code>:ForwardDiff</code>: None (as ForwardDiff takes care of all computation steps).</li><li><code>:ForwardEquations</code>: <code>:ForwardDiff</code> (uses ForwardDiff.jl and typicaly performs best) or <code>ForwardDiffSensitivity()</code> and <code>ForwardSensitivity()</code> from SciMLSensitivity.jl (https://github.com/SciML/SciMLSensitivity.jl).</li><li><code>:Adjoint</code>: <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> from SciMLSensitivity.jl.</li><li><code>:Zygote</code>: All sensealg in SciMLSensitivity.jl.</li></ul></li><li><code>sensealgSS=nothing</code>: Sensitivity algorithm for adjoint gradient computations for steady-state simulations. The available options are <code>SteadyStateAdjoint()</code>, <code>InterpolatingAdjoint()</code>, and <code>QuadratureAdjoint()</code> from SciMLSensitivity.jl. <code>SteadyStateAdjoint()</code> is the most efficient but requires a non-singular Jacobian, and in the case of a non-singular Jacobian, the code automatically switches to <code>InterpolatingAdjoint()</code>.</li><li><code>chunkSize=nothing</code>: Chunk-size for ForwardDiff.jl when computing the gradient and Hessian via forward-mode automatic differentiation. If nothing is provided, the default value is used. Tuning <code>chunkSize</code> is non-trivial, and we plan to add automatic functionality for this.</li><li><code>splitOverConditions::Bool=false</code>: For gradient and Hessian via ForwardDiff.jl, whether or not to split calls to ForwardDiff across experimental (simulation) conditions. This parameter should only be set to true if the model has many parameters specific to an experimental condition; otherwise, the overhead from the calls will increase run time. See the Beer example for a case where this is needed.</li><li><code>reuseS::Bool=false</code> : If set to <code>true</code>, reuse the sensitivities computed during gradient computations for the Gauss-Newton Hessian approximation. This option is only applicable when using <code>hessianMethod=:GaussNewton</code> and <code>gradientMethod=:ForwardEquations</code>. Note that it should only be used when the optimizer always computes the gradient before the Hessian.</li><li><code>verbose::Bool=true</code> : If set to <code>true</code>, print progress messages while setting up the PEtabODEProblem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/Create_PEtabODEProblem/Create_PEtab_ODEProblem.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ODESolverOptions" href="#PEtab.ODESolverOptions"><code>PEtab.ODESolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODESolverOptions(solver, &lt;keyword arguments&gt;)</code></pre><p>ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem.</p><p>More information about the available options and solvers can be found in the documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommended settings for which solver and options to use for different problems can be found below and in the documentation.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: Any of the ODE solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models, composite solvers such as <code>AutoVern7(Rodas5P())</code> perform well. For stiff small models, <code>Rodas5P()</code> performs well. For medium-sized models (≤75 states), <code>QNDF()</code>, <code>FBDF()</code>, and <code>CVODE_BDF()</code> perform well. <code>CVODE_BDF()</code> is not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic differentiation or if the Gauss-Newton Hessian approximation is used. If the gradient is computed via adjoint sensitivity analysis, <code>CVODE_BDF()</code> is often the best choice as it is typically more reliable than <code>QNDF()</code> and <code>FBDF()</code> (fails less often).</li><li><code>abstol=1e-8</code>: Absolute tolerance when solving the ODE system. Not recommended to increase above 1e-6 for gradients.</li><li><code>reltol=1e-8</code>: Relative tolerance when solving the ODE system. Not recommended to increase above 1e-6 for gradients.</li><li><code>force_dtmin=false</code>: Whether or not to force <code>dtmin</code> when solving the ODE system.</li><li><code>dtmin=nothing</code>: Minimal acceptable step-size when solving the ODE system.</li><li><code>maxiters=10000</code>: Maximum number of iterations when solving the ODE system. Increasing above the default value can cause the optimization to take substantial time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/PEtab_structs.jl#L80-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.SteadyStateSolverOptions" href="#PEtab.SteadyStateSolverOptions"><code>PEtab.SteadyStateSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolverOptions(method::Symbol;
                         howCheckSimulationReachedSteadyState::Symbol=:wrms,
                         rootfindingAlgorithm=nothing,
                         abstol=nothing,
                         reltol=nothing,
                         maxiters=nothing)</code></pre><p>Setup options for finding steady-state via either <code>method=:Rootfinding</code> or <code>method=:Simulate</code>.</p><p>For <code>method=:Rootfinding</code>, the steady-state <code>u*</code> is found by solving the problem <code>du = f(u, p, t) ≈ 0</code> with tolerances <code>abstol</code> and <code>reltol</code> via an automatically chosen optimization algorithm (<code>rootfindingAlgorithm=nothing</code>) or via any algorithm in NonlinearSolve.jl.</p><p>For <code>method=:Simulate</code>, the steady-state <code>u*</code> is found by simulating the ODE system until <code>du = f(u, p, t) ≈ 0</code>. Two options are available for <code>howCheckSimulationReachedSteadyState</code>:</p><ul><li><code>:wrms</code> : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1</li><li><code>:Newton</code> : If Newton-step <code>Δu</code> is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1.       - Newton often performs better but requires an invertible Jacobian. In case it&#39;s not fulfilled, the code switches automatically to <code>:wrms</code>.</li></ul><p><code>maxiters</code> refers to either the maximum number of rootfinding steps or the maximum number of integration steps, depending on the chosen method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/PEtab_structs.jl#L114-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.remakePEtabProblem" href="#PEtab.remakePEtabProblem"><code>PEtab.remakePEtabProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remakePEtabProblem(petabProblem::PEtabODEProblem, parametersChange::Dict) :: PEtabODEProblem</code></pre><p>Fixate model parameters for a given PEtabODEProblem without recompiling the problem.</p><p>This function allows you to modify parameters without the need to recompile the underlying code, resulting in reduced latency. To fixate the parameter k1, you can use <code>parametersChange=Dict(:k1 =&gt; 1.0)</code>.</p><p>If model derivatives are computed using ForwardDiff.jl with a chunk-size of N, the new PEtabODEProblem will only evaluate the necessary number of chunks of size N to compute the full gradient for the remade problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/Create_PEtabODEProblem/Remake_PEtabODEProblem.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.Fides" href="#PEtab.Fides"><code>PEtab.Fides</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fides</code></pre><p><a href="https://github.com/fides-dev/fides">Fides</a> is a Python Newton-trust region optimizer for box-bounded optimization problems.</p><p>It is particularly effective when the full Hessian cannot be computed, but the Gauss-Newton Hessian approximation can be computed. If constructed with <code>Fides(verbose=true)</code>, it prints optimization progress during the process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/PEtab_structs.jl#L377-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.callibrateModel" href="#PEtab.callibrateModel"><code>PEtab.callibrateModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calibrateModel(petabProblem::PEtabODEProblem,
               optimizer;
               &lt;keyword arguments&gt;)</code></pre><p>Perform multi-start local optimization for a given PEtabODEProblem and return (fmin, minimizer) for all runs.</p><p><strong>Arguments</strong></p><ul><li><code>petabProblem::PEtabODEProblem</code>: The PEtabODEProblem to be calibrated.</li><li><code>optimizer</code>: The optimizer algorithm to be used. Currently, we support three different algorithms:<ol><li><code>Fides()</code>: The Newton trust-region Fides optimizer from Python. Please refer to the documentation for setup  examples. This optimizer performs well when computing the full Hessian is not possible, and the Gauss-Newton Hessian approximation can be used.</li><li><code>IPNewton()</code>: The interior-point Newton method from Optim.jl. This optimizer performs well when it is  computationally feasible to compute the full Hessian.</li><li><code>LBFGS()</code> or <code>BFGS()</code> from Optim.jl: These optimizers are suitable when the computation of the Gauss-Newton  Hessian approximation is too expensive, such as when adjoint sensitivity analysis is required for the gradient.</li></ol></li><li><code>nOptimisationStarts::Int</code>: Number of multi-starts to be performed. Defaults to 100.</li><li><code>samplingMethod</code>: Method for generating start guesses. Any method from QuasiMonteCarlo.jl is supported, with LatinHypercube as the default.</li><li><code>options</code>: Optimization options. For Optim.jl optimizers, it accepts an <code>Optim.Options</code> struct. For Fides, please refer to the Fides documentation and the PEtab.jl documentation for information on setting options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/Optimization/Callibration.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.runPEtabSelect" href="#PEtab.runPEtabSelect"><code>PEtab.runPEtabSelect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runPEtabSelect(pathYAML, optimizer; &lt;keyword arguments&gt;)</code></pre><p>Given a PEtab-select YAML file perform model selection with the algorithms specified in the YAML file.</p><p>Results are written to a YAML file in the same directory as the PEtab-select YAML file.</p><p>Each candidate model produced during the model selection undergoes parameter estimation using local multi-start optimization. Three optimizers are supported: <code>optimizer=Fides()</code> (Fides Newton-trust region), <code>optimizer=IPNewton()</code> from Optim.jl, and <code>optimizer=LBFGS()</code> from Optim.jl. Additional keywords for the optimisation are <code>nOptimisationStarts::Int</code>- number of multi-starts for parameter estimation (defaults to 100) and <code>optimizationSamplingMethod</code> - which is any sampling method from QuasiMonteCarlo.jl for generating start guesses (defaults to LatinHypercubeSample). See also (add callibrate model)</p><p>Simulation options can be set using any keyword argument accepted by the <code>createPEtabODEProblem</code> function. For example, setting <code>gradientMethod=:ForwardDiff</code> specifies the use of forward-mode automatic differentiation for gradient computation. If left blank, we automatically select appropriate options based on the size of the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/e9d23aadaf53e4a1a45f6358f85a747185563da5/src/PEtab_select/PEtab_select.jl#L1-L18">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Best_options/">« Choosing the best options for a PEtab problem</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 3 June 2023 07:04">Saturday 3 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
