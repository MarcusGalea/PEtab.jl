<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · PEtab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/Define_in_julia/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Importing a PEtab problem</a></li><li><span class="tocitem">Defining a PEtab problem in Julia</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-Dynamic-Model"><span>Defining the Dynamic Model</span></a></li><li><a class="tocitem" href="#Defining-the-Observable"><span>Defining the Observable</span></a></li><li><a class="tocitem" href="#Defining-Parameters-to-Estimate"><span>Defining Parameters to Estimate</span></a></li><li><a class="tocitem" href="#Defining-Simulation-Conditions"><span>Defining Simulation Conditions</span></a></li><li><a class="tocitem" href="#Defining-Measurement-Data"><span>Defining Measurement Data</span></a></li><li><a class="tocitem" href="#Bringing-It-All-Together"><span>Bringing It All Together</span></a></li><li><a class="tocitem" href="#What-is-Next"><span>What is Next</span></a></li><li><a class="tocitem" href="#Runnable-Example"><span>Runnable Example</span></a></li></ul></li><li><a class="tocitem" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations)</a></li><li><a class="tocitem" href="../Julia_obs_noise/">Noise and observable parameters</a></li></ul></li><li><span class="tocitem">Selecting options for a PEtab-problem</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li><li><a class="tocitem" href="../Beer_julia_import/">Providing the model as a Julia file instead of an SBML File</a></li></ul></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Avaible_optimisers/">Available optimisers</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li><a class="tocitem" href="../API_choosen/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Defining a PEtab problem in Julia</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/Define_in_julia.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="define_in_julia"><a class="docs-heading-anchor" href="#define_in_julia">Creating a PEtab Parameter Estimation Problem in Julia</a><a id="define_in_julia-1"></a><a class="docs-heading-anchor-permalink" href="#define_in_julia" title="Permalink"></a></h1><p>While the PEtab table format is excellent for specifying parameter estimation problems for dynamic ODE models, setting up a parameter estimation problem directly in Julia can be more convenient.</p><p>Here we demonstrate how to define a parameter estimation problem using a simple Micheli-Mentan model as an example. We will discuss in detail the five essential components required to define a problem:</p><ol><li><strong>Dynamic Model</strong>: You can use either a <code>ReactionSystem</code> defined in <a href="https://petab.readthedocs.io/en/latest/">Catalyst</a> or an <code>ODESystem</code> defined in <a href="https://github.com/SciML/ModelingToolkit.jl">ModellingToolkit</a>.</li><li><strong>Observable Formula</strong>: To link the model to the measurement data, you need an observable formula. Since real-world data often comes with measurement noise, you also must specify a noise formula and noise distribution. This is specified as a <code>PEtabObservable</code>.</li><li><strong>Parameters to Estimate</strong>: Typically, you do not want to estimate all model parameters. Moreover, sometimes you might want to incorporate prior beliefs by assigning priors to certain parameters. Parameter information is provided as a vector of <code>PEtabParameter</code>.</li><li><strong>Simulation Conditions</strong>: Measurements are often taken under various experimental conditions, such as different substrate concentrations. These experimental conditions typically correspond to model control parameters, like the initial value of a model species. You specify these conditions as a <code>Dict</code> (see below).</li><li><strong>Measurement Data</strong>: To calibrate the model, you need measurement data, which should be provided as a <code>DataFrame</code>. The data format is explained below.</li></ol><h2 id="Defining-the-Dynamic-Model"><a class="docs-heading-anchor" href="#Defining-the-Dynamic-Model">Defining the Dynamic Model</a><a id="Defining-the-Dynamic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Dynamic-Model" title="Permalink"></a></h2><p>To define the dynamic model, you have two options; you can use a <a href="https://petab.readthedocs.io/en/latest/">Catalyst</a> defined <code>ReactionSystem</code>, or a <a href="https://github.com/SciML/ModelingToolkit.jl">ModellingToolkit</a> <code>ODESystem</code>. Using Catalyst we define the model as</p><pre><code class="language-julia hljs">using Catalyst
using PEtab

rn = @reaction_network begin
    @parameters se0
    @species SE(t) = se0
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end</code></pre><p>If you want to estimate the initial value of a species (like <code>SE</code>), you must define it as a parameter, as here with <code>SE(t) = se0</code>. Additionally, if you want to fixate a parameter or initial value to a constant value across all simulations, you can use a state and/or parameter map. For instance, to set <code>E</code> and <code>P</code> to be 1.0 and 0.0, and set <code>c1</code> to 1.0, do:</p><pre><code class="language-julia hljs">state_map = [:E =&gt; 1.0, :P =&gt; 0.0]
parameter_map = [:c1 =&gt; 1.0]</code></pre><p>If a parameter or initial value is not specified anywhere it defaults to zero.</p><h2 id="Defining-the-Observable"><a class="docs-heading-anchor" href="#Defining-the-Observable">Defining the Observable</a><a id="Defining-the-Observable-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Observable" title="Permalink"></a></h2><p>To connect our model with measurement data, we need an observable formula. Since data from a reaction networks typically includes measurement noise, we also require a noise formula and a noise distribution.</p><p>Let us assume we are observing the product <code>P</code> with a normally distributed multiplicative measurement error (<code>sigma * P</code>) on a relative scale. To account for this relative scale we cam as commonly done use <code>scale</code> and <code>offset</code> parameters. Additionally, let us assume we are directly measure the sum <code>E + SE</code> with log-normal measurement noise, and we already know the measurement error (<code>sigma</code>) is 3.0. This can be defined as</p><pre><code class="language-julia hljs">@unpack P, E, SE = rn
@parameters sigma, scale, offset
obs_P = PEtabObservable(scale * P + offset, sigma * P, transformation=:lin)
obs_Sum = PEtabObservable(E + SE, 3.0, transformation=:log)</code></pre><p>The <code>transformation</code> parameter can take one of three values: <code>:lin</code> (default for normal measurement noise), <code>:log</code>, or <code>:log10</code> (for log-normal measurement noise).</p><p>To complete the definition, we group these observables together in a <code>Dict</code> with appropriate names:</p><pre><code class="language-julia hljs">observables = Dict(&quot;obs_P&quot; =&gt; obs_P,
                   &quot;obs_Sum&quot; =&gt; obs_Sum)</code></pre><h2 id="Defining-Parameters-to-Estimate"><a class="docs-heading-anchor" href="#Defining-Parameters-to-Estimate">Defining Parameters to Estimate</a><a id="Defining-Parameters-to-Estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Parameters-to-Estimate" title="Permalink"></a></h2><p>To set up a parameter estimation problem, we need to specify the parameters to estimate. To improve the estimation it is often beneficial to define lower and upper bounds to restrict the parameter space. For example, let us assume we want to estimate the parameter <code>c3</code> with bounds <code>[1e-3, 1e3]</code> (default):</p><pre><code class="language-julia hljs">_c3 = PEtabParameter(:c3, lb=1e-3, ub=1e3, scale=:log10)</code></pre><p>Here <code>scale=:log10</code> means that we are estimating the parameter on a log10 scale, which typically yields better results than a linear-scale. Overall the <code>scale</code> parameter can take on three values: <code>:lin</code>, <code>:log</code>, and <code>:log10</code> (default).</p><p>If you have prior information about parameters, you can specify a continuous prior distribution from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>. For instance, if you want to estimate <code>se0</code> (the initial value of species <code>SE</code>) and you know it should be around 3.1, you can set a prior as:</p><pre><code class="language-julia hljs">using Distributions
_se0 = PEtabParameter(:se0, prior=LogNormal(log(3.1), 0.5), prior_on_linear_scale=true)</code></pre><p>In this case, <code>prior_on_linear_scale=true</code> (default) indicates that the prior is defined on the linear scale, not the default transformed log10 scale used for parameter estimation.</p><p>Apart from estimating parameters in the reaction system, you can also estimate parameters related to measurement noise or parameters used exclusively in the observable formula (e.g., <code>scale</code> and <code>offset</code> parameters see above) by defining them as a <code>PEtabParameter</code>:</p><pre><code class="language-julia hljs"># Using default bounds [1e-3, 1e3] and scale=:log10
_sigma = PEtabParameter(:sigma)
_scale = PEtabParameter(:scale)
_offset = PEtabParameter(:offset)</code></pre><p>Once the parameters are defined they should be gathered into a vector</p><pre><code class="language-julia hljs">_c2 = PEtabParameter(:c2)
parameters = [_c2, _c3, _se0, _sigma, _scale, _offset]</code></pre><h2 id="Defining-Simulation-Conditions"><a class="docs-heading-anchor" href="#Defining-Simulation-Conditions">Defining Simulation Conditions</a><a id="Defining-Simulation-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Simulation-Conditions" title="Permalink"></a></h2><p>Data is often collected under various experimental settings, such as different initial concentrations of a substrate. These variations in experimental conditions correspond to different simulation conditions during model calibration. To effectively align your measurements with the data, you need to specify these simulation conditions using a dictionary.</p><p>Specifically, assume you have measured your data under two conditions: <code>c0</code> and <code>c1</code>, where each condition has different starting concentrations for the substrate <code>S</code>. This can be defined as:</p><pre><code class="language-julia hljs">condition_c0 = Dict(:S =&gt; 5.0)
condition_c1 = Dict(:S =&gt; 2.0)</code></pre><p>Here, the key (in this case, <code>S</code>) can represent either a model species (as in this case) or a parameter. To complete the setup, gather all the simulation conditions in a dictionary, and assign each condition an appropriate name:</p><pre><code class="language-julia hljs">simulation_conditions = Dict(&quot;c0&quot; =&gt; condition_c0,
                             &quot;c1&quot; =&gt; condition_c1)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a parameter or species is specified for one simulation condition, it must be specified for all simulation conditions.</p></div></div><h2 id="Defining-Measurement-Data"><a class="docs-heading-anchor" href="#Defining-Measurement-Data">Defining Measurement Data</a><a id="Defining-Measurement-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Measurement-Data" title="Permalink"></a></h2><p>The measurement data should be organized as a <code>DataFrame</code> in the following format (the column names matter, but not the order)</p><table><tr><th style="text-align: right">simulation_id (str)</th><th style="text-align: right">obs_id (str)</th><th style="text-align: right">time (float)</th><th style="text-align: right">measurement (float)</th></tr><tr><td style="text-align: right">c0</td><td style="text-align: right">obs_P</td><td style="text-align: right">0.0</td><td style="text-align: right">0.7</td></tr><tr><td style="text-align: right">c0</td><td style="text-align: right">obs_Sum</td><td style="text-align: right">10.0</td><td style="text-align: right">0.1</td></tr><tr><td style="text-align: right">c1</td><td style="text-align: right">obs_P</td><td style="text-align: right">1.0</td><td style="text-align: right">1.0</td></tr><tr><td style="text-align: right">c1</td><td style="text-align: right">obs_Sum</td><td style="text-align: right">20.0</td><td style="text-align: right">1.5</td></tr></table><p>For each measurement, you need to specify:</p><ul><li><code>simulation_id</code>: Identifies the simulation condition it corresponds to.</li><li><code>obs_id</code>: Specifies the observable it corresponds to.</li><li><code>time</code>: Indicates the time point at which the data was collected.</li><li><code>measurement</code>: The actual measurement value.</li></ul><p>For this case, the input would look like;</p><pre><code class="language-julia hljs">using DataFrames

measurements = DataFrame(
    simulation_id=[&quot;c0&quot;, &quot;c0&quot;, &quot;c1&quot;, &quot;c1&quot;],
    obs_id=[&quot;obs_P&quot;, &quot;obs_Sum&quot;, &quot;obs_P&quot;, &quot;obs_Sum&quot;],
    time=[0.0, 10.0, 1.0, 20.0],
    measurement=[0.7, 0.1, 1.0, 1.5])</code></pre><h2 id="Bringing-It-All-Together"><a class="docs-heading-anchor" href="#Bringing-It-All-Together">Bringing It All Together</a><a id="Bringing-It-All-Together-1"></a><a class="docs-heading-anchor-permalink" href="#Bringing-It-All-Together" title="Permalink"></a></h2><p>After defining the model, observables, parameters to estimate, simulation conditions, and measurement data, you can easily create a <code>PEtabODEProblem</code> for your parameter estimation task:</p><pre><code class="language-julia hljs">petab_model = readPEtabModel(rn, simulation_conditions, observables, measurements,
                             parameters, stateMap=state_map, parameterMap=parameter_map,
                             verbose=true)
petab_problem = createPEtabODEProblem(petab_model, verbose=true)</code></pre><p>The <code>PEtabODEProblem</code> contains all the necessary information to work with most available optimizers (ADD!). Alternatively, if you want to perform parameter estimation using a multi-start approach, you can use the <code>calibrateModelMultistart</code> function (see see <a href="../Parameter_estimation/#parameter_estimation">Parameter estimation</a>).</p><h2 id="What-is-Next"><a class="docs-heading-anchor" href="#What-is-Next">What is Next</a><a id="What-is-Next-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-Next" title="Permalink"></a></h2><p>This example has covered the fundamental aspects of setting up a parameter estimation problem directly Julia, but there are additional options:</p><ul><li><p><strong>Steady-State Initialization</strong>: In some cases, you might require your model to be at a steady-state at time zero when starting to match the model against data. To learn how to set up pre-equilibration criteria, see <a href="../Julia_steady_state/#define_with_ss">this</a> tutorial.</p></li><li><p><strong>Time-Point Specific Parameters</strong>: You might measure the same observable with different assays, leading to different observable parameters (e.g., scale and offset) and noise parameters for various time points. To handle time-point-specific measurement and noise parameters, see <a href="../Julia_obs_noise/#time_point_parameters">this</a> tutorial.</p></li></ul><p>For guidance on choosing the best options for your specific PEtab problem, we recommend the <a href="../Best_options/#best_options">Choosing the Best Options for a PEtab Problem</a> section and refer to the <a href="../Gradient_hessian_support/#gradient_support">Supported Gradient and Hessian Methods</a> section for more information on available gradient and hessian methods.</p><h2 id="Runnable-Example"><a class="docs-heading-anchor" href="#Runnable-Example">Runnable Example</a><a id="Runnable-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Runnable-Example" title="Permalink"></a></h2><p>Here is the complete code from the tutorial</p><pre><code class="language-julia hljs">using Catalyst
using DataFrames
using Distributions
using PEtab

# Define the reaction network
rn = @reaction_network begin
    @parameters se0
    @species SE(t) = se0  # se0 = initial value for S
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end

# Define state and parameter maps
state_map =  [:E =&gt; 1.0, :P =&gt; 0.0]
parameter_map = [:c1 =&gt; 1.0]

# Unpack model components
@unpack P, E, SE = rn
@parameters sigma, scale, offset

# Define observables
obs_P = PEtabObservable(scale * P + offset, sigma * P, transformation=:lin)
obs_Sum = PEtabObservable(E + SE, 3.0, transformation=:log)
observables = Dict(&quot;obs_P&quot; =&gt; obs_P,
                   &quot;obs_Sum&quot; =&gt; obs_Sum)

# Define parameters for estimation
_c3 = PEtabParameter(:c3, scale=:log10)
_se0 = PEtabParameter(:c3, prior=LogNormal(1.0, 0.5), prior_on_linear_scale=true)
_c2 = PEtabParameter(:c2)
_sigma = PEtabParameter(:sigma)
_scale = PEtabParameter(:scale)
_offset = PEtabParameter(:offset)
parameters = [_c2, _c3, _se0, _sigma, _scale, _offset]

# Define simulation conditions
condition_c0 = Dict(:S =&gt; 5.0)
condition_c1 = Dict(:S =&gt; 2.0)
simulation_conditions = Dict(&quot;c0&quot; =&gt; condition_c0,
                             &quot;c1&quot; =&gt; condition_c1)

# Define measurement data
measurements = DataFrame(
    simulation_id=[&quot;c0&quot;, &quot;c0&quot;, &quot;c1&quot;, &quot;c1&quot;],
    obs_id=[&quot;obs_P&quot;, &quot;obs_Sum&quot;, &quot;obs_P&quot;, &quot;obs_Sum&quot;],
    time=[0.0, 10.0, 1.0, 20.0],
    measurement=[0.7, 0.1, 1.0, 1.5]
)

# Create a PEtab model
petab_model = readPEtabModel(
    rn, simulation_conditions, observables, measurements,
    parameters, stateMap=state_map, parameterMap=parameter_map, verbose=true
)

# Create a PEtabODEProblem
petab_problem = createPEtabODEProblem(petab_model)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Boehm/">« Importing a PEtab problem</a><a class="docs-footer-nextpage" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 September 2023 10:08">Wednesday 20 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
