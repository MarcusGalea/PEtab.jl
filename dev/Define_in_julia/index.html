<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining parameter estimation problems in Julia · PEtab.jl</title><meta name="title" content="Defining parameter estimation problems in Julia · PEtab.jl"/><meta property="og:title" content="Defining parameter estimation problems in Julia · PEtab.jl"/><meta property="twitter:title" content="Defining parameter estimation problems in Julia · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><meta property="og:url" content="https://sebapersson.github.io/PEtab.jl/Define_in_julia/"/><meta property="twitter:url" content="https://sebapersson.github.io/PEtab.jl/Define_in_julia/"/><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/Define_in_julia/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Importing problems in PEtab standard format</a></li><li><span class="tocitem">Defining a PEtab problem in Julia</span><ul><li class="is-active"><a class="tocitem" href>Defining parameter estimation problems in Julia</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-Dynamic-Model"><span>Defining the Dynamic Model</span></a></li><li><a class="tocitem" href="#Defining-the-Observable"><span>Defining the Observable</span></a></li><li><a class="tocitem" href="#Defining-Parameters-to-Estimate"><span>Defining Parameters to Estimate</span></a></li><li><a class="tocitem" href="#Defining-Simulation-Conditions"><span>Defining Simulation Conditions</span></a></li><li><a class="tocitem" href="#Defining-Measurement-Data"><span>Defining Measurement Data</span></a></li><li><a class="tocitem" href="#Bringing-It-All-Together"><span>Bringing It All Together</span></a></li><li><a class="tocitem" href="#Where-to-Go-Next"><span>Where to Go Next</span></a></li><li><a class="tocitem" href="#Runnable-Example"><span>Runnable Example</span></a></li></ul></li><li><a class="tocitem" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations)</a></li><li><a class="tocitem" href="../Julia_obs_noise/">Noise and observable parameters</a></li><li><a class="tocitem" href="../Julia_condition_specific/">Condition specific system/model parameters</a></li><li><a class="tocitem" href="../Julia_event/">Events (callbacks, dosages etc...)</a></li></ul></li><li><span class="tocitem">Options for specific problem types</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li></ul></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Avaible_optimisers/">Available optimisers</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li><li><a class="tocitem" href="../optimisation_output_plotting/">Plots evaluating parameter estimation</a></li></ul></li><li><a class="tocitem" href="../HMC/">Bayesian inference</a></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li><a class="tocitem" href="../API_choosen/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Defining a PEtab problem in Julia</a></li><li class="is-active"><a href>Defining parameter estimation problems in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining parameter estimation problems in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/Define_in_julia.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="define_in_julia"><a class="docs-heading-anchor" href="#define_in_julia">Creating a PEtab Parameter Estimation Problem in Julia</a><a id="define_in_julia-1"></a><a class="docs-heading-anchor-permalink" href="#define_in_julia" title="Permalink"></a></h1><p>While the PEtab table format is excellent for specifying parameter estimation problems for dynamic ODE models, setting up a parameter estimation problem directly in Julia can be more convenient.</p><p>Here we demonstrate how to define a parameter estimation problem using a simple Micheli-Mentan model as an example. We will discuss in detail the five essential components required to define a problem:</p><ol><li><strong>Dynamic Model</strong>: You can use either a <code>ReactionSystem</code> defined in <a href="https://petab.readthedocs.io/en/latest/">Catalyst</a> or an <code>ODESystem</code> defined in <a href="https://github.com/SciML/ModelingToolkit.jl">ModellingToolkit</a>.</li><li><strong>Observable Formula</strong>: To link the model to the measurement data, you need an observable formula. Since real-world data often comes with measurement noise, you also must specify a noise formula and noise distribution. This is specified as a <code>PEtabObservable</code>.</li><li><strong>Parameters to Estimate</strong>: Typically, you do not want to estimate all model parameters. Moreover, sometimes you might want to incorporate prior beliefs by assigning priors to certain parameters. Parameter information is provided as a vector of <code>PEtabParameter</code>.</li><li><strong>Simulation Conditions</strong>: Measurements are often taken under various experimental conditions, such as different substrate concentrations. These experimental conditions typically correspond to model control parameters, like the initial value of a model species. You specify these conditions as a <code>Dict</code> (see below). In case the model only has a single simulation conditions, <code>simulation_conditions</code> can be omitted when building the <code>PEtabModel</code>.</li><li><strong>Measurement Data</strong>: To calibrate the model, you need measurement data, which should be provided as a <code>DataFrame</code>. The data format is explained below.</li></ol><h2 id="Defining-the-Dynamic-Model"><a class="docs-heading-anchor" href="#Defining-the-Dynamic-Model">Defining the Dynamic Model</a><a id="Defining-the-Dynamic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Dynamic-Model" title="Permalink"></a></h2><p>To define the dynamic model, you have two options; you can use a <a href="https://petab.readthedocs.io/en/latest/">Catalyst</a> defined <code>ReactionSystem</code>, or a <a href="https://github.com/SciML/ModelingToolkit.jl">ModellingToolkit</a> <code>ODESystem</code>. Using Catalyst we define the model as</p><pre><code class="language-julia hljs">using Catalyst
using PEtab

rn = @reaction_network begin
    @parameters se0
    @species SE(t) = se0
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end</code></pre><p>If you want to estimate the initial value of a species (like <code>SE</code>), you must define it as a parameter, as here with <code>SE(t) = se0</code>.</p><p>Using a ModellingToolkit <code>ODESystem</code> we define the model as:</p><pre><code class="language-julia hljs">using ModelingToolkit

@parameters c1, c2, c3, se0
@variables t S(t) SE(t) P(t) E(t)
D = Differential(t)
eqs = [
    D(S) ~ -c1*S*E + c2*SE,
    D(E) ~ -c1*S*E + c2*SE + c3*SE,
    D(SE) ~ c1*S*E - c2*SE - c3*SE,
    D(P) ~ c3*SE
]
@named sys = ODESystem(eqs; defaults=Dict(SE =&gt; se0))</code></pre><p>To estimate an initial value, such as <code>SE</code>, for an <code>ODESystem</code>, you need to define it using a dictionary under the <code>defaults</code> keyword, here done via <code>defaults = Dict(SE =&gt; se0)</code>.</p><p>Regardless of how the model is defined, if you want to fixate a parameter or initial value to a constant value across all simulations, you can use a state and/or parameter map. For instance, to set <code>E</code> and <code>P</code> to be 1.0 and 0.0, and set <code>c1</code> to 1.0, do:</p><pre><code class="language-julia hljs">state_map = [:E =&gt; 1.0, :P =&gt; 0.0]
parameter_map = [:c1 =&gt; 1.0]</code></pre><p>If a parameter or initial value is not specified anywhere it defaults to zero.</p><h2 id="Defining-the-Observable"><a class="docs-heading-anchor" href="#Defining-the-Observable">Defining the Observable</a><a id="Defining-the-Observable-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Observable" title="Permalink"></a></h2><p>To connect our model with measurement data, we need an observable formula. Since data from a reaction networks typically includes measurement noise, we also require a noise formula and a noise distribution.</p><p>Let us assume we are observing the product <code>P</code> with a normally distributed multiplicative measurement error (<code>sigma * P</code>) on a relative scale. To account for this relative scale we can as commonly done use <code>scale</code> and <code>offset</code> parameters. Additionally, let us assume we are directly measure the sum <code>E + SE</code> with log-normal measurement noise, and we already know the measurement error (<code>sigma</code>) is 3.0. This can be defined as</p><pre><code class="language-julia hljs">@unpack P, E, SE = rn
@parameters sigma, scale, offset
obs_P = PEtabObservable(scale * P + offset, sigma * P, transformation=:lin)
obs_Sum = PEtabObservable(E + SE, 3.0, transformation=:log)</code></pre><p>The <code>transformation</code> parameter can take one of three values: <code>:lin</code> (default for normal measurement noise), <code>:log</code>, or <code>:log10</code> (for log-normal measurement noise).</p><p>To complete the definition, we group these observables together in a <code>Dict</code> with appropriate names:</p><pre><code class="language-julia hljs">observables = Dict(&quot;obs_P&quot; =&gt; obs_P,
                   &quot;obs_Sum&quot; =&gt; obs_Sum)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, PEtabObservable{Symbolics.Num}} with 2 entries:
  &quot;obs_Sum&quot; =&gt; PEtabObservable: h = E(t) + SE(t), noise-formula = 3.0 and log-n…
  &quot;obs_P&quot;   =&gt; PEtabObservable: h = offset + scale*P(t), noise-formula = sigma*…</code></pre><h2 id="Defining-Parameters-to-Estimate"><a class="docs-heading-anchor" href="#Defining-Parameters-to-Estimate">Defining Parameters to Estimate</a><a id="Defining-Parameters-to-Estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Parameters-to-Estimate" title="Permalink"></a></h2><p>To set up a parameter estimation problem, we need to specify the parameters to estimate. To improve the estimation it is often beneficial to define lower and upper bounds to restrict the parameter space. For example, let us assume we want to estimate the parameter <code>c3</code> with bounds <code>[1e-3, 1e3]</code> (default):</p><pre><code class="language-julia hljs">_c3 = PEtabParameter(:c3, lb=1e-3, ub=1e3, scale=:log10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PEtabParameter c3. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03]</code></pre><p>Here <code>scale=:log10</code> means that we are estimating the parameter on a log10 scale, which typically yields better results than a linear-scale. Overall the <code>scale</code> parameter can take on three values: <code>:lin</code>, <code>:log</code>, and <code>:log10</code> (default).</p><p>If you have prior information about parameters, you can specify a continuous prior distribution from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>. For instance, if you want to estimate <code>se0</code> (the initial value of species <code>SE</code>) and you know it should be around 3.1, you can set a prior as:</p><pre><code class="language-julia hljs">using Distributions
_se0 = PEtabParameter(:se0, prior=LogNormal(log(3.1), 0.5),
                      prior_on_linear_scale=true, sample_from_prior=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PEtabParameter se0. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03] and prior Distributions.LogNormal{Float64}(μ=1.1314021114911006, σ=0.5)</code></pre><p>In this case, <code>prior_on_linear_scale=true</code> (default) indicates that the prior is defined on the linear scale, not the default transformed log10 scale used for parameter estimation. Moreover, for parameters with priors, start-guesses for parameter estimation are generated from the prior distribution (instead of randomly within the upper and lower bounds), if you want to disable this for a specific parameter set <code>sample_from_prior=false</code> (default is true), more information can be found <a href="../Parameter_estimation/#get_startguesses">here</a>.</p><p>Apart from estimating parameters in the reaction system, you can also estimate parameters related to measurement noise or parameters used exclusively in the observable formula (e.g., <code>scale</code> and <code>offset</code> parameters see above) by defining them as a <code>PEtabParameter</code>:</p><pre><code class="language-julia hljs"># Using default bounds [1e-3, 1e3] and scale=:log10
_sigma = PEtabParameter(:sigma)
_scale = PEtabParameter(:scale)
_offset = PEtabParameter(:offset)</code></pre><p>Once the parameters are defined they should be gathered into a vector</p><pre><code class="language-julia hljs">_c2 = PEtabParameter(:c2)
parameters = [_c2, _c3, _se0, _sigma, _scale, _offset]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{PEtabParameter}:
 PEtabParameter c2. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03]
 PEtabParameter c3. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03]
 PEtabParameter se0. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03] and prior Distributions.LogNormal{Float64}(μ=1.1314021114911006, σ=0.5)
 PEtabParameter sigma. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03]
 PEtabParameter scale. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03]
 PEtabParameter offset. Estimated on log10-scale with bounds [1.0e-03, 1.0e+03]</code></pre><h2 id="Defining-Simulation-Conditions"><a class="docs-heading-anchor" href="#Defining-Simulation-Conditions">Defining Simulation Conditions</a><a id="Defining-Simulation-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Simulation-Conditions" title="Permalink"></a></h2><p>Data is often collected under various experimental settings, such as different initial concentrations of a substrate. These variations in experimental conditions correspond to different simulation conditions during model calibration. To effectively align your measurements with the data, you need to specify these simulation conditions using a dictionary.</p><p>Specifically, assume you have measured your data under two conditions: <code>c0</code> and <code>c1</code>, where each condition has different starting concentrations for the substrate <code>S</code>. This can be defined as:</p><pre><code class="language-julia hljs">condition_c0 = Dict(:S =&gt; 5.0)
condition_c1 = Dict(:S =&gt; 2.0)</code></pre><p>Here, the key (in this case, <code>S</code>) can represent either a model species (as in this case) or a parameter. To complete the setup, gather all the simulation conditions in a dictionary, and assign each condition an appropriate name:</p><pre><code class="language-julia hljs">simulation_conditions = Dict(&quot;c0&quot; =&gt; condition_c0,
                             &quot;c1&quot; =&gt; condition_c1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Dict{Symbol, Float64}} with 2 entries:
  &quot;c1&quot; =&gt; Dict(:S=&gt;2.0)
  &quot;c0&quot; =&gt; Dict(:S=&gt;5.0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a parameter or species is specified for one simulation condition, it must be specified for all simulation conditions.</p></div></div><h2 id="Defining-Measurement-Data"><a class="docs-heading-anchor" href="#Defining-Measurement-Data">Defining Measurement Data</a><a id="Defining-Measurement-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Measurement-Data" title="Permalink"></a></h2><p>The measurement data should be organized as a <code>DataFrame</code> in the following format (the column names matter, but not the order)</p><table><tr><th style="text-align: right">simulation_id (str)</th><th style="text-align: right">obs_id (str)</th><th style="text-align: right">time (float)</th><th style="text-align: right">measurement (float)</th></tr><tr><td style="text-align: right">c0</td><td style="text-align: right">obs_P</td><td style="text-align: right">1.0</td><td style="text-align: right">0.7</td></tr><tr><td style="text-align: right">c0</td><td style="text-align: right">obs_Sum</td><td style="text-align: right">10.0</td><td style="text-align: right">0.1</td></tr><tr><td style="text-align: right">c1</td><td style="text-align: right">obs_P</td><td style="text-align: right">1.0</td><td style="text-align: right">1.0</td></tr><tr><td style="text-align: right">c1</td><td style="text-align: right">obs_Sum</td><td style="text-align: right">20.0</td><td style="text-align: right">1.5</td></tr></table><p>For each measurement, you need to specify:</p><ul><li><code>simulation_id</code>: Identifies the simulation condition it corresponds to.</li><li><code>obs_id</code>: Specifies the observable it corresponds to.</li><li><code>time</code>: Indicates the time point at which the data was collected.</li><li><code>measurement</code>: The actual measurement value.</li></ul><p>For this case, the input would look like;</p><pre><code class="language-julia hljs">using DataFrames

measurements = DataFrame(
    simulation_id=[&quot;c0&quot;, &quot;c0&quot;, &quot;c1&quot;, &quot;c1&quot;],
    obs_id=[&quot;obs_P&quot;, &quot;obs_Sum&quot;, &quot;obs_P&quot;, &quot;obs_Sum&quot;],
    time=[1.0, 10.0, 1.0, 20.0],
    measurement=[0.7, 0.1, 1.0, 1.5])</code></pre><div><div style = "float: left;"><span>4×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">simulation_id</th><th style = "text-align: left;">obs_id</th><th style = "text-align: left;">time</th><th style = "text-align: left;">measurement</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">c0</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">0.7</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">c0</td><td style = "text-align: left;">obs_Sum</td><td style = "text-align: right;">10.0</td><td style = "text-align: right;">0.1</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">c1</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">1.0</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">c1</td><td style = "text-align: left;">obs_Sum</td><td style = "text-align: right;">20.0</td><td style = "text-align: right;">1.5</td></tr></tbody></table></div><h2 id="Bringing-It-All-Together"><a class="docs-heading-anchor" href="#Bringing-It-All-Together">Bringing It All Together</a><a id="Bringing-It-All-Together-1"></a><a class="docs-heading-anchor-permalink" href="#Bringing-It-All-Together" title="Permalink"></a></h2><p>After defining the model, observables, parameters to estimate, simulation conditions, and measurement data, you can easily create a <code>PEtabODEProblem</code> for your parameter estimation task using the <code>ReactionSystem</code>:</p><pre><code class="language-julia hljs">petab_model = PEtabModel(rn, simulation_conditions, observables, measurements,
                         parameters, state_map=state_map, parameter_map=parameter_map,
                         verbose=false)
petab_problem = PEtabODEProblem(petab_model, verbose=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PEtabODEProblem for ReactionSystemModel. ODE-states: 4. Parameters to estimate: 6 where 3 are dynamic.
---------- Problem settings ----------
Gradient method : ForwardDiff
Hessian method : ForwardDiff
--------- ODE-solver settings --------
Cost Rodas5P. Options (abstol, reltol, maxiters) = (1.0e-08, 1.0e-08, 1.0e+04)
Gradient Rodas5P. Options (abstol, reltol, maxiters) = (1.0e-08, 1.0e-08, 1.0e+04)</code></pre><p>or the <code>ODESystem</code>:</p><pre><code class="language-julia hljs">petab_model = PEtabModel(sys, simulation_conditions, observables, measurements,
                         parameters, state_map=state_map, parameter_map=parameter_map,
                         verbose=false)
petab_problem = PEtabODEProblem(petab_model, verbose=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PEtabODEProblem for ODESystemModel. ODE-states: 4. Parameters to estimate: 6 where 3 are dynamic.
---------- Problem settings ----------
Gradient method : ForwardDiff
Hessian method : ForwardDiff
--------- ODE-solver settings --------
Cost Rodas5P. Options (abstol, reltol, maxiters) = (1.0e-08, 1.0e-08, 1.0e+04)
Gradient Rodas5P. Options (abstol, reltol, maxiters) = (1.0e-08, 1.0e-08, 1.0e+04)</code></pre><p>The <code>PEtabODEProblem</code> contains all the necessary information to work with most available optimizers (see <a href="../Boehm/#import_petab_problem">here</a>). Alternatively, if you want to perform parameter estimation using a multi-start approach, you can use the <code>calibrate_model_multistart</code> function (see <a href="../Parameter_estimation/#parameter_estimation">Parameter estimation</a>). When creating the <code>PEtabODEProblem</code> good default options are selected based on the problem size, but if you want to set any options, a full list is available <a href="../API_choosen/#API">here</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the model does not have multiple simulation conditions (e.g., data is collected under a single condition), you can omit the <code>simulation_conditions</code> argument when constructing the <code>PEtabModel</code> and the <code>simulation_id</code> columns from the measurement data. Simply use the following format: <code>PEtabModel(sys, observables, measurements, parameters, &lt;keyword arguments&gt;)</code>.</p></div></div><h2 id="Where-to-Go-Next"><a class="docs-heading-anchor" href="#Where-to-Go-Next">Where to Go Next</a><a id="Where-to-Go-Next-1"></a><a class="docs-heading-anchor-permalink" href="#Where-to-Go-Next" title="Permalink"></a></h2><p>This example has covered the fundamental aspects of setting up a parameter estimation problem directly Julia, but there are additional options:</p><ul><li><p><strong>Steady-State Initialization</strong>: In some cases, you might require your model to be at a steady-state at time zero when starting to match the model against data. To learn how to set up pre-equilibration criteria, see <a href="../Julia_steady_state/#define_with_ss">this</a> tutorial.</p></li><li><p><strong>Time-Point Specific Parameters</strong>: You might measure the same observable with different assays, leading to different observable parameters (e.g., scale and offset) and noise parameters for various time points. To handle time-point-specific measurement and noise parameters, see <a href="../Julia_obs_noise/#time_point_parameters">this</a> tutorial.</p></li><li><p><strong>Condition Specific System/Model Parameters</strong>: Sometimes a subset of model parameters, like protein synthesis rates, vary between simulation conditions, while other parameters remain constant across all conditions. To handle conditions specific parameters, see <a href="../Julia_condition_specific/#define_conditions">this</a> tutorial.</p></li><li><p><strong>Events</strong>: Sometimes a model incorporates events like substrate addition at specific time points, and/or parameter changes when a state/species reaches certain values. To manage these events/callbacks, see <a href="../Julia_event/#define_events">this</a> tutorial.</p></li></ul><p>For guidance on choosing the best options for your specific PEtab problem, we recommend the <a href="../Best_options/#best_options">Choosing the Best Options for a PEtab Problem</a> section and refer to the <a href="../Gradient_hessian_support/#gradient_support">Supported Gradient and Hessian Methods</a> section for more information on available gradient and hessian methods.</p><h2 id="Runnable-Example"><a class="docs-heading-anchor" href="#Runnable-Example">Runnable Example</a><a id="Runnable-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Runnable-Example" title="Permalink"></a></h2><p>Here is the complete code from the tutorial</p><pre><code class="language-julia hljs">using Catalyst
using DataFrames
using Distributions
using ModelingToolkit
using PEtab

# Define the reaction network
rn = @reaction_network begin
    @parameters se0
    @species SE(t) = se0  # se0 = initial value for S
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end

@parameters c1, c2, c3, se0
@variables t S(t) SE(t) P(t) E(t)
D = Differential(t)
eqs = [
    D(S) ~ -c1*S*E + c2*SE,
    D(E) ~ -c1*S*E + c2*SE + c3*SE,
    D(SE) ~ c1*S*E - c2*SE - c3*SE,
    D(P) ~ c3*SE
]
@named sys = ODESystem(eqs; defaults=Dict(SE =&gt; se0))

# Define state and parameter maps
state_map =  [:E =&gt; 1.0, :P =&gt; 0.0]
parameter_map = [:c1 =&gt; 1.0]

# Unpack model components
@unpack P, E, SE = rn
@parameters sigma, scale, offset

# Define observables
obs_P = PEtabObservable(scale * P + offset, sigma * P, transformation=:lin)
obs_Sum = PEtabObservable(E + SE, 3.0, transformation=:log)
observables = Dict(&quot;obs_P&quot; =&gt; obs_P,
                   &quot;obs_Sum&quot; =&gt; obs_Sum)

# Define parameters for estimation
_c3 = PEtabParameter(:c3, scale=:log10)
_se0 = PEtabParameter(:se0, prior=LogNormal(log(3.1), 0.5), 
                      prior_on_linear_scale=true, sample_from_prior=true)
_c2 = PEtabParameter(:c2)
_sigma = PEtabParameter(:sigma)
_scale = PEtabParameter(:scale)
_offset = PEtabParameter(:offset)
parameters = [_c2, _c3, _se0, _sigma, _scale, _offset]

# Define simulation conditions
condition_c0 = Dict(:S =&gt; 5.0)
condition_c1 = Dict(:S =&gt; 2.0)
simulation_conditions = Dict(&quot;c0&quot; =&gt; condition_c0,
                             &quot;c1&quot; =&gt; condition_c1)

# Define measurement data
measurements = DataFrame(
    simulation_id=[&quot;c0&quot;, &quot;c0&quot;, &quot;c1&quot;, &quot;c1&quot;],
    obs_id=[&quot;obs_P&quot;, &quot;obs_Sum&quot;, &quot;obs_P&quot;, &quot;obs_Sum&quot;],
    time=[1.0, 10.0, 1.0, 20.0],
    measurement=[0.7, 0.1, 1.0, 1.5]
)

# Create a PEtab model. To build the petab_model with ODE-system instead of
# ReactionSystem provide sys instead of rn as first argument
petab_model = PEtabModel(
    rn, simulation_conditions, observables, measurements,
    parameters, state_map=state_map, parameter_map=parameter_map, verbose=true
)

# Create a PEtabODEProblem
petab_problem = PEtabODEProblem(petab_model)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Boehm/">« Importing problems in PEtab standard format</a><a class="docs-footer-nextpage" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Friday 26 April 2024 18:44">Friday 26 April 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
