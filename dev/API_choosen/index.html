<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PEtab.jl</title><meta name="title" content="API · PEtab.jl"/><meta property="og:title" content="API · PEtab.jl"/><meta property="twitter:title" content="API · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><meta property="og:url" content="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><meta property="twitter:url" content="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Importing problems in PEtab standard format</a></li><li><span class="tocitem">Defining a PEtab problem in Julia</span><ul><li><a class="tocitem" href="../Define_in_julia/">Defining parameter estimation problems in Julia</a></li><li><a class="tocitem" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations)</a></li><li><a class="tocitem" href="../Julia_obs_noise/">Noise and observable parameters</a></li><li><a class="tocitem" href="../Julia_condition_specific/">Condition specific system/model parameters</a></li><li><a class="tocitem" href="../Julia_event/">Events (callbacks, dosages etc...)</a></li></ul></li><li><span class="tocitem">Options for specific problem types</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li></ul></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Avaible_optimisers/">Available optimisers</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li><li><a class="tocitem" href="../optimisation_output_plotting/">Plots evaluating parameter estimation</a></li></ul></li><li><a class="tocitem" href="../HMC/">Bayesian inference</a></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/API_choosen.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabModel(path_yaml::String;
           build_julia_files::Bool=false,
           verbose::Bool=true,
           ifelse_to_event::Bool=true,
           write_to_file::Bool=true,
           jlfile_path::String=&quot;&quot;)::PEtabModel</code></pre><p>Create a PEtabModel from a PEtab specified problem with a YAML-file located at <code>path_yaml</code>.</p><p>When parsing a PEtab problem, several things happen under the hood:</p><ol><li>The SBML file is translated into <code>ModelingToolkit.jl</code> format to allow for symbolic computations of the ODE-model Jacobian. Piecewise and model events are further written into <code>DifferentialEquations.jl</code> callbacks.</li><li>The observable PEtab table is translated into a Julia file with functions for computing the observable (<code>h</code>), noise parameter (<code>σ</code>), and initial values (<code>u0</code>).</li><li>To allow gradients via adjoint sensitivity analysis and/or forward sensitivity equations, the gradients of <code>h</code> and <code>σ</code> are computed symbolically with respect to the ODE model&#39;s states (<code>u</code>) and parameters (<code>ode_problem.p</code>).</li></ol><p>All of this happens automatically, and resulting files are stored under <code>petab_model.dir_julia</code> assuming write<em>to</em>file=true. To save time, <code>forceBuildJlFiles=false</code> by default, which means that Julia files are not rebuilt if they already exist.</p><p><strong>Arguments</strong></p><ul><li><code>path_yaml::String</code>: Path to the PEtab problem YAML file.</li><li><code>build_julia_files::Bool=false</code>: If <code>true</code>, forces the creation of Julia files for the problem even if they already exist.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, displays verbose output during parsing.</li><li><code>ifelse_to_event::Bool=true</code>: If <code>true</code>, rewrites <code>if-else</code> statements in the SBML model as event-based callbacks.</li><li><code>write_to_file::Bool=true</code>: If <code>true</code>, writes built Julia files to disk (recomended)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">petab_model = PEtabModel(&quot;path_to_petab_problem_yaml&quot;)</code></pre><pre><code class="nohighlight hljs">PEtabModel(system::Union{ReactionSystem, ODESystem},
           simulation_conditions::Dict{String, Dict},
           observables::Dict{String, PEtabObservable},
           measurements::DataFrame,
           petab_parameters::Vector{PEtabParameter};
           state_map::Union{Nothing, Vector{Pair}=nothing,
           parameter_map::Union{Nothing, Vector{Pair}=nothing,
           events::Union{Nothing, PEtabEvent, AbstractVector}=nothing,
           verbose::Bool=false)::PEtabModel</code></pre><p>Create a PEtabModel directly in Julia from a Catalyst reaction system or MTK ODESystem.</p><p>For additional information on the input format, see the main documentation.</p><p><strong>Arguments</strong></p><ul><li><code>system::Union{ReactionSystem, ODESystem}</code>: A Catalyst reaction system or a ModellingToolkit ODESystem</li><li><code>simulation_conditions::Dict{String, T}</code>: A dictionary specifying values for control parameters/species per simulation condition.</li><li><code>observables::Dict{String, PEtab.PEtabObservable}</code>: A dictionary specifying the observable and noise formulas linking the model to data.</li><li><code>measurements::DataFrame</code>: Measurement data to calibrate the model against.</li><li><code>petab_parameters::Vector{PEtab.PEtabParameter}</code>: Parameters to estimate in PEtabParameter format.</li><li><code>state_map=nothing</code>: An optional state-map to set initial species values to be constant across all simulation conditions.</li><li><code>parameter_map=nothing</code>: An optional state-map to set parameter values to be constant across all simulation conditions.</li><li><code>events=nothing</code>: Potential model event (callbacks) defined via <code>PEtabEvent</code>. In case of several events provide a vector of <code>PEtabEvent</code>.</li><li><code>verbose::Bool=false</code>: Whether to print progress when building the model.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Define a reaction network model
rn = @reaction_network begin
    @parameters a0 b0
    @species A(t)=a0 B(t)=b0
    (k1, k2), A &lt;--&gt; B
end

# Alternatively we can use an ODESystem (just use sys in PEtabModel)
@parameters a0 b0 k1 k2
@variables t A(t) B(t)
D = Differential(t)
eqs = [
    D(A) ~ -k1*A + k2*B
    D(B) ~ k1*A - k2*B
]
@named sys = ODESystem(eqs; defaults=Dict(A =&gt; a0, B =&gt; b0))

# Measurement data
measurements = DataFrame(
    simulation_id=[&quot;c0&quot;, &quot;c0&quot;],
    obs_id=[&quot;obs_a&quot;, &quot;obs_a&quot;],
    time=[0, 10.0],
    measurement=[0.7, 0.1],
    noise_parameters=0.5
)

# Single experimental condition
simulation_conditions = Dict(&quot;c0&quot; =&gt; Dict())

# PEtab-parameters to estimate
petab_parameters = [
    PEtabParameter(:a0, value=1.0, scale=:lin),
    PEtabParameter(:b0, value=0.0, scale=:lin),
    PEtabParameter(:k1, value=0.8, scale=:lin),
    PEtabParameter(:k2, value=0.6, scale=:lin)
]

# Observable equation
@unpack A = rn
observables = Dict(&quot;obs_a&quot; =&gt; PEtabObservable(A, 0.5))

# Create a PEtabODEProblem
petab_model = PEtabModel(
    rn, simulation_conditions, observables, measurements,
    petab_parameters, verbose=false
)</code></pre><pre><code class="nohighlight hljs">PEtabModel(system::Union{ReactionSystem, ODESystem},
           observables::Dict{String, PEtabObservable},
           measurements::DataFrame,
           petab_parameters::Vector{PEtabParameter};
           state_map::Union{Nothing, Vector{Pair}=nothing,
           parameter_map::Union{Nothing, Vector{Pair}=nothing,
           events::Union{Nothing, PEtabEvent, AbstractVector}=nothing,
           verbose::Bool=false)::PEtabModel</code></pre><p>Create a PEtabModel directly in Julia from a Catalyst ReactionSystem or MTK ODESystem without simulation conditions.</p><p>In case of simulation conditions, and for all arguments, see above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L174-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabODEProblem</code></pre><p>Everything needed to setup an optimization problem (compute cost, gradient, hessian and  parameter bounds) for a PEtab model.</p><p>For constructor, see below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parameter vector θ is always assumed to be on the parameter scale specified in the PEtab parameters file. If needed, θ is transformed to the linear scale inside the function call.</p></div></div><p><strong>Fields</strong></p><ul><li><code>compute_cost</code>: For θ computes the negative likelihood (objective to minimize)</li><li><code>compute_chi2</code>: For θ compute χ2 value</li><li><code>compute_gradient!</code>: For θ computes in-place gradient compute_gradient!(gradient, θ)</li><li><code>compute_gradient</code>: For θ computes out-place gradient gradient = compute_gradient(θ)</li><li><code>compute_hessian!</code>: For θ computes in-place hessian-(approximation) compute_hessian!(hessian, θ)</li><li><code>compute_hessian</code>: For θ computes out-place hessian-(approximation) hessian = compute_hessian(θ)</li><li><code>compute_FIM!</code>: For θ computes the empirical Fisher-Information-Matrix (FIM) which is the Hessian of the negative-log-likelihood  compute_FIM!(FIM, θ).</li><li><code>compute_FIM</code>: For θ computes FIM out of place FIM = compute_FIM(θ).</li><li><code>compute_simulated_values</code>: For θ compute the corresponding model (simulated) values to the measurements in the same order as in the Measurements PEtab table</li><li><code>compute_residuals</code>: For θ compute the residuals (h<em>model - h</em>observed)^2 / σ^2 in the same order as in the Measurements PEtab table</li><li><code>gradient_method</code>: The method used to compute the gradient (either :ForwardDiff, :ForwardEquations, :Adjoint, or :Zygote).</li><li><code>hessian_method</code>: The method used to compute or approximate the Hessian (either :ForwardDiff, :BlocForwardDiff, or :GaussNewton).</li><li><code>FIM_method</code>: The method used to compute FIM, either :ForwardDiff (full Hessian) or :GaussNewton (only recomended for &gt;100 parameter models)</li><li><code>n_parameters_esimtate</code>: The number of parameters to estimate.</li><li><code>θ_names</code>: The names of the parameters in θ.</li><li><code>θ_nominal</code>: The nominal values of θ as specified in the PEtab parameters file.</li><li><code>θ_nominalT</code>: The nominal values of θ on the parameter scale (e.g., log) as specified in the PEtab parameters file.</li><li><code>lower_bounds</code>: The lower parameter bounds on the parameter scale for θ as specified in the PEtab parameters file.</li><li><code>upper_bounds</code>: The upper parameter bounds on the parameter scale for θ as specified in the PEtab parameters file.</li><li><code>petab_model</code>: The PEtabModel used to construct the PEtabODEProblem.</li><li><code>ode_solver</code>: The options for the ODE solver specified when creating the PEtabODEProblem.</li><li><code>ode_solver_gradient</code>: The options for the ODE solver gradient specified when creating the PEtabODEProblem.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PEtabODEProblem(petab_model::PEtabModel; &lt;keyword arguments&gt;)</code></pre><p>Given a <code>PEtabModel</code> creates a <code>PEtabODEProblem</code> with potential user specified options.</p><p>The keyword arguments (described below) allows to choose cost, gradient, and Hessian methods, ODE solver options, and other tuneable options that can potentially make computations more efficient for some &quot;edge-case&quot; models. Please refer to the documentation for guidance on selecting the most efficient options for different types of models. If a keyword argument is not set, a suitable default option is chosen based on the number of model parameters.</p><p>Once created, a <code>PEtabODEProblem</code> contains everything needed to perform parameter estimtimation (see above)</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Every problem is unique, so even though the default settings often work well they might not be optimal.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>ode_solver::ODESolver</code>: Options for the ODE solver when computing the cost, such as solver and tolerances.</li><li><code>ode_solver_gradient::ODESolver</code>: Options for the ODE solver when computing the gradient, such as the ODE solver options used in adjoint sensitivity analysis. Defaults to <code>ode_solver</code> if not set to nothing.</li><li><code>ss_solver::SteadyStateSolver</code>: Options for finding steady-state for models with pre-equilibrium. Steady-state can be found via simulation or rootfinding, which can be set using <code>SteadyStateSolver</code> (see documentation). If not set, defaults to simulation with <code>wrms &lt; 1</code> termination.</li><li><code>ss_solver_gradient::SteadyStateSolver</code>: Options for finding steady-state for models with pre-equilibrium when computing gradients. Defaults to <code>ss_solver</code> value if not set.</li><li><code>cost_method::Symbol=:Standard</code>: Method for computing the cost (objective). Two options are available: <code>:Standard</code>, which is the most efficient, and <code>:Zygote</code>, which is less efficient but compatible with the Zygote automatic differentiation library.</li><li><code>gradient_method=nothing</code>: Method for computing the gradient of the objective. Four options are available:<ul><li><code>:ForwardDiff</code>: Compute the gradient via forward-mode automatic differentiation using ForwardDiff.jl. Most efficient for models with ≤50 parameters. The number of chunks can be optionally set using <code>chunksize</code>.</li><li><code>:ForwardEquations</code>: Compute the gradient via the model sensitivities, where <code>sensealg</code> specifies how to solve for the sensitivities. Most efficient when the Hessian is approximated using the Gauss-Newton method and when the optimizer can reuse the sensitivities (<code>reuse_sensitivities</code>) from gradient computations in Hessian computations (e.g., when the optimizer always computes the gradient before the Hessian).</li><li><code>:Adjoint</code>: Compute the gradient via adjoint sensitivity analysis, where <code>sensealg</code> specifies which algorithm to use. Most efficient for large models (≥75 parameters).</li><li><code>:Zygote</code>: Compute the gradient via the Zygote package, where <code>sensealg</code> specifies which sensitivity algorithm to use when solving the ODE model. This is the most inefficient option and not recommended.</li></ul></li><li><code>hessian_method=nothing</code>: method for computing the Hessian of the cost. There are three available options:<ul><li><code>:ForwardDiff</code>: Compute the Hessian via forward-mode automatic differentiation using ForwardDiff.jl. This is often only computationally feasible for models with ≤20 parameters but can greatly improve optimizer convergence.</li><li><code>:BlockForwardDiff</code>: Compute the Hessian block approximation via forward-mode automatic differentiation using ForwardDiff.jl. The approximation consists of two block matrices: the first is the Hessian for only the dynamic parameters (parameter part of the ODE system), and the second is for the non-dynamic parameters (e.g., noise parameters). This is computationally feasible for models with ≤20 dynamic parameters and often performs better than BFGS methods.</li><li><code>:GaussNewton</code>: Approximate the Hessian via the Gauss-Newton method, which often performs better than the BFGS method. If we can reuse the sensitivities from the gradient in the optimizer (see <code>reuse_sensitivities</code>), this method is best paired with <code>gradient_method=:ForwardEquations</code>.</li></ul></li><li><code>FIM_method=nothing</code>: Method for computing the empirical Fisher-Information-Matrix (FIM), can be:<ul><li><code>:ForwardDiff</code> - use ForwardDiff to compute the full Hessian (FIM) matrix, default for model with ≤ 100 parameters</li><li><code>:GaussNewton</code> - approximate the FIM as the Gauss-Newton Hessian approximation (only recomeded when ForwardDiff is computationally infeasible)</li></ul></li><li><code>sparse_jacobian::Bool=false</code>: When solving the ODE du/dt=f(u, p, t), whether implicit solvers use a sparse Jacobian. Sparse Jacobian often performs best for large models (≥100 states).</li><li><code>specialize_level=SciMLBase.FullSpecialize</code>: Specialization level when building the ODE problem. It is not recommended to change this parameter (see https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/).</li><li><code>sensealg</code>: Sensitivity algorithm for gradient computations. The available options for each gradient method are:<ul><li><code>:ForwardDiff</code>: None (as ForwardDiff takes care of all computation steps).</li><li><code>:ForwardEquations</code>: <code>:ForwardDiff</code> (uses ForwardDiff.jl and typicaly performs best) or <code>ForwardDiffSensitivity()</code> and <code>ForwardSensitivity()</code> from SciMLSensitivity.jl (https://github.com/SciML/SciMLSensitivity.jl).</li><li><code>:Adjoint</code>: <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> from SciMLSensitivity.jl.</li><li><code>:Zygote</code>: All sensealg in SciMLSensitivity.jl.</li></ul></li><li><code>sensealg_ss=nothing</code>: Sensitivity algorithm for adjoint gradient computations for steady-state simulations. The available options are <code>SteadyStateAdjoint()</code>, <code>InterpolatingAdjoint()</code>, and <code>QuadratureAdjoint()</code> from SciMLSensitivity.jl. <code>SteadyStateAdjoint()</code> is the most efficient but requires a non-singular Jacobian, and in the case of a non-singular Jacobian, the code automatically switches to <code>InterpolatingAdjoint()</code>.</li><li><code>chunksize=nothing</code>: Chunk-size for ForwardDiff.jl when computing the gradient and Hessian via forward-mode automatic differentiation. If nothing is provided, the default value is used. Tuning <code>chunksize</code> is non-trivial, and we plan to add automatic functionality for this.</li><li><code>split_over_conditions::Bool=false</code>: For gradient and Hessian via ForwardDiff.jl, whether or not to split calls to ForwardDiff across experimental (simulation) conditions. This parameter should only be set to true if the model has many parameters specific to an experimental condition; otherwise, the overhead from the calls will increase run time. See the Beer example for a case where this is needed.</li><li><code>reuse_sensitivities::Bool=false</code> : If set to <code>true</code>, reuse the sensitivities computed during gradient computations for the Gauss-Newton Hessian approximation. This option is only applicable when using <code>hessian_method=:GaussNewton</code> and <code>gradient_method=:ForwardEquations</code>. Note that it should only be used when the optimizer always computes the gradient before the Hessian.</li><li><code>verbose::Bool=true</code> : If set to <code>true</code>, print progress messages while setting up the PEtabODEProblem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L401-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabObservable" href="#PEtab.PEtabObservable"><code>PEtab.PEtabObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabObservable(obs_formula, noise_formula; transformation::Symbol=:lin)</code></pre><p>Links a model to measurements using an observable formula and measurement noise formula.</p><p>The <code>transformation</code> argument can take one of three values: <code>:lin</code> (for normal measurement noise), <code>:log</code>, or <code>:log10</code> (for log-normal measurement noise). For a full description of options, including how to define measurement-specific observable and noise parameters, see the main documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example 1: Log-normal measurement noise with known error σ=3.0
@unpack X = rn  # &#39;rn&#39; is the dynamic model
PEtabObservable(X, 3.0, transformation=:log)</code></pre><pre><code class="language-julia hljs"># Example 2: Normal measurement noise with estimation of σ (defined as PEtabParameter)
@unpack X, Y = rn  # &#39;rn&#39; is the dynamic model
@parameters sigma
PEtabObservable((X + Y) / X, sigma)</code></pre><pre><code class="language-julia hljs"># Example 3: Normal measurement noise with measurement-specific noiseParameter
@unpack X, Y = rn  # &#39;rn&#39; is the dynamic model
@parameters noiseParameter1  # Must be in the format &#39;noiseParameter&#39;
PEtabObservable(X, noiseParameter1 * X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L804-L829">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabParameter" href="#PEtab.PEtabParameter"><code>PEtab.PEtabParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabParameter(id::Union{Num, Symbol}; &lt;keyword arguments&gt;)</code></pre><p>Represents a parameter to be estimated in a PEtab model calibration problem.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>estimate::Bool=true</code>: Specifies whether the parameter should be estimated (default) or set as constant.</li><li><code>value::Union{Nothing, Float64}=nothing</code>: The parameter value to use if <code>estimate=false</code>. Defaults to the midpoint between <code>lb</code> and <code>ub</code>.</li><li><code>scale::Symbol=:log10</code>: The scale on which to estimate the parameter. Allowed options are <code>:log10</code> (default), <code>:log</code>, and <code>:lin</code>.</li><li><code>lb::Float64=1e-3</code>: The lower parameter bound in parameter estimation (default: 1e-3).</li><li><code>ub::Float64=1e-3</code>: The upper parameter bound in parameter estimation (default: 1e3).</li><li><code>prior=nothing</code>: An optional continuous prior distribution from the Distributions package.</li><li><code>prior_on_linear_scale::Bool=true</code>: Specifies whether the prior is on the linear scale (default) or the transformed scale, e.g., log10-scale.</li><li><code>sample_from_prior::Bool=true</code>: Whether to sample the parameter from the prior distribution when generating startguesses for model calibration.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example 1: Parameter with a Log-Normal prior (LN(μ=3.0, σ=1.0)) estimated on the log10 scale
PEtabParameter(:c1, prior=LogNormal(3.0, 1.0))</code></pre><pre><code class="language-julia hljs"># Example 2: Parameter estimated on the log scale with a Normal prior (N(0.0, 1.0)) on the log scale
PEtabParameter(:c1, scale=:log, prior=Normal(0.0, 1.0), prior_on_linear_scale=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L842-L866">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabEvent" href="#PEtab.PEtabEvent"><code>PEtab.PEtabEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabEvent(condition, affect, target)</code></pre><p>An event triggered by <code>condition</code> that sets the value of <code>target</code> to that of <code>affect</code>.</p><p>If <code>condition</code> is a single value or model parameter (e.g., <code>c1</code> or <code>1.0</code>), the event is triggered when time reaches that value (e.g., <code>t == c1</code> or <code>t == 1.0</code>). Condition can also depend on model states, for example, <code>S == 2.0</code> will trigger the event when the state <code>S</code> reaches the value 2.0. In contrast, <code>S &gt; 2.0</code> will trigger the condition when <code>S</code> increases from below 2.0 (specifically, the event is triggered when the condition changes from <code>false</code> to <code>true</code>). Note that the condition can contain model parameter values or species, e.g., <code>S &gt; c1</code>.</p><p><code>affect</code> can be a constant value (e.g., <code>1.0</code>) or an algebraic expression of model parameters/states. For example, to add <code>5.0</code> to the state <code>S</code>, write <code>S + 5</code>. In case an event affects several parameters and/or states provide affect as a <code>Vector</code>, for example <code>[S + 5, 1.0]</code>.</p><p><code>target</code> is either a model state or parameter that the event acts on. In case an event affects several states and/or parameters provide as a <code>Vector</code> where <code>target[i]</code> is the target of <code>affect[i]</code>.</p><p>For more details, see the documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the condition and target are single parameters or states, they can be specied as <code>Num</code> (from unpack) or <code>Symbol</code>. If the event involves multiple parameters or states, you must provide them as either a <code>Num</code> (as shown below) or a <code>String</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Catalyst
# Trigger event at t = 3.0, add 5 to A
rn = @reaction_network begin
    (k1, k2), A &lt;--&gt; B
end
@unpack A = rn
event = PEtabEvent(3.0, A + 5.0, A)</code></pre><pre><code class="language-julia hljs">using Catalyst
# Trigger event at t = k1, set k2 to 3
rn = @reaction_network begin
    (k1, k2), A &lt;--&gt; B
end
event = PEtabEvent(:k1, 3.0, :k2)</code></pre><pre><code class="language-julia hljs">using Catalyst
# Trigger event when A == 0.2, set B to 2.0
rn = @reaction_network begin
    (k1, k2), A &lt;--&gt; B
end
@unpack A, B = rn
event = PEtabEvent(A == 0.2, 2.0, B)</code></pre><pre><code class="language-julia hljs">using Catalyst
# Trigger event when A == 0.2, set B to 2.0 and A += 2
rn = @reaction_network begin
    (k1, k2), A &lt;--&gt; B
end
@unpack A, B = rn
event = PEtabEvent(A == 0.2, [A + 2, 2.0], [A, B])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L733-L795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.ODESolver" href="#PEtab.ODESolver"><code>PEtab.ODESolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODESolver(solver, &lt;keyword arguments&gt;)</code></pre><p>ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem.</p><p>More information about the available options and solvers can be found in the documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommended settings for which solver and options to use for different problems can be found below and in the documentation.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: Any of the ODE solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models, composite solvers such as <code>AutoVern7(Rodas5P())</code> perform well. For stiff small models, <code>Rodas5P()</code> performs well. For medium-sized models (≤75 states), <code>QNDF()</code>, <code>FBDF()</code>, and <code>CVODE_BDF()</code> perform well. <code>CVODE_BDF()</code> is not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic differentiation or if the Gauss-Newton Hessian approximation is used. If the gradient is computed via adjoint sensitivity analysis, <code>CVODE_BDF()</code> is often the best choice as it is typically more reliable than <code>QNDF()</code> and <code>FBDF()</code> (fails less often).</li><li><code>abstol=1e-8</code>: Absolute tolerance when solving the ODE system. Not recommended to increase above 1e-6 for gradients.</li><li><code>reltol=1e-8</code>: Relative tolerance when solving the ODE system. Not recommended to increase above 1e-6 for gradients.</li><li><code>force_dtmin=false</code>: Whether or not to force <code>dtmin</code> when solving the ODE system.</li><li><code>dtmin=nothing</code>: Minimal acceptable step-size when solving the ODE system.</li><li><code>maxiters=10000</code>: Maximum number of iterations when solving the ODE system. Increasing above the default value can cause the optimization to take substantial time.</li><li><code>verbose::Bool=true</code>: Whether or not warnings are displayed if the solver exits early. <code>true</code> is recommended in order to detect if a suboptimal ODE solver was chosen.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.SteadyStateSolver" href="#PEtab.SteadyStateSolver"><code>PEtab.SteadyStateSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolver(method::Symbol;
                  check_simulation_steady_state::Symbol=:wrms,
                  rootfinding_alg=nothing,
                  abstol=nothing,
                  reltol=nothing,
                  maxiters=nothing)</code></pre><p>Setup options for finding steady-state via either <code>method=:Rootfinding</code> or <code>method=:Simulate</code>.</p><p>For <code>method=:Rootfinding</code>, the steady-state <code>u*</code> is found by solving the problem <code>du = f(u, p, t) ≈ 0</code> with tolerances <code>abstol</code> and <code>reltol</code> via an automatically chosen optimization algorithm (<code>rootfinding_alg=nothing</code>) or via any provided algorithm in <a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a>.</p><p>For <code>method=:Simulate</code>, the steady-state <code>u*</code> is found by simulating the ODE system until <code>du = f(u, p, t) ≈ 0</code>. Two options are available for <code>check_simulation_steady_state</code>:</p><ul><li><code>:wrms</code> : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1</li><li><code>:Newton</code> : If Newton-step <code>Δu</code> is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1.       - Newton often performs better but requires an invertible Jacobian. In case it&#39;s not fulfilled, the code         switches automatically to <code>:wrms</code>.</li></ul><p><code>maxiters</code> refers to either the maximum number of rootfinding steps or the maximum number of integration steps, depending on the chosen method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L47-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.remake_PEtab_problem" href="#PEtab.remake_PEtab_problem"><code>PEtab.remake_PEtab_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remake_PEtab_problem(petab_problem::PEtabODEProblem, parameters_change::Dict) :: PEtabODEProblem</code></pre><p>Fixate model parameters for a given PEtabODEProblem without recompiling the problem.</p><p>This function allows you to modify parameters without the need to recompile the underlying code, resulting in reduced latency. To fixate the parameter k1, you can use <code>parameters_change=Dict(:k1 =&gt; 1.0)</code>.</p><p>If model derivatives are computed using ForwardDiff.jl with a chunk-size of N, the new PEtabODEProblem will only evaluate the necessary number of chunks of size N to compute the full gradient for the remade problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/PEtabODEProblem/Remake.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.Fides" href="#PEtab.Fides"><code>PEtab.Fides</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fides(hessian_method::Union{Nothing, Symbol}; verbose::Bool=false)</code></pre><p><a href="https://github.com/fides-dev/fides">Fides</a> is a Python Newton-trust region optimizer designed for box-bounded optimization problems.</p><p>It excels when the full Hessian is too computationally expensive, but a Gauss-Newton Hessian approximation can be calculated. When constructed with <code>Fides(verbose=true)</code>, it displays optimization progress during estimation.</p><p><strong>Hessian Methods</strong></p><p>If <code>hessian_method=nothing</code>, the Hessian method from the <code>PEtabODEProblem</code> is used, which can be either exact or a Gauss-Newton approximation. Additionally, Fides supports the following Hessian approximation methods:</p><ul><li><code>:BB</code>: Broyden&#39;s &quot;bad&quot; method</li><li><code>:BFGS</code>: Broyden-Fletcher-Goldfarb-Shanno update strategy</li><li><code>:BG</code>: Broyden&#39;s &quot;good&quot; method</li><li><code>:Broyden</code>: BroydenClass Update scheme</li><li><code>:SR1</code>: Symmetric Rank 1 update</li><li><code>:SSM</code>: Structured Secant Method</li><li><code>:TSSM</code>: Totally Structured Secant Method</li></ul><p>For more information on each method, see the Fides <a href="https://fides-optimizer.readthedocs.io/en/latest/generated/fides.hessian_approximation.html">documentation</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Fides with the Hessian method as in the PEtabProblem
fides_opt = Fides(nothing)</code></pre><pre><code class="language-julia hljs"># Fides with the BFGS Hessian approximation, with progress printing
fides_opt = Fides(:BFGS; verbose=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L531-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.OptimizationProblem" href="#PEtab.OptimizationProblem"><code>PEtab.OptimizationProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OptimizationProblem(petab_problem::PEtabODEProblem;
                    interior_point_alg::Bool = false,
                    box_constraints::Bool = true)</code></pre><p>Create an Optimization.jl <code>OptimizationProblem</code> from a <code>PEtabODEProblem</code>.</p><p>To utilize interior-point Newton methods (e.g. Optim <code>IPNewton</code> or <code>Ipopt</code>), set <code>interior_point_alg</code> to true.</p><p>To use algorithms not compatible with box-constraints (e.g., <code>NewtonTrustRegion</code>), set <code>box_constraints</code> to false. Note, with this options optimizers may move outside exceed the parameter bounds in the <code>petab_problem</code>, which can negatively impact performance.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Use IPNewton with startguess u0
using OptimizationOptimJL
prob = PEtab.OptimizationProblem(petab_problem, interior_point=true)
prob.u0 .= u0
sol = solve(prob, IPNewton())</code></pre><pre><code class="language-julia hljs"># Use Optim ParticleSwarm with startguess u0
using OptimizationOptimJL
prob = PEtab.OptimizationProblem(petab_problem)
prob.u0 .= u0
sol = solve(prob, Optim.ParticleSwarm())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Calibrate/Common.jl#L169-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.IpoptOptions" href="#PEtab.IpoptOptions"><code>PEtab.IpoptOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IpoptOptions(;print_level::Int64=0,
             max_iter::Int64=1000,
             tol::Float64=1e-8,
             acceptable_tol::Float64=1e-6,
             max_wall_time::Float64=1e20,
             acceptable_obj_change_tol::Float64=1e20)</code></pre><p>Wrapper for a subset of Ipopt options to set during parameter estimation.</p><p>For more information about each options see the Ipopt <a href="https://coin-or.github.io/Ipopt/OPTIONS.html">documentation</a></p><p><strong>Arguments</strong></p><ul><li><code>print_level</code>: Output verbosity level (valid values are 0 ≤ print_level ≤ 12)</li><li><code>max_iter</code>: Maximum number of iterations</li><li><code>tol</code>: Relative convergence tolerance</li><li><code>acceptable_tol</code>: Acceptable relative convergence tolerance</li><li><code>max_wall_time</code>: Max wall time optimisation is allowed to run</li><li><code>acceptable_obj_change_tol</code>: Acceptance stopping criterion based on objective function change.</li></ul><p>See also <a href="#PEtab.calibrate_model"><code>calibrate_model</code></a> and <a href="#PEtab.calibrate_model_multistart"><code>calibrate_model_multistart</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L601-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.IpoptOptimiser" href="#PEtab.IpoptOptimiser"><code>PEtab.IpoptOptimiser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IpoptOptimiser(LBFGS::Bool)</code></pre><p><a href="https://coin-or.github.io/Ipopt/">Ipopt</a> is an Interior-point Newton method designed for nonlinear optimization.</p><p>Ipopt can be configured to use either the Hessian method from the <code>PEtabODEProblem</code> (<code>LBFGS=false</code>) or a LBFGS scheme (<code>LBFGS=true</code>). For setting Ipopt options, see <a href="#PEtab.IpoptOptions"><code>IpoptOptions</code></a>.</p><p>See also <a href="#PEtab.calibrate_model"><code>calibrate_model</code></a> and <a href="#PEtab.calibrate_model_multistart"><code>calibrate_model_multistart</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Ipopt with the Hessian method as in the PEtabProblem
ipopt_opt = IpoptOptimiser(false)</code></pre><pre><code class="language-julia hljs"># Ipopt with LBFGS Hessian approximation
ipopt_opt = IpoptOptimiser(true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L577-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.calibrate_model" href="#PEtab.calibrate_model"><code>PEtab.calibrate_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calibrate_model(petab_problem::PEtabODEProblem,
                p0::Vector{Float64},
                alg;
                save_trace::Bool=false,
                options=algOptions)::PEtabOptimisationResult</code></pre><p>Parameter estimate a model for a PEtabODEProblem using an optimization algorithm <code>alg</code> and an initial guess <code>p0</code>.</p><p>The optimization algorithm <code>alg</code> can be one of the following:</p><ul><li><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim</a> LBFGS, BFGS, or IPNewton methods</li><li><a href="https://coin-or.github.io/Ipopt/">IpoptOptimiser</a> interior-point optimizer</li><li><a href="https://github.com/fides-dev/fides">Fides</a> Newton trust region method</li></ul><p>For how to use an OptimizationProblem from Optimization.jl see below.</p><p>Each algorithm accepts specific optimizer options in the format of the respective package. For a comprehensive list of available options, please refer to the main documentation.</p><p>If you want the optimizer to return parameter and objective trace information, set <code>save_trace=true</code>. Results are returned as a <code>PEtabOptimisationResult</code>, which includes the following information: minimum parameter values found (<code>xmin</code>), smallest objective value (<code>fmin</code>), number of iterations, runtime, whether the optimizer converged, and optionally, the trace.</p><pre><code class="nohighlight hljs">calibrate_model(optimization_problem::OptimizationProblem,
                petab_problem::PEtabODEProblem,
                p0::Vector{Float64},
                alg;
                kwargs...)</code></pre><p>Perform parameter estimation for an OptimizationProblem using algorithm <code>alg</code> and startguess <code>p0</code>.</p><p>To create an <code>OptimizationProblem</code> from a <code>PEtabODEProblem</code>, see PEtab.OptimizationProblem. All algorithms from Optimization.jl are supported. However, depending on the algorithm, different options must be specified when creating the <code>OptimizationProblem</code>.</p><p>Solver options are provided via keyword arguments, and a list can be found <a href="https://docs.sciml.ai/Optimization/stable/API/solve/">here</a>. To, for example, run calibration with <code>reltol=1e-8</code>, use <code>calibrate_model(prob, p0, alg; reltol=1e-8)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use Optim optimizers, you must load Optim with <code>using Optim</code>. To use Ipopt, you must load Ipopt with <code>using Ipopt</code>. To use Fides, load PyCall with <code>using PyCall</code> and ensure Fides is installed (see documentation for setup). To use Optimization load Optimization.jl with <code>using Optimization</code></p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Perform parameter estimation using Optim&#39;s IPNewton with a given initial guess
using Optim
res = calibrate_model(petab_problem, p0, Optim.IPNewton();
                     options=Optim.Options(iterations = 1000))</code></pre><pre><code class="language-julia hljs"># Perform parameter estimation using Fides with a given initial guess
using PyCall
res = calibrate_model(petab_problem, p0, Fides(nothing);
                     options=py&quot;{&#39;maxiter&#39; : 1000}&quot;o)</code></pre><pre><code class="language-julia hljs"># Perform parameter estimation using Ipopt and save the trace
using Ipopt
res = calibrate_model(petab_problem, p0, IpoptOptimiser(false);
                     options=IpoptOptions(max_iter = 1000),
                     save_trace=true)</code></pre><pre><code class="language-julia hljs"># Perform parameter estimation using Optimization
using Optimization
using OptimizationOptimJL
prob = PEtab.OptimizationProblem(petab_problem, interior_point_alg=true)
res = calibrate_model(prob, petab_problem, p0, IPNewton())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Calibrate/Common.jl#L1-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.calibrate_model_multistart" href="#PEtab.calibrate_model_multistart"><code>PEtab.calibrate_model_multistart</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calibrate_model_multistart(petab_problem::PEtabODEProblem,
                           alg,
                           n_multistarts::Signed,
                           dir_save::Union{Nothing, String};
                           sampling_method=QuasiMonteCarlo.LatinHypercubeSample(),
                           sample_from_prior::Bool=true,
                           options=options,
                           seed=nothing,
                           save_trace::Bool=false)::PEtabMultistartOptimisationResult</code></pre><p>Perform multistart optimization for a PEtabODEProblem using the algorithm <code>alg</code>.</p><p>The optimization algorithm <code>alg</code> can be one of the following:</p><ul><li><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim</a> LBFGS, BFGS, or IPNewton methods</li><li><a href="https://coin-or.github.io/Ipopt/">IpoptOptimiser</a> interior-point optimizer</li><li><a href="https://github.com/fides-dev/fides">Fides</a> Newton trust region method</li></ul><p>For each algorithm, optimizer options can be provided in the format of the respective package. For a comprehensive list of available options, please refer to the main documentation. If you want the optimizer to return parameter and objective trace information, set <code>save_trace=true</code>.</p><p>Multistart optimization involves generating multiple starting points for optimization runs. These starting points are generated using the specified <code>sampling_method</code> from <a href="https://github.com/SciML/QuasiMonteCarlo.jl">QuasiMonteCarlo.jl</a>, with the default being LatinHypercubeSample, a method that typically produces better results than random sampling. If <code>sample_from_prior=true</code> (default), for parameters with priors samples are taken from the prior distribution, where the distribution is clipped/truncated by the parameter&#39;s lower- and upper bound. For reproducibility, you can set a random number generator seed using the <code>seed</code> parameter.</p><p>If <code>dir_save</code> is provided as <code>nothing</code>, results are not written to disk. Otherwise, if a directory path is provided, results are written to disk. Writing results to disk is recommended in case the optimization process is terminated after a number of optimization runs.</p><p>The results are returned as a <code>PEtabMultistartOptimisationResult</code>, which stores the best-found minima (<code>xmin</code>), smallest objective value (<code>fmin</code>), as well as optimization results for each run.</p><pre><code class="nohighlight hljs">calibrate_model_multistart(optimization_problem::OptimizationProblem,
                           alg,
                           n_multistarts::Signed,
                           dir_save::Union{Nothing, String};
                           sampling_method=QuasiMonteCarlo.LatinHypercubeSample(),
                           sample_from_prior::Bool=true,
                           seed::Union{Nothing, Integer}=nothing,
                           kwargs...)::PEtabMultistartOptimisationResult</code></pre><p>Perform multistart optimization for a <code>OptimizationProblem</code> using the algorithm <code>alg</code>.</p><p>To create an <code>OptimizationProblem</code> from a <code>PEtabODEProblem</code>, see PEtab.OptimizationProblem. All algorithms from Optimization.jl are supported. However, depending on the algorithm, different options must be specified when creating the <code>OptimizationProblem</code>.</p><p>Solver options are provided via keyword arguments, and a list can be found <a href="https://docs.sciml.ai/Optimization/stable/API/solve/">here</a>. To, for example, run calibration with <code>reltol=1e-8</code>, use <code>calibrate_model_multistart(prob, alg, n, dir_save; reltol=1e-8)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use Optim optimizers, you must load Optim with <code>using Optim</code>. To use Ipopt, you must load Ipopt with <code>using Ipopt</code>. To use Fides, load PyCall with <code>using PyCall</code> and ensure Fides is installed (see documentation for setup). To use Optimization load Optimization.jl with <code>using Optimization</code></p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Perform 100 optimization runs using Optim&#39;s IPNewton, save results in dir_save
using Optim
dir_save = joinpath(@__DIR__, &quot;Results&quot;)
res = calibrate_model_multistart(petab_problem, Optim.IPNewton(), 100, dir_save;
                               options=Optim.Options(iterations = 1000))</code></pre><pre><code class="language-julia hljs"># Perform 100 optimization runs using Fides, save results in dir_save
using PyCall
dir_save = joinpath(@__DIR__, &quot;Results&quot;)
res = calibrate_model_multistart(petab_problem, Fides(nothing), 100, dir_save;
                               options=py&quot;{&#39;maxiter&#39; : 1000}&quot;o)</code></pre><pre><code class="language-julia hljs"># Perform 100 optimization runs using Ipopt, save results in dir_save. For each
# run save the trace
using Ipopt
dir_save = joinpath(@__DIR__, &quot;Results&quot;)
res = calibrate_model_multistart(petab_problem, IpoptOptimiser(false), 100, dir_save;
                               options=IpoptOptions(max_iter = 1000),
                               save_trace=true)</code></pre><pre><code class="language-julia hljs"># Perform 100 optimization runs using Optimization with IPNewton, save results in dir_save.
using Optimization
using OptimizationOptimJL
prob = PEtab.OptimizationProblem(petab_problem, interior_point_alg=true)
res = calibrate_model_multistart(prob, IPNewton(), 100, dir_save;
                                 reltol=1e-8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Calibrate/Common.jl#L75-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabMultistartOptimisationResult" href="#PEtab.PEtabMultistartOptimisationResult"><code>PEtab.PEtabMultistartOptimisationResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabMultistartOptimisationResult(dir_res::String; which_run::String=&quot;1&quot;)</code></pre><p>Read PEtab multistart optimization results saved at <code>dir_res</code>.</p><p>Each time a new optimization run is performed, results are saved with unique numerical endings appended to the directory specified by <code>dir_res</code>. Results from a specific run can be retreived by specifying the numerical ending by <code>which_run</code>. For example, to access results from the second run, set <code>which_run=&quot;2&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L654-L663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.run_PEtab_select" href="#PEtab.run_PEtab_select"><code>PEtab.run_PEtab_select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_PEtab_select(path_yaml, alg; &lt;keyword arguments&gt;)</code></pre><p>Given a PEtab-select YAML file perform model selection with the algorithms specified in the YAML file.</p><p>Results are written to a YAML file in the same directory as the PEtab-select YAML file.</p><p>Each candidate model produced during the model selection undergoes parameter estimation using local multi-start optimization. Three alg are supported: <code>optimizer=Fides()</code> (Fides Newton-trust region), <code>optimizer=IPNewton()</code> from Optim.jl, and <code>optimizer=LBFGS()</code> from Optim.jl. Additional keywords for the optimisation are <code>n_multistarts::Int</code>- number of multi-starts for parameter estimation (defaults to 100) and <code>optimizationSamplingMethod</code> - which is any sampling method from QuasiMonteCarlo.jl for generating start guesses (defaults to LatinHypercubeSample).</p><p>Simulation options can be set using any keyword argument accepted by the <code>PEtabODEProblem</code> function. For example, setting <code>gradient_method=:ForwardDiff</code> specifies the use of forward-mode automatic differentiation for gradient computation. If left blank, we automatically select appropriate options based on the size of the problem.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use Optim optimizers, you must load Optim with <code>using Optim</code>. To use Ipopt, you must load Ipopt with <code>using Ipopt</code>. To use Fides, load PyCall with <code>using PyCall</code> and ensure Fides is installed (see documentation for setup).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Calibrate/Common.jl#L200-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.generate_startguesses" href="#PEtab.generate_startguesses"><code>PEtab.generate_startguesses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_startguesses(petab_problem::PEtabODEProblem,
                      n_multistarts::Int64;
                      sampling_method::T=QuasiMonteCarlo.LatinHypercubeSample(),
                      sample_from_prior::Bool=true,
                      allow_inf_for_startguess::Bool=false,
                      verbose::Bool=false)::Array{Float64} where T &lt;: QuasiMonteCarlo.SamplingAlgorithm</code></pre><p>Generate <code>n_multistarts</code> initial parameter guesses within the parameter bounds in the <code>petab_problem</code> with <code>sampling_method</code></p><p>Any sampling algorithm from QuasiMonteCarlo is supported, but <code>LatinHypercubeSample</code> is recomended as it usually performs well. If <code>sample_from_prior=true</code> (default), for parameters with priors samples are taken from said prior distribution, where the distribution is clipped/truncated by the parameter&#39;s lower- and upper bound.</p><p>If <code>n_multistarts</code> is set to 1, a single random vector within the parameter bounds is returned. For <code>n_multistarts &gt; 1</code>, a matrix is returned, with each column representing a different initial guess.</p><p>By default <code>allow_inf_startguess=false</code> - only initial guesses that result in finite cost evaluations are returned. If <code>allow_inf_startguess=true</code>, initial guesses that result in <code>Inf</code> are allowed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate a single initial guess within the parameter bounds
start_guess = generate_startguesses(petab_problem, 1)</code></pre><pre><code class="language-julia hljs"># Generate 10 initial guesses using Sobol sampling
start_guess = generate_startguesses(petab_problem, 10,
                                    sampling_method=QuasiMonteCarlo.SobolSample())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Calibrate/Common.jl#L223-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_ps" href="#PEtab.get_ps"><code>PEtab.get_ps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ps(res::Union{PEtabOptimisationResult, PEtabMultistartOptimisationResult, Vector{Float64}},
       petab_problem::PEtabODEProblem;
       condition_id::Union{String, Symbol, Nothing}=nothing,
       retmap::Bool=true)</code></pre><p>From a fitted PEtab model or parameter vector retrieve the ODE parameters to simulate the model for the specified <code>condition_id</code>.</p><p>If <code>condition_id</code> is provided, the parameters are extracted for that specific simulation condition. If not provided, parameters for the first (default) simulation condition are returned.</p><p>If a parameter vector is provided it must have the parameters in the same order as <code>petab_problem.θ_names</code>.</p><p>If <code>retmap=true</code>, a parameter vector is returned; otherwise, a vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Utility.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_u0" href="#PEtab.get_u0"><code>PEtab.get_u0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_u0(res::Union{PEtabOptimisationResult, PEtabMultistartOptimisationResult, Vector{Float64}},
       petab_problem::PEtabODEProblem;
       condition_id::Union{String, Symbol}=nothing,
       pre_eq_id::Union{String, Symbol, Nothing}=nothing,
       retmap::Bool=true)</code></pre><p>From a fitted PEtab model or parameter vector retrieve the inital values (u0) to simulate the model for the specified <code>condition_id</code>.</p><p>If <code>condition_id</code> is provided, the initial values are extracted for that specific simulation condition. If not provided, initial values for the first (default) simulation condition are returned.</p><p>If a <code>pre_eq_id</code> is provided, the initial values are taken from the pre-equilibration simulation corresponding to <code>pre_eq_id</code>. If there are potential overrides of initial values in the simulation conditions, they take priority over the pre-equilibrium simulation.</p><p>If a parameter vector is provided it must have the parameters in the same order as <code>petab_problem.θ_names</code>.</p><p>If <code>retmap=true</code>, a parameter vector is returned; otherwise, a vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Utility.jl#L120-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_odeproblem" href="#PEtab.get_odeproblem"><code>PEtab.get_odeproblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_odeproblem(res::Union{PEtabOptimisationResult, PEtabMultistartOptimisationResult, Vector{Float64}},
               petab_problem::PEtabODEProblem;
               condition_id::Union{String, Symbol, Nothing}=nothing,
               pre_eq_id::Union{String, Symbol, Nothing}=nothing)</code></pre><p>From a fitted PEtab model or parameter vector retrieve the <code>ODEProblem</code> and callbacks to simulate the model for the specified <code>condition_id</code>.</p><p>If <code>condition_id</code> is provided, the parameters are extracted for that specific simulation condition. If not provided, parameters for the first (default) simulation condition are returned.</p><p>If a <code>pre_eq_id</code> is provided, the initial values are taken from the pre-equilibration simulation corresponding to <code>pre_eq_id</code>.</p><p>If a parameter vector is provided it must have the parameters in the same order as <code>petab_problem.θ_names</code>.</p><p>Potential events are returned as second argument, and potential time of events (<code>tstops</code>) are returned as third argument.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using OrdinaryDiffEq
# Solve the model with callbacks
prob, cb, tstops = get_odeproblem(res, petab_problem, condition_id=&quot;cond1&quot;)
sol = solve(prob, Rodas5P(), callback=cb, tstops=tstops)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Utility.jl#L49-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_odesol" href="#PEtab.get_odesol"><code>PEtab.get_odesol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_odesol(res::Union{PEtabOptimisationResult, PEtabMultistartOptimisationResult, Vector{Float64}},
           petab_problem::PEtabODEProblem;
           condition_id::Union{String, Symbol, Nothing}=nothing,
           pre_eq_id::Union{String, Symbol, Nothing}=nothing)</code></pre><p>From a fitted PEtab model or parameter vector retrieve the ODE solution for the specified <code>condition_id</code>.</p><p>If <code>condition_id</code> is provided, the parameters are extracted for that specific simulation condition. If not provided, parameters for the first (default) simulation condition are returned.</p><p>If a <code>pre_eq_id</code> is provided, the initial values are taken from the pre-equilibration simulation corresponding to <code>pre_eq_id</code>.</p><p>If a parameter vector is provided it must have the parameters in the same order as <code>petab_problem.θ_names</code>.</p><p>Potential events are accounted for when solving the ODE model. The ODE solver options specified when creating the <code>petab_problem</code> are used for solving the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Utility.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabLogDensity" href="#PEtab.PEtabLogDensity"><code>PEtab.PEtabLogDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabLogDensity(prob::PEtabODEProblem)</code></pre><p>Construct a <code>LogDensityProblem</code> using the likelihood and gradient method from the <code>PEtabODEProblem</code>.</p><p>This LogDensityProblem method defines everything needed to perform Bayesian inference with libraries such as <code>AdvancedHMC.jl</code> (which includes algorithms like NUTS, used by <code>Turing.jl</code>), <code>AdaptiveMCMC.jl</code> for adaptive Markov Chain Monte Carlo methods, and <code>Pigeon.jl</code> for parallel tempering methods. For examples on how to perform inference, see the documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/Structs.jl#L911-L920">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.to_prior_scale" href="#PEtab.to_prior_scale"><code>PEtab.to_prior_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_prior_scale(xpetab, target::PEtabLogDensity)::AbstractVector</code></pre><p>Transforms parameter <code>xpetab</code> from the PEtab problem scale to the prior scale.</p><p>This conversion is essential for Bayesian inference, as in PEtab.jl Bayesian inference is performed on the prior scale.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use this function Bijectors, LogDensityProblems, LogDensityProblemsAD must be loaded; <code>using Bijectors, LogDensityProblems, LogDensityProblemsAD</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/PEtab.jl#L106-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.to_chains" href="#PEtab.to_chains"><code>PEtab.to_chains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_chains(res, target::PEtabLogDensity; start_time=nothing, end_time=nothing)::MCMCChains</code></pre><p>Converts Bayesian inference results obtained with <code>PEtabLogDensity</code> into a <code>MCMCChains</code>.</p><p><code>res</code> can be the inference results from AdvancedHMC.jl, AdaptiveMCMC.jl, or Pigeon.jl. The out chain has the inferred parameters on the prior scale.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>start_time</code>: Optional starting time for the inference, obtained with <code>now()</code>.</li><li><code>end_time</code>: Optional ending time for the inference, obtained with <code>now()</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use this function MCMCChains must be loaded; <code>using MCMCChains</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/4e7a22ba0d9cc13b037c69bf12fc6b21c555bf3f/src/PEtab.jl#L120-L134">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Best_options/">« Choosing the best options for a PEtab problem</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 5 March 2024 10:08">Tuesday 5 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
