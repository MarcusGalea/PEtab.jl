<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PEtab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Importing a PEtab problem</a></li><li><span class="tocitem">Defining a PEtab problem in Julia</span><ul><li><a class="tocitem" href="../Define_in_julia/">Getting started</a></li><li><a class="tocitem" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations)</a></li><li><a class="tocitem" href="../Julia_obs_noise/">Noise and observable parameters</a></li></ul></li><li><span class="tocitem">Selecting options for a PEtab-problem</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li></ul></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Avaible_optimisers/">Available optimisers</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/API_choosen.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabModel</code></pre><p>A Julia-compatible representation of a PEtab-specified problem.</p><p>For how to construct see below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most of the functions in <code>PEtabModel</code> are not intended to be accessed by the user. For example, <code>compute_h</code>  (and similar functions) require indices that are built in the background to efficiently map parameters between  experimental (simulation) conditions. Rather, <code>PEtabModel</code> holds all information needed to create a  <code>PEtabODEProblem</code>, and in the future, <code>PEtabSDEProblem</code>, etc.</p></div></div><p><strong>Fields</strong></p><ul><li><code>model_name</code>: The model name extracted from the PEtab YAML file.</li><li><code>compute_h</code>: Computes the observable <code>h</code> for a specific time point and simulation condition.</li><li><code>compute_u0!</code>: Computes in-place initial values using <code>ODEProblem.p</code> for a simulation condition; <code>compute_u0!(u0, p)</code>.</li><li><code>compute_u0</code>: Computes initial values as above, but not in-place; <code>u0 = compute_u0(p)</code>.</li><li><code>compute_σ</code>: Computes the noise parameter <code>σ</code> for a specific time point and simulation condition.</li><li><code>compute_∂h∂u!</code>: Computes the gradient of <code>h</code> with respect to <code>ODEModel</code> states (<code>u</code>) for a specific time point and simulation condition.</li><li><code>compute_∂σ∂u!</code>: Computes the gradient of <code>σ</code> with respect to <code>ODEModel</code> states (<code>u</code>) for a specific time point and simulation condition.</li><li><code>compute_∂h∂p!</code>: Computes the gradient of <code>h</code> with respect to <code>ODEProblem.p</code>.</li><li><code>compute_∂σ∂p!</code>: Computes the gradient of <code>σ</code> with respect to <code>ODEProblem.p</code>.</li><li><code>compute_tstops</code>: Computes the event times in case the model has <code>DiscreteCallbacks</code> (events).</li><li><code>convert_tspan::Bool</code>: Tracks whether the time span should be converted to <code>Dual</code> numbers for <code>ForwardDiff.jl</code> gradients, in case the model has <code>DiscreteCallbacks</code> and the trigger time is a parameter set to be estimated.</li><li><code>dir_model</code>: The directory where the model.xml and PEtab files are stored.</li><li><code>dir_julia</code>: The directory where the Julia-model files created by parsing the PEtab files (e.g., SBML file) are stored.</li><li><code>ode_system</code>: A <code>ModellingToolkit.jl</code> ODE system obtained from parsing the model SBML file.</li><li><code>parameter_map</code>: A <code>ModellingToolkit.jl</code> parameter map for the ODE system.</li><li><code>state_map</code>: A <code>ModellingToolkit.jl</code> state map for the ODE system describing how the initial values are computed, e.g., whether or not certain initial values are computed from parameters in the <code>parameter_map</code>.</li><li><code>parameter_names</code>: The names of the parameters in the <code>ode_system</code>.</li><li><code>state_names</code>: The names of the states in the <code>ode_system</code>.</li><li><code>path_measurements</code>: The path to the PEtab measurements file.</li><li><code>path_conditions</code>: The path to the PEtab conditions file.</li><li><code>path_observables</code>: The path to the PEtab observables file.</li><li><code>path_parameters</code>: The path to the PEtab parameters file.</li><li><code>path_SBML</code>: The path to the PEtab SBML file.</li><li><code>path_yaml</code>: The path to the PEtab YAML file.</li><li><code>model_callbacks</code>: This stores potential model callbacks or events.</li><li><code>check_callback_is_active</code>: Piecewise SBML statements are transformed to DiscreteCallbacks that are activated at a specific time-point. The piecewise callback has a default value at t0 and is only triggered when reaching t<em>activation. If t</em>activation ≤ 0 (never reached when solving the model), this function checks whether the callback should be triggered before solving the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L1-L41">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PEtabModel</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Everything needed to setup an optimization problem (compute cost, gradient, hessian and  parameter bounds) for a PEtab model.</p><p>For how to construct, see below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parameter vector θ is always assumed to be on the parameter scale specified in the PEtab parameters file. If needed, θ is transformed to the linear scale inside the function call.</p></div></div><p><strong>Fields</strong></p><ul><li><code>compute_cost</code>: For θ computes the negative likelihood (objective to minimize)</li><li><code>compute_chi2</code>: For θ compute χ2 value</li><li><code>compute_gradient!</code>: For θ computes in-place gradient compute_gradient!(gradient, θ)</li><li><code>compute_gradient</code>: For θ computes out-place gradient gradient = compute_gradient(θ)</li><li><code>compute_hessian!</code>: For θ computes in-place hessian-(approximation) compute_hessian!(hessian, θ)</li><li><code>compute_hessian</code>: For θ computes out-place hessian-(approximation) hessian = compute_hessian(θ)</li><li><code>compute_simulated_values</code>: For θ compute the corresponding model (simulated) values to the measurements in the same order as in the Measurements PEtab table</li><li><code>compute_residuals</code>: For θ compute the residuals (h<em>model - h</em>observed)^2 / σ^2 in the same order as in the Measurements PEtab table</li><li><code>gradient_method</code>: The method used to compute the gradient (either :ForwardDiff, :ForwardEquations, :Adjoint, or :Zygote).</li><li><code>hessian_method</code>: The method used to compute or approximate the Hessian (either :ForwardDiff, :BlocForwardDiff, or :GaussNewton).</li><li><code>n_parameters_esimtate</code>: The number of parameters to estimate.</li><li><code>θ_names</code>: The names of the parameters in θ.</li><li><code>θ_nominal</code>: The nominal values of θ as specified in the PEtab parameters file.</li><li><code>θ_nominalT</code>: The nominal values of θ on the parameter scale (e.g., log) as specified in the PEtab parameters file.</li><li><code>lower_bounds</code>: The lower parameter bounds on the parameter scale for θ as specified in the PEtab parameters file.</li><li><code>upper_bounds</code>: The upper parameter bounds on the parameter scale for θ as specified in the PEtab parameters file.</li><li><code>petab_model</code>: The PEtabModel used to construct the PEtabODEProblem.</li><li><code>ode_solver</code>: The options for the ODE solver specified when creating the PEtabODEProblem.</li><li><code>ode_solver_gradient</code>: The options for the ODE solver gradient specified when creating the PEtabODEProblem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L241-L269">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PEtabODEProblem</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabObservable" href="#PEtab.PEtabObservable"><code>PEtab.PEtabObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabObservable(obs_formula, noise_formula; transformation::Symbol=:lin)</code></pre><p>Links a model to measurements using an observable formula and measurement noise formula.</p><p>The <code>transformation</code> argument can take one of three values: <code>:lin</code> (for normal measurement noise), <code>:log</code>, or <code>:log10</code> (for log-normal measurement noise). For a full description of options, including how to define measurement-specific observable and noise parameters, see the main documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example 1: Log-normal measurement noise with known error σ=3.0
@unpack X = rn  # &#39;rn&#39; is the dynamic model
PEtabObservable(X, 3.0, transformation=:log)</code></pre><pre><code class="language-julia hljs"># Example 2: Normal measurement noise with estimation of σ (defined as PEtabParameter)
@unpack X, Y = rn  # &#39;rn&#39; is the dynamic model
@parameters sigma
PEtabObservable((X + Y) / X, sigma)</code></pre><pre><code class="language-julia hljs"># Example 3: Normal measurement noise with measurement-specific noiseParameter
@unpack X, Y = rn  # &#39;rn&#39; is the dynamic model
@parameters noiseParameter1  # Must be in the format &#39;noiseParameter&#39;
PEtabObservable(X, noiseParameter1 * X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L521-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabParameter" href="#PEtab.PEtabParameter"><code>PEtab.PEtabParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabParameter(id::Symbol; &lt;keyword arguments&gt;)</code></pre><p>Represents a parameter to be estimated in a PEtab model calibration problem.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>estimate::Bool=true</code>: Specifies whether the parameter should be estimated (default) or set as constant.</li><li><code>value::Union{Nothing, Float64}=nothing</code>: The parameter value to use if <code>estimate=false</code>. Defaults to the midpoint between <code>lb</code> and <code>ub</code>.</li><li><code>scale::Symbol=:log10</code>: The scale on which to estimate the parameter. Allowed options are <code>:log10</code> (default), <code>:log</code>, and <code>:lin</code>.</li><li><code>lb::Float64=1e-3</code>: The lower parameter bound in parameter estimation (default: 1e-3).</li><li><code>ub::Float64=1e-3</code>: The upper parameter bound in parameter estimation (default: 1e3).</li><li><code>prior=nothing</code>: An optional continuous prior distribution from the Distributions package.</li><li><code>prior_on_linear_scale::Bool=true</code>: Specifies whether the prior is on the linear scale (default) or the transformed scale, e.g., log10-scale.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example 1: Parameter with a Log-Normal prior (LN(μ=3.0, σ=1.0)) estimated on the log10 scale
PEtabParameter(:c1, prior=LogNormal(3.0, 1.0))</code></pre><pre><code class="language-julia hljs"># Example 2: Parameter estimated on the log scale with a Normal prior (N(0.0, 1.0)) on the log scale
PEtabParameter(:c1, scale=:log, prior=Normal(0.0, 1.0), prior_on_linear_scale=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L559-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ODESolver" href="#PEtab.ODESolver"><code>PEtab.ODESolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODESolver(solver, &lt;keyword arguments&gt;)</code></pre><p>ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem.</p><p>More information about the available options and solvers can be found in the documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommended settings for which solver and options to use for different problems can be found below and in the documentation.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: Any of the ODE solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models, composite solvers such as <code>AutoVern7(Rodas5P())</code> perform well. For stiff small models, <code>Rodas5P()</code> performs well. For medium-sized models (≤75 states), <code>QNDF()</code>, <code>FBDF()</code>, and <code>CVODE_BDF()</code> perform well. <code>CVODE_BDF()</code> is not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic differentiation or if the Gauss-Newton Hessian approximation is used. If the gradient is computed via adjoint sensitivity analysis, <code>CVODE_BDF()</code> is often the best choice as it is typically more reliable than <code>QNDF()</code> and <code>FBDF()</code> (fails less often).</li><li><code>abstol=1e-8</code>: Absolute tolerance when solving the ODE system. Not recommended to increase above 1e-6 for gradients.</li><li><code>reltol=1e-8</code>: Relative tolerance when solving the ODE system. Not recommended to increase above 1e-6 for gradients.</li><li><code>force_dtmin=false</code>: Whether or not to force <code>dtmin</code> when solving the ODE system.</li><li><code>dtmin=nothing</code>: Minimal acceptable step-size when solving the ODE system.</li><li><code>maxiters=10000</code>: Maximum number of iterations when solving the ODE system. Increasing above the default value can cause the optimization to take substantial time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L83-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.SteadyStateSolver" href="#PEtab.SteadyStateSolver"><code>PEtab.SteadyStateSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolver(method::Symbol;
                  check_simulation_steady_state::Symbol=:wrms,
                  rootfinding_alg=nothing,
                  abstol=nothing,
                  reltol=nothing,
                  maxiters=nothing)</code></pre><p>Setup options for finding steady-state via either <code>method=:Rootfinding</code> or <code>method=:Simulate</code>.</p><p>For <code>method=:Rootfinding</code>, the steady-state <code>u*</code> is found by solving the problem <code>du = f(u, p, t) ≈ 0</code> with tolerances  <code>abstol</code> and <code>reltol</code> via an automatically chosen optimization algorithm (<code>rootfinding_alg=nothing</code>) or via any  provided algorithm in <a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a>.</p><p>For <code>method=:Simulate</code>, the steady-state <code>u*</code> is found by simulating the ODE system until <code>du = f(u, p, t) ≈ 0</code>.  Two options are available for <code>check_simulation_steady_state</code>:</p><ul><li><code>:wrms</code> : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1</li><li><code>:Newton</code> : If Newton-step <code>Δu</code> is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1.       - Newton often performs better but requires an invertible Jacobian. In case it&#39;s not fulfilled, the code          switches automatically to <code>:wrms</code>.</li></ul><p><code>maxiters</code> refers to either the maximum number of rootfinding steps or the maximum number of integration steps,  depending on the chosen method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L117-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.remake_PEtab_problem" href="#PEtab.remake_PEtab_problem"><code>PEtab.remake_PEtab_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remake_PEtab_problem(petab_problem::PEtabODEProblem, parameters_change::Dict) :: PEtabODEProblem</code></pre><p>Fixate model parameters for a given PEtabODEProblem without recompiling the problem.</p><p>This function allows you to modify parameters without the need to recompile the underlying code, resulting in reduced latency. To fixate the parameter k1, you can use <code>parameters_change=Dict(:k1 =&gt; 1.0)</code>.</p><p>If model derivatives are computed using ForwardDiff.jl with a chunk-size of N, the new PEtabODEProblem will only evaluate the necessary number of chunks of size N to compute the full gradient for the remade problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/Create_PEtabODEProblem/Remake_PEtabODEProblem.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.Fides" href="#PEtab.Fides"><code>PEtab.Fides</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fides(hessian_method::Union{Nothing, Symbol}; verbose::Bool=false)</code></pre><p><a href="https://github.com/fides-dev/fides">Fides</a> is a Python Newton-trust region optimizer designed for box-bounded optimization problems.</p><p>It excels when the full Hessian is too computationally expensive, but a Gauss-Newton Hessian approximation can be calculated. When constructed with <code>Fides(verbose=true)</code>, it displays optimization progress during estimation.</p><p><strong>Hessian Methods</strong></p><p>If <code>hessian_method=nothing</code>, the Hessian method from the <code>PEtabODEProblem</code> is used, which can be either exact or a Gauss-Newton approximation. Additionally, Fides supports the following Hessian approximation methods:</p><ul><li><code>:BB</code>: Broyden&#39;s &quot;bad&quot; method</li><li><code>:BFGS</code>: Broyden-Fletcher-Goldfarb-Shanno update strategy</li><li><code>:BG</code>: Broyden&#39;s &quot;good&quot; method</li><li><code>:Broyden</code>: BroydenClass Update scheme </li><li><code>:SR1</code>: Symmetric Rank 1 update</li><li><code>:SSM</code>: Structured Secant Method</li><li><code>:TSSM</code>: Totally Structured Secant Method</li></ul><p>For more information on each method, see the Fides <a href="https://fides-optimizer.readthedocs.io/en/latest/generated/fides.hessian_approximation.html">documentation</a>.</p><p>See also <a href="@ref"><code>callibrateModel</code></a> and <a href="@ref"><code>callibrateModelMultistart</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Fides with the Hessian method as in the PEtabProblem
fides_opt = Fides(nothing)</code></pre><pre><code class="language-julia hljs"># Fides with the BFGS Hessian approximation, with progress printing
fides_opt = Fides(:BFGS; verbose=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L383-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.IpoptOptions" href="#PEtab.IpoptOptions"><code>PEtab.IpoptOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IpoptOptions(;print_level::Int64=0, 
             max_iter::Int64=1000, 
             tol::Float64=1e-8, 
             acceptable_tol::Float64=1e-6, 
             max_wall_time::Float64=1e20, 
             acceptable_obj_change_tol::Float64=1e20)</code></pre><p>Wrapper for a subset of Ipopt options to set during parameter estimation.</p><p>For more information about each options see the Ipopt <a href="https://coin-or.github.io/Ipopt/OPTIONS.html">documentation</a></p><p><strong>Arguments</strong></p><ul><li><code>print_level</code>: Output verbosity level (valid values are 0 ≤ print_level ≤ 12)</li><li><code>max_iter</code>: Maximum number of iterations</li><li><code>tol</code>: Relative convergence tolerance</li><li><code>acceptable_tol</code>: Acceptable relative convergence tolerance</li><li><code>max_wall_time</code>: Max wall time optimisation is allowed to run</li><li><code>acceptable_obj_change_tol</code>: Acceptance stopping criterion based on objective function change.</li></ul><p>See also <a href="#PEtab.calibrate_model"><code>calibrate_model</code></a> and <a href="#PEtab.calibrate_model_multistart"><code>calibrate_model_multistart</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L456-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.IpoptOptimiser" href="#PEtab.IpoptOptimiser"><code>PEtab.IpoptOptimiser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IpoptOptimiser(LBFGS::Bool)</code></pre><p><a href="https://coin-or.github.io/Ipopt/">Ipopt</a> is an Interior-point Newton method designed for nonlinear optimization.</p><p>Ipopt can be configured to use either the Hessian method from the <code>PEtabODEProblem</code> (<code>LBFGS=false</code>) or a LBFGS scheme (<code>LBFGS=true</code>).  For setting Ipopt options, see <a href="#PEtab.IpoptOptions"><code>IpoptOptions</code></a>.</p><p>See also <a href="#PEtab.calibrate_model"><code>calibrate_model</code></a> and <a href="#PEtab.calibrate_model_multistart"><code>calibrate_model_multistart</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Ipopt with the Hessian method as in the PEtabProblem
ipopt_opt = IpoptOptimiser(false)</code></pre><pre><code class="language-julia hljs"># Ipopt with LBFGS Hessian approximation
ipopt_opt = IpoptOptimiser(true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/PEtab_structs.jl#L431-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calibrate_model" href="#PEtab.calibrate_model"><code>PEtab.calibrate_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calibrate_model(petab_problem::PEtabODEProblem,
                p0::Vector{Float64},
                alg;
                save_trace::Bool=false,
                options=algOptions)::PEtabOptimisationResult</code></pre><p>Parameter estimate a model for a PEtabODEProblem using an optimization algorithm <code>alg</code> and an initial guess <code>p0</code>.</p><p>The optimization algorithm <code>alg</code> can be one of the following:</p><ul><li><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim</a> LBFGS, BFGS, or IPNewton methods</li><li><a href="https://coin-or.github.io/Ipopt/">IpoptOptimiser</a> interior-point optimizer</li><li><a href="https://github.com/fides-dev/fides">Fides</a> Newton trust region method</li></ul><p>Each algorithm accepts specific optimizer options in the format of the respective package. For a comprehensive list of available options, please refer to the main documentation.</p><p>If you want the optimizer to return parameter and objective trace information, set <code>save_trace=true</code>. Results are returned as a <code>PEtabOptimisationResult</code>, which includes the following information: minimum parameter values found (<code>xmin</code>), smallest objective value (<code>fmin</code>), number of iterations, runtime, whether the optimizer converged, and optionally, the trace.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use Optim optimizers, you must load Optim with <code>using Optim</code>. To use Ipopt, you must load Ipopt with <code>using Ipopt</code>.  To use Fides, load PyCall with <code>using PyCall</code> and ensure Fides is installed (see documentation for setup).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Perform parameter estimation using Optim&#39;s IPNewton with a given initial guess
using Optim
res = calibrate_model(petab_problem, p0, Optim.IPNewton();
                     options=Optim.Options(iterations = 1000))</code></pre><pre><code class="language-julia hljs"># Perform parameter estimation using Fides with a given initial guess
using PyCall
res = calibrate_model(petab_problem, p0, Fides(nothing);
                     options=py&quot;{&#39;maxiter&#39; : 1000}&quot;o)</code></pre><pre><code class="language-julia hljs"># Perform parameter estimation using Ipopt and save the trace
using Ipopt
res = calibrate_model(petab_problem, p0, IpoptOptimiser(false);
                     options=IpoptOptions(max_iter = 1000), 
                     save_trace=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/Model_callibration/Common.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calibrate_model_multistart" href="#PEtab.calibrate_model_multistart"><code>PEtab.calibrate_model_multistart</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calibrate_model_multistart(petab_problem::PEtabODEProblem,
                         alg,
                         n_multistarts::Signed,
                         dir_save::Union{Nothing, String};
                         sampling_method=QuasiMonteCarlo.LatinHypercubeSample(),
                         options=algOptions,
                         seed=nothing,
                         save_trace::Bool=false)::PEtabMultistartOptimisationResult</code></pre><p>Perform multistart optimization for a PEtabODEProblem using the algorithm <code>alg</code>.</p><p>The optimization algorithm <code>alg</code> can be one of the following:</p><ul><li><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim</a> LBFGS, BFGS, or IPNewton methods</li><li><a href="https://coin-or.github.io/Ipopt/">IpoptOptimiser</a> interior-point optimizer</li><li><a href="https://github.com/fides-dev/fides">Fides</a> Newton trust region method</li></ul><p>For each algorithm, optimizer options can be provided in the format of the respective package. For a comprehensive list of available options, please refer to the main documentation. If you want the optimizer to return parameter and objective trace information, set <code>save_trace=true</code>.</p><p>Multistart optimization involves generating multiple starting points for optimization runs. These starting points are generated using the specified <code>sampling_method</code> from <a href="https://github.com/SciML/QuasiMonteCarlo.jl">QuasiMonteCarlo.jl</a>, with the default being LatinHypercubeSample, a method that typically produces better results than random sampling. For reproducibility, you can set a random number generator seed using the <code>seed</code> parameter.</p><p>If <code>dir_save</code> is provided as <code>nothing</code>, results are not written to disk. Otherwise, if a directory path is provided, results are written to disk. Writing results to disk is recommended in case the optimization process is terminated after a number of optimization runs.</p><p>The results are returned as a <code>PEtabMultistartOptimisationResult</code>, which stores the best-found minima (<code>xmin</code>), smallest objective value (<code>fmin</code>), as well as optimization results for each run.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use Optim optimizers, you must load Optim with <code>using Optim</code>. To use Ipopt, you must load Ipopt with <code>using Ipopt</code>.  To use Fides, load PyCall with <code>using PyCall</code> and ensure Fides is installed (see documentation for setup).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Perform 100 optimization runs using Optim&#39;s IPNewton, save results in dir_save
using Optim
dir_save = joinpath(@__DIR__, &quot;Results&quot;)
res = calibrate_model_multistart(petab_problem, Optim.IPNewton(), 100, dir_save;
                               options=Optim.Options(iterations = 1000))</code></pre><pre><code class="language-julia hljs"># Perform 100 optimization runs using Fides, save results in dir_save
using PyCall
dir_save = joinpath(@__DIR__, &quot;Results&quot;)
res = calibrate_model_multistart(petab_problem, Fides(nothing), 100, dir_save;
                               options=py&quot;{&#39;maxiter&#39; : 1000}&quot;o)</code></pre><pre><code class="language-julia hljs"># Perform 100 optimization runs using Ipopt, save results in dir_save. For each 
# run save the trace 
using Ipopt
dir_save = joinpath(@__DIR__, &quot;Results&quot;)
res = calibrate_model_multistart(petab_problem, IpoptOptimiser(false), 100, dir_save;
                               options=IpoptOptions(max_iter = 1000), 
                               save_trace=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/Model_callibration/Common.jl#L51-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.run_PEtab_select" href="#PEtab.run_PEtab_select"><code>PEtab.run_PEtab_select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_PEtab_select(path_yaml, alg; &lt;keyword arguments&gt;)</code></pre><p>Given a PEtab-select YAML file perform model selection with the algorithms specified in the YAML file.</p><p>Results are written to a YAML file in the same directory as the PEtab-select YAML file.</p><p>Each candidate model produced during the model selection undergoes parameter estimation using local multi-start optimization. Three alg are supported: <code>optimizer=Fides()</code> (Fides Newton-trust region), <code>optimizer=IPNewton()</code> from Optim.jl, and <code>optimizer=LBFGS()</code> from Optim.jl. Additional keywords for the optimisation are <code>n_multistarts::Int</code>- number of multi-starts for parameter estimation (defaults to 100) and <code>optimizationSamplingMethod</code> - which is any sampling method from QuasiMonteCarlo.jl for generating start guesses (defaults to LatinHypercubeSample).</p><p>Simulation options can be set using any keyword argument accepted by the <code>PEtabODEProblem</code> function. For example, setting <code>gradient_method=:ForwardDiff</code> specifies the use of forward-mode automatic differentiation for gradient computation. If left blank, we automatically select appropriate options based on the size of the problem.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use Optim optimizers, you must load Optim with <code>using Optim</code>. To use Ipopt, you must load Ipopt with <code>using Ipopt</code>. To use Fides, load PyCall with <code>using PyCall</code> and ensure Fides is installed (see documentation for setup).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/Model_callibration/Common.jl#L116-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.solve_SBML" href="#PEtab.solve_SBML"><code>PEtab.solve_SBML</code></a> — <span class="docstring-category">Function</span></header><section><div><p>solve<em>SBML(path</em>SBML, solver, tspan; abstol=1e-8, reltol=1e-8, saveat=Float64[], verbose=true)</p><p>Solve an ODE SBML model at the values reported in the SBML file over the specified time span (t0::Float, tend::Float).</p><p>Solvers from the OrdinaryDiffEq.jl package are supported. If you want to save the ODE solution at specific time-points,  e.g., [1.0, 3.0], provide the <code>saveat</code> argument as <code>saveat=[1.0, 3.0]</code>. The output is provided in the format of OrdinaryDiffEq.jl.  The Julia model files are saved in the same directory as the SBML file, in a subdirectory named &quot;SBML&quot;.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is primarily intended for testing the SBML importer.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/16f73fdcb04592c93612e1dc2949f50f12cced18/src/SBML/Solve_SBML_model.jl#L1-L12">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Best_options/">« Choosing the best options for a PEtab problem</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 22 September 2023 04:27">Friday 22 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
