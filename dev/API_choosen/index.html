<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PEtab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Brannmark/">Models with preequilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/API_choosen.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabModel

A PEtab specified problem translated into a Julia compatible format.

Created from `readPEtabModel` contains helper functions needed to set up cost-, gradient-, hessian-computations, and 
for handling potential model events (callbacks). 

Note1 - Several of the functions in the PEtabModel are not meant to be accessible for the user. For example 
compute_h (and similar functions) require indices which are built in the background to efficiently map parameter 
between experimental (simulation) conditions. Rather, `PEtabModel` holds all information needed to create a 
PEtabODEProblem, and in the future PEtabSDEProblem etc ...
Note2 - ODEProblem.p refers to the parameters for underlying DifferentialEquations.jl ODEProblem.

# Fields
`modelName`: Model-name extracted from the PEtab yaml-file. 
`compute_h`: Compute the observable (h) for a specific time-point and simulation condition.
`compute_u0!`: In-place initial values using the ODEProblem.p for a simulation condition; compute_u0!(u0, p)
`compute_u0`: As above but not in-place; u0 = compute_u0(p)
`compute_σ`: Compute the noise parameter σ for specific time-point and simulation condition.
`compute_∂h∂u!`: Compute the gradient of h with respect to ODE-model states (u) for a specific time-point and 
 simulation condition.
`compute_∂σ∂u!`: As above but for the noise parameter σ
`compute_∂h∂p!`: As above for h but with respect to ODEProblem.p
`compute_∂σ∂p!`: As above for σ but with respect to ODEProblem.p
`computeTStops`: In case the model has DiscreteCallbacks (events) this function computes the event times. 
`convertTspan::Bool`: In case the model has DiscreteCallbacks (events) and the trigger-time is a parameter set to 
 be estimated this Bool tracks that for ForwardDiff.jl gradients the time-span should be converted to Dual-numbers. 
`dirModel`: Directory where the model.xml and PEtab files are stored.
`dirJulia`: Directory where the Julia-model files created by parsing the PEtab files (e.g SBML-file) are stored. 
`odeSystem`: A ModellingToolkit.jl ODE-system obtained from parsing the model SBML-file.  
`parameterMap`: A ModellingToolkit.jl parameter map for the ODE-system.
`stateMap`: A ModellingToolkit.jl state map for the ODE-system describing how the inital values are computed, e.g.
 whether or not certain initial values are computed from parameters in the parameterMap.
`parameterNames`: Names of the parameter in the odeSystem.
`stateNames`: Names of the states in the odeSystem.
`pathMeasurements`: Path to the PEtab measurements file
`pathConditions`: Path to the PEtab conditions file
`pathObservables`: Path to the PEtab observables file
`pathParameters`: Path to the PEtab parameters file
`pathSBML`: Path to the PEtab SBML file
`pathYAML`: Path to the PEtab yaml file
`modelCallbackSet`: Stores potential model callbacks (events)
`checkIfCallbackIsActive`: Piecewise SBML statements are rewritten to DiscreteCallbacks that are activated at a
specific time-point. The piecewise callback has a defult value at t0 which is only triggered upon reaching t_activation.
In case t_activation ≤ 0 (never reached when solvig the model) this function checks whether or not the callback 
should be triggered before solving the model.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/PEtab_structs.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabODEProblem

All needed to setup an optimization problem (compute cost, gradient, hessian and parameter bounds) for a PEtab model.

The PEtabODEproblem for a PEtab problem allows for efficient cost, gradient and hessian computations. Constructed
via `setupPEtabODEProblem`, more info on tuneable options can be found in the documentation [add]. 

**Note** - the parameter vector θ is **always** assumed to be on parameter scale specified in the PEtab parameters 
file. If needed θ is transformed to linear scale inside of the function call. 

# Fields
`computeCost`: For θ computes the objective value cost = computeCost(θ)
`computeGradient!`: For θ computes in-place gradient computeGradient!(gradient, θ)
`computeHessian!`: For θ computes in-place hessian-(approximation) computeHessian!(hessian, θ)
`costMethod`: Method for computing the cost (:Standard, :Zygote)
`gradientMethod`: Method for computing the gradient (:ForwardDiff, :ForwardEquations :Adjoint, :Zygote)
`hessianMethod`:  Method for computing/approximating the hessian (:ForwardDiff, :BlocForwardDiff :GaussNewton)
`nParametersToEstimate`: Number of parameter to estimate.
`θ_estNames`: Names of the parameter in θ
`θ_nominal`: Nominal θ values as specified in the PEtab parameters-file. 
`θ_nominalT`: Nominal θ values on parameter-scale (e.g log) as specified in the PEtab parameters-file.
`lowerBounds`: Lower parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.
`upperBounds`: Upper parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.
`petabModel`: PEtabModel used to construct the PEtabODEProblem
`odeSolverOptions`: ODE-solver options specified when creating the PEtabODEProblem 
`odeSolverGradientOptions`: ODE-solver gradient options specified when creating the PEtabODEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/PEtab_structs.jl#L159-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ODESolverOptions" href="#PEtab.ODESolverOptions"><code>PEtab.ODESolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODESolverOptions

Stores ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. 

Constructed via `getODESolverOptions`. More info regarding the options and available solvers can be found in the 
documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/), and 
in the documentation for `getODESolverOptions`.

# Fields
`solver`: Any of the ODE-solvers in DifferentialEquations.jl
`abstol`: Absolute tolerance when solving the ODE-system. 
`reltol`: Relative tolerance when solving the ODE-system
`force_dtmin`: Whether or not to force dtmin when solving the ODE-system.
`dtmin`: Minimal acceptable step-size when solving the ODE-system.
`maxiters`: Maximum number of iterations when solving the ODE-system.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/PEtab_structs.jl#L94-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.SteadyStateSolverOptions" href="#PEtab.SteadyStateSolverOptions"><code>PEtab.SteadyStateSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolverOptions

Stores options (algorithm, tolerances, etc...) to use when computing steady state for models with pre-equlibration.

Constructed via `getSteadyStateSolverOptions` with several potential user options.

# Fields
`method`: Approach to find steady-state u*; du = f(u*, p, t) ≈ 0. Either :Rootfinding to directly solve the problem 
 via optimisation, or :Simulate to via ODE solver simulate model to steady state.
`rootfindingAlgorithm`: In case of :Rootfinding which algorithm to use. Supports any of the NonlinearSolve algorithms 
 (https://docs.sciml.ai/NonlinearSolve/stable/tutorials/nonlinear/).
`howCheckSimulationReachedSteadyState`: For :Simulate which method to check steady state been reached, options;
    wrms : Weighted root-mean square : √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1
    Newton : If Newton-step Δu is sufficiently small : √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1
`abstol`: Absolute tolerance when checking if steady state has been found. Defaults to 1e-8 for :Rootfinding and
 ODE-solver tolerance divided by 100 for :Simulate
`reltol`: Relative tolerance when checking if steady state has been found. As for abstol.
`maxiters`: Maximum number of root-finding or ODE-solver steps when solving for steady state. Defaults to 1e4
 for :Rootfinding and ODE-solver options for :Simulate.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/PEtab_structs.jl#L122-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.readPEtabModel" href="#PEtab.readPEtabModel"><code>PEtab.readPEtabModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readPEtabModel(pathYAML::String;
               forceBuildJuliaFiles::Bool=false,
               verbose::Bool=true,
               ifElseToEvent::Bool=true)::PEtabModel

Parses a PEtab specified problem with yaml-file at `pathYAML` into a Julia accessible format. 

When parsing a PEtab problem several things happens under the hood;
1) The SBML file is translated into ModelingToolkit.jl format (e.g allow symbolic computations of the ODE-model 
   Jacobian). Piecewise and model events are further written into DifferentialEquations.jl callbacks.
2) The observable PEtab-table is translated into Julia-file with functions for computing the observable (h), 
   noise parameter (σ) and initial values (u0). 
3) To allow gradients via adjoint sensitivity analysis and/or forward sensitivity equations the gradients of 
   h and σ are computed symbolically with respect to the ODE-models states (u) and parameters (odeProblem.p).
All this happens automatically, and resulting files are stored under petabModel.dirJulia. To save time 
`forceBuildJlFiles=false` meaning that Julia files are not rebuilt in case the already exist.

In the future we plan to allow the user to also provide a Julia file instead of a SBML file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/Create_PEtab_model.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setupPEtabODEProblem" href="#PEtab.setupPEtabODEProblem"><code>PEtab.setupPEtabODEProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setupPEtabODEProblem(petabModel::PEtabModel, 
                     odeSolverOptions::ODESolverOptions; 
                     &lt;keyword arguments&gt;)

For a PEtabModel and ODE-solver options (e.g. solver and tolerances) returns a PEtabODEProblem.

The PEtabODEproblem allows for efficient cost, gradient and hessian computations for a PEtab specified problem.  
Using the keyword arguments (see below) the user can select cost method, gradient method, hessian method, ODE 
solver options, and a few tuneable options that potentially can make computations more efficient for a subset of 
&quot;edge-case&quot; models. A discussion about the most efficient option for different model types can be found in the 
documentation [add]. 

# Arguments
- `petabModel::PEtabModel`: a PEtab-specified problem processed into Julia syntax by `readPEtabModel`
- `odeSolverOptions::ODESolverOptions`: ODE-solver options when computing the cost (e.g solver and tolerances)
- `odeSolverGradientOptions=nothing` : ODE-solver options when computing the gradient, e.g. the ODE solver options 
   used when doing adjoint sensitivity analysis. If nothing defaults to `odeSolverOptions`. 
- `ssSolverOptions=nothing` : Options used when solving for steady-state for models with pre-equlibrium. Steady-state
   can be found either via simulation or rootfinding and can be set via `getSteadyStateSolverOptions` (see 
   documentation), if nothing defaults to simulation with wrms &lt; 1 termination.
   used when doing adjoint sensitivity analysis. If nothing defaults to `odeSolverOptions`. 
- `ssSolverGradientOptions=nothing` : Options used when solving for steady-state for models with pre-equlibrium when
   doing gradient computations. If nothing defaults to `ssSolverOptions` value.
- `costMethod::Symbol=:Standard` : method for computing the cost (objective). Two options are available, :Standard is 
   most efficient, while :Zygote is less efficient but compatible with the Zygote automatic differentiation library.
- `gradientMethod::Symbol=:ForwardDiff` : method for computing the gradient of the (objective). Four availble options:
    * :ForwardDiff - Compute the gradient via forward-mode automatic differentiation using ForwardDiff.jl. Most 
      efficient for models with ≤50 parameters. Optionally the number of chunks can be set by `chunkSize`.
    * :ForwardEquations - Compute the gradient via the model sensitivities, where `sensealg` species how to solve 
      for the sensitivities. Most efficient if the hessian is approximated via the Gauss-Newton method, and if in the 
      optimizer we can reuse the sensitives (see `reuseS`) from the gradient computations in the hessian computations 
      (e.g when the optimizer always computes the gradient before the hessian). 
    * :Adjoint - Compute the gradient via adjoint sensitivity analysis, where `sensealg` specifies which algorithm 
      to use. Most efficient for large models (≥75 parameters). 
    * :Zygote - Compute the gradient via the Zygote package, where `sensealg` specifies which sensitivity algorithm 
      to use when solving the ODE-model. Most inefficient option and not recommended to use at all. 
- `hessianMethod::Symbol=:ForwardDiff` : method for computing the hessian of the cost. Three available options:
    * :ForwardDiff - Compute the hessian via forward-mode automatic differentiation using ForwardDiff.jl. Often only 
      computationally feasible for models with ≤20 parameters, but often greatly improves optimizer convergence. 
    * :BlockForwardDiff - Compute hessian block approximation via forward-mode automatic differentiation using 
      ForwardDiff.jl. Approximation consists of two block matrices, the first is the hessian for only the dynamic 
      parameters (parameter part of the ODE system), and the second for the non-dynamic parameters (e.g noise 
      parameters). Computationally feasible for models with ≤ 20 dynamic parameters and often performs better than 
      BFGS-methods. 
    * :GaussNewton - Approximate the hessian via the Gauss-Newton method. Often performs better than the BFGS method.
      If in the optimizer we can reuse the sensitives from the gradient (see `reuseS`) this method is best paired with 
      `gradientMethod=:ForwardEquations`. 
- `sparseJacobian::Bool=false` : when solving the ODE du/dt=f(u, p, t) whether or not for implicit solvers use a 
   sparse-jacobian. Sparse jacobian often performs best for large models (≥100 states). 
- `specializeLevel=SciMLBase.FullSpecialize` : specialization level when building the ODE-problem. Not recommended 
   to change (see https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/)
- `sensealg=InterpolatingAdjoint()` : Sensitivity algorithm for gradient computations. Available options for each 
   gradient method are:
    * :ForwardDiff : None (as ForwardDiff takes care of all computation steps)
    * :ForwardEquations : :ForwardDiff (uses ForwardDiff.jl) or ForwardDiffSensitivity() and ForwardSensitivity() 
      from SciMLSensitivity.jl (https://github.com/SciML/SciMLSensitivity.jl). 
    * :Adjoint : InterpolatingAdjoint() and QuadratureAdjoint() from SciMLSensitivity.jl
    * :Zygote : all sensealg in SciMLSensitivity.jl 
- `sensealgSS=InterpolatingAdjoint()` : Sensitivity algorithm for adjoint gradient compuations for steady state 
   simulations. Availble options are SteadyStateAdjoint() InterpolatingAdjoint() and QuadratureAdjoint() from 
   SciMLSensitivity.jl. SteadyStateAdjoint() is most efficient but requires a non-singular jacobian, and in case
   of non-singular jacobian the code automatically switches to InterpolatingAdjoint(). 
- `chunkSize=nothing` : Chunk-size for ForwardDiff.jl when computing the gradient and hessian via forward mode 
   automatic different. If nothing default value is used. Tuning chunkSize is non-trivial and we plan to add 
   automatic functionality for this.
- `splitOverConditions::Bool=false` : For gradient and hessian via ForwardDiff.jl whether or not to split calls to 
  to ForwardDiff across experimental (simulation) conditions. Should only be set to true in case the model has many 
  parameters tgat are specific to an experimental condition, else the overhead from the calls will increase run time. 
  See the Beer-example for an example where this is needed.
- `reuseS::Bool=false` : Reuse the sensitives from the gradient computations for the Gauss-Newton hessian approximation.
  Only applicable when `hessianMethod=:GaussNewton` and `gradientMethod=:ForwardEquations` and should **only** be used 
  when the optimizer **always** computes the gradient before the hessian.
- `verbose::Bool=true` : Print progress when setting up PEtab ODEProblem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/Create_PEtab_ODEProblem.jl#L1-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getODESolverOptions" href="#PEtab.getODESolverOptions"><code>PEtab.getODESolverOptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getODESolverOptions(solver, &lt;keyword arguments&gt;)

Setup ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. 

More info of about the options and available solvers can be found in the documentation for DifferentialEquations.jl 
(https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommendeded settings for which solver and options 
to use for different problems can be found below and in the documentation.

# Arguments
`solver`: Any of the ODE-solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models 
 composite solvers such as `AutoVern7(Rodas5P())` perform well. For stiff small models `Rodas5P()` performs 
 well. For medium sized models (≤75states) `QNDF()`, `FBDF()` and `CVODE_BDF()` perform well. `CVODE_BDF()` is 
 not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic 
 differentiation, or if the Gauss-Newton hessian approximation is used. If the gradient is computed via adjoint 
 sensitivity analysis `CVODE_BDF()` is often the best choices as it typically is more relaible than `QNDF()` and 
 `FBDF()` (fails less often).
`abstol=1e-8`: Absolute tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. 
`reltol=1e-8`: Relative tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. 
`force_dtmin=false`: Whether or not to force dtmin when solving the ODE-system.
`dtmin=nothing`: Minimal acceptable step-size when solving the ODE-system.
`maxiters=10000`: Maximum number of iterations when solving the ODE-system. Increasing above the default value can 
 cause the optimization to take substantial time.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/Create_PEtab_ODEProblem.jl#L860-L883">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getSteadyStateSolverOptions" href="#PEtab.getSteadyStateSolverOptions"><code>PEtab.getSteadyStateSolverOptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getSteadyStateSolverOptions(method::Symbol;
                            howCheckSimulationReachedSteadyState::Symbol=:wrms,
                            rootfindingAlgorithm=nothing,
                            abstol=nothing, 
                            reltol=nothing, 
                            maxiters=nothing)::SteadyStateSolverOptions

Setup steady-state solver options for finding steady-state via **either** method=:Rootfinding or method=:Simulate.

For :Rootfinding the steady state u* is found by solving the problem du = f(u, p, t) ≈ 0 with tolerances 
abstol and reltol via an automatically choosen optimisation algorithm (rootfindingAlgorithm=nothing) or via any 
algorithm in NonlinearSolve.jl (https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/), e.g. 
rootfindingAlgorithm=NonlinearSolve.TrustRegion(). (abstol, reltol, maxiters) defaults to (1e-8, 1e-8, 1e4).

For :Simulate the steady state u* is found by simulating the ODE-system until du = f(u, p, t) ≈ 0.
Two options are availble for howCheckSimulationReachedSteadyState;
    - :wrms : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1
    - :Newton : If Newton-step Δu is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1. 
Newton often perform better but requires an invertible Jacobian. In case not fulfilled code switches automatically
to wrms. (abstol, reltol) defaults to ODE solver tolerances divided by 100 and maxiters to ODE solver value.
    
maxiters refers to either maximum number of rootfinding steps, or maximum number of integration steps.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/76ee1ed9715646e75081763cf4654e83121a1b6f/src/Solve_ODE/Solve_for_steady_state.jl#L1-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Best_options/">« Choosing the best options for a PEtab problem</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 13 April 2023 15:08">Thursday 13 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
