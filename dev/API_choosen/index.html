<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PEtab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/API_choosen/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Brannmark/">Models with preequilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li><a class="tocitem" href="../Best_options/">Choosing the best options for a PEtab problem</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/API_choosen.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabModel</code></pre><p>A PEtab specified problem translated into a Julia compatible format.</p><p>Created from <code>readPEtabModel</code> contains helper functions needed to set up cost-, gradient-, hessian-computations, and for handling potential model events (callbacks). </p><p><strong>Note1</strong> - Several of the functions in the PEtabModel are not meant to be accessible for the user. For example compute_h (and similar functions) require indices which are built in the background to efficiently map parameter between experimental (simulation) conditions. Rather, <code>PEtabModel</code> holds all information needed to create a PEtabODEProblem, and in the future PEtabSDEProblem etc ... <strong>Note2</strong> - ODEProblem.p refers to the parameters for underlying DifferentialEquations.jl ODEProblem.</p><p><strong>Fields</strong></p><ul><li><code>modelName</code>: Model-name extracted from the PEtab yaml-file. </li><li><code>compute_h</code>: Compute the observable (h) for a specific time-point and simulation condition.</li><li><code>compute_u0!</code>: In-place initial values using the ODEProblem.p for a simulation condition; compute_u0!(u0, p)</li><li><code>compute_u0</code>: As above but not in-place; u0 = compute_u0(p)</li><li><code>compute_σ</code>: Compute the noise parameter σ for specific time-point and simulation condition.</li><li><code>compute_∂h∂u!</code>: Compute the gradient of h with respect to ODE-model states (u) for a specific time-point and simulation condition.</li><li><code>compute_∂σ∂u!</code>: As above but for the noise parameter σ</li><li><code>compute_∂h∂p!</code>: As above for h but with respect to ODEProblem.p</li><li><code>compute_∂σ∂p!</code>: As above for σ but with respect to ODEProblem.p</li><li><code>computeTStops</code>: In case the model has DiscreteCallbacks (events) this function computes the event times. </li><li><code>convertTspan::Bool</code>: In case the model has DiscreteCallbacks (events) and the trigger-time is a parameter set to be estimated this Bool tracks that for ForwardDiff.jl gradients the time-span should be converted to Dual-numbers. </li><li><code>dirModel</code>: Directory where the model.xml and PEtab files are stored.</li><li><code>dirJulia</code>: Directory where the Julia-model files created by parsing the PEtab files (e.g SBML-file) are stored. </li><li><code>odeSystem</code>: A ModellingToolkit.jl ODE-system obtained from parsing the model SBML-file.  </li><li><code>parameterMap</code>: A ModellingToolkit.jl parameter map for the ODE-system.</li><li><code>stateMap</code>: A ModellingToolkit.jl state map for the ODE-system describing how the inital values are computed, e.g. whether or not certain initial values are computed from parameters in the parameterMap.</li><li><code>parameterNames</code>: Names of the parameter in the odeSystem.</li><li><code>stateNames</code>: Names of the states in the odeSystem.</li><li><code>pathMeasurements</code>: Path to the PEtab measurements file</li><li><code>pathConditions</code>: Path to the PEtab conditions file</li><li><code>pathObservables</code>: Path to the PEtab observables file</li><li><code>pathParameters</code>: Path to the PEtab parameters file</li><li><code>pathSBML</code>: Path to the PEtab SBML file</li><li><code>pathYAML</code>: Path to the PEtab yaml file</li><li><code>modelCallbackSet</code>: Stores potential model callbacks (events)</li><li><code>checkIfCallbackIsActive</code>: Piecewise SBML statements are rewritten to DiscreteCallbacks that are activated at a specific time-point. The piecewise callback has a defult value at t0 which is only triggered upon reaching t<em>activation. In case t</em>activation ≤ 0 (never reached when solvig the model) this function checks whether or not the callback should be triggered before solving the model. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/PEtab_structs.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabODEProblem</code></pre><p>All needed to setup an optimization problem (compute cost, gradient, hessian and parameter bounds) for a PEtab model.</p><p>The PEtabODEproblem for a PEtab problem allows for efficient cost, gradient and hessian computations. Constructed via <code>setupPEtabODEProblem</code>, more info on tuneable options can be found in the documentation [add]. </p><p><strong>Note</strong> - the parameter vector θ is <strong>always</strong> assumed to be on parameter scale specified in the PEtab parameters file. If needed θ is transformed to linear scale inside of the function call. </p><p><strong>Fields</strong></p><ul><li><code>computeCost</code>: For θ computes the objective value cost = computeCost(θ)</li><li><code>computeGradient!</code>: For θ computes in-place gradient computeGradient!(gradient, θ)</li><li><code>computeHessian!</code>: For θ computes in-place hessian-(approximation) computeHessian!(hessian, θ)</li><li><code>costMethod</code>: Method for computing the cost (:Standard, :Zygote)</li><li><code>gradientMethod</code>: Method for computing the gradient (:ForwardDiff, :ForwardEquations :Adjoint, :Zygote)</li><li><code>hessianMethod</code>:  Method for computing/approximating the hessian (:ForwardDiff, :BlocForwardDiff :GaussNewton)</li><li><code>nParametersToEstimate</code>: Number of parameter to estimate.</li><li><code>θ_estNames</code>: Names of the parameter in θ</li><li><code>θ_nominal</code>: Nominal θ values as specified in the PEtab parameters-file. </li><li><code>θ_nominalT</code>: Nominal θ values on parameter-scale (e.g log) as specified in the PEtab parameters-file.</li><li><code>lowerBounds</code>: Lower parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.</li><li><code>upperBounds</code>: Upper parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.</li><li><code>petabModel</code>: PEtabModel used to construct the PEtabODEProblem</li><li><code>odeSolverOptions</code>: ODE-solver options specified when creating the PEtabODEProblem </li><li><code>odeSolverGradientOptions</code>: ODE-solver gradient options specified when creating the PEtabODEProblem </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/PEtab_structs.jl#L143-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ODESolverOptions" href="#PEtab.ODESolverOptions"><code>PEtab.ODESolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODESolverOptions</code></pre><p>Stores ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. </p><p>Constructed via <code>getODESolverOptions</code>. More info regarding the options and available solvers can be found in the documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/), and in the documentation for <code>getODESolverOptions</code>.</p><p><strong>Fields</strong></p><ul><li><code>solver</code>: Any of the ODE-solvers in DifferentialEquations.jl</li><li><code>abstol</code>: Absolute tolerance when solving the ODE-system. </li><li><code>reltol</code>: Relative tolerance when solving the ODE-system</li><li><code>force_dtmin</code>: Whether or not to force dtmin when solving the ODE-system.</li><li><code>dtmin</code>: Minimal acceptable step-size when solving the ODE-system.</li><li><code>maxiters</code>: Maximum number of iterations when solving the ODE-system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/PEtab_structs.jl#L84-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.SteadyStateSolverOptions" href="#PEtab.SteadyStateSolverOptions"><code>PEtab.SteadyStateSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolverOptions</code></pre><p>Stores options (algorithm, tolerances, etc...) to use when computing steady state for models with pre-equlibration.</p><p>Constructed via <code>getSteadyStateSolverOptions</code> with several potential user options.</p><p><strong>Fields</strong></p><ul><li><code>method</code>: Approach to find steady-state u<em>; du = f(u</em>, p, t) ≈ 0. Either :Rootfinding to directly solve the problem via optimisation, or :Simulate to via ODE solver simulate model to steady state.</li><li><code>rootfindingAlgorithm</code>: In case of :Rootfinding which algorithm to use. Supports any of the NonlinearSolve algorithms (https://docs.sciml.ai/NonlinearSolve/stable/tutorials/nonlinear/).</li><li><code>howCheckSimulationReachedSteadyState</code>: For :Simulate which method to check steady state been reached, options;<ul><li>wrms : Weighted root-mean square : √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1</li><li>Newton : If Newton-step Δu is sufficiently small : √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1</li></ul></li><li><code>abstol</code>: Absolute tolerance when checking if steady state has been found. Defaults to 1e-8 for :Rootfinding and ODE-solver tolerance divided by 100 for :Simulate</li><li><code>reltol</code>: Relative tolerance when checking if steady state has been found. As for abstol.</li><li><code>maxiters</code>: Maximum number of root-finding or ODE-solver steps when solving for steady state. Defaults to 1e4 for :Rootfinding and ODE-solver options for :Simulate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/PEtab_structs.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.readPEtabModel" href="#PEtab.readPEtabModel"><code>PEtab.readPEtabModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readPEtabModel(pathYAML::String;
               forceBuildJuliaFiles::Bool=false,
               verbose::Bool=true,
               ifElseToEvent::Bool=true)::PEtabModel</code></pre><p>Parses a PEtab specified problem with yaml-file at <code>pathYAML</code> into a Julia accessible format. </p><p>When parsing a PEtab problem several things happens under the hood;</p><ol><li>The SBML file is translated into ModelingToolkit.jl format (e.g allow symbolic computations of the ODE-model Jacobian). Piecewise and model events are further written into DifferentialEquations.jl callbacks.</li><li>The observable PEtab-table is translated into Julia-file with functions for computing the observable (h), noise parameter (σ) and initial values (u0). </li><li>To allow gradients via adjoint sensitivity analysis and/or forward sensitivity equations the gradients of h and σ are computed symbolically with respect to the ODE-models states (u) and parameters (odeProblem.p).</li></ol><p>All this happens automatically, and resulting files are stored under petabModel.dirJulia. To save time <code>forceBuildJlFiles=false</code> meaning that Julia files are not rebuilt in case the already exist.</p><p>In the future we plan to allow the user to also provide a Julia file instead of a SBML file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/Create_PEtab_model.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setupPEtabODEProblem" href="#PEtab.setupPEtabODEProblem"><code>PEtab.setupPEtabODEProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setupPEtabODEProblem(petabModel::PEtabModel, 
                     odeSolverOptions::ODESolverOptions; 
                     &lt;keyword arguments&gt;)</code></pre><p>For a PEtabModel and ODE-solver options (e.g. solver and tolerances) returns a PEtabODEProblem.</p><p>The PEtabODEproblem allows for efficient cost, gradient and hessian computations for a PEtab specified problem.  Using the keyword arguments (see below) the user can select cost method, gradient method, hessian method, ODE solver options, and a few tuneable options that potentially can make computations more efficient for a subset of &quot;edge-case&quot; models. A discussion about the most efficient option for different model types can be found in the documentation. </p><p><strong>Arguments</strong></p><ul><li><code>petabModel::PEtabModel</code>: a PEtab-specified problem processed into Julia syntax by <code>readPEtabModel</code></li><li><code>odeSolverOptions::ODESolverOptions</code>: ODE-solver options when computing the cost (e.g solver and tolerances)</li><li><code>odeSolverGradientOptions=nothing</code> : ODE-solver options when computing the gradient, e.g. the ODE solver options used when doing adjoint sensitivity analysis. If nothing defaults to <code>odeSolverOptions</code>. </li><li><code>ssSolverOptions=nothing</code> : Options used when solving for steady-state for models with pre-equlibrium. Steady-state can be found either via simulation or rootfinding and can be set via <code>getSteadyStateSolverOptions</code> (see documentation), if nothing defaults to simulation with wrms &lt; 1 termination. used when doing adjoint sensitivity analysis. If nothing defaults to <code>odeSolverOptions</code>. </li><li><code>ssSolverGradientOptions=nothing</code> : Options used when solving for steady-state for models with pre-equlibrium when doing gradient computations. If nothing defaults to <code>ssSolverOptions</code> value.</li><li><code>costMethod::Symbol=:Standard</code> : method for computing the cost (objective). Two options are available, :Standard is most efficient, while :Zygote is less efficient but compatible with the Zygote automatic differentiation library.</li><li><code>gradientMethod::Symbol=:ForwardDiff</code> : method for computing the gradient of the (objective). Four availble options:<ul><li><code>:ForwardDiff</code> - Compute the gradient via forward-mode automatic differentiation using ForwardDiff.jl. Most efficient for models with ≤50 parameters. Optionally the number of chunks can be set by <code>chunkSize</code>.</li><li><code>:ForwardEquations</code> - Compute the gradient via the model sensitivities, where <code>sensealg</code> species how to solve for the sensitivities. Most efficient if the hessian is approximated via the Gauss-Newton method, and if in the optimizer we can reuse the sensitives (see <code>reuseS</code>) from the gradient computations in the hessian computations (e.g when the optimizer always computes the gradient before the hessian). </li><li><code>:Adjoint</code> - Compute the gradient via adjoint sensitivity analysis, where <code>sensealg</code> specifies which algorithm to use. Most efficient for large models (≥75 parameters). </li><li><code>:Zygote</code> - Compute the gradient via the Zygote package, where <code>sensealg</code> specifies which sensitivity algorithm to use when solving the ODE-model. Most inefficient option and not recommended to use at all. </li></ul></li><li><code>hessianMethod::Symbol=:ForwardDiff</code> : method for computing the hessian of the cost. Three available options:<ul><li><code>:ForwardDiff</code> - Compute the hessian via forward-mode automatic differentiation using ForwardDiff.jl. Often only computationally feasible for models with ≤20 parameters, but often greatly improves optimizer convergence. </li><li><code>:BlockForwardDiff</code> - Compute hessian block approximation via forward-mode automatic differentiation using ForwardDiff.jl. Approximation consists of two block matrices, the first is the hessian for only the dynamic parameters (parameter part of the ODE system), and the second for the non-dynamic parameters (e.g noise parameters). Computationally feasible for models with ≤ 20 dynamic parameters and often performs better than BFGS-methods. </li><li><code>:GaussNewton</code> - Approximate the hessian via the Gauss-Newton method. Often performs better than the BFGS method. If in the optimizer we can reuse the sensitives from the gradient (see <code>reuseS</code>) this method is best paired with <code>gradientMethod=:ForwardEquations</code>. </li></ul></li><li><code>sparseJacobian::Bool=false</code> : when solving the ODE du/dt=f(u, p, t) whether or not for implicit solvers use a sparse-jacobian. Sparse jacobian often performs best for large models (≥100 states). </li><li><code>specializeLevel=SciMLBase.FullSpecialize</code> : specialization level when building the ODE-problem. Not recommended to change (see https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/)</li><li><code>sensealg=InterpolatingAdjoint()</code> : Sensitivity algorithm for gradient computations. Available options for each gradient method are:<ul><li><code>:ForwardDiff</code> : None (as ForwardDiff takes care of all computation steps)</li><li><code>:ForwardEquations</code> : <code>:ForwardDiff</code> (uses ForwardDiff.jl) or <code>ForwardDiffSensitivity()</code> and <code>ForwardSensitivity()</code> from SciMLSensitivity.jl (https://github.com/SciML/SciMLSensitivity.jl). </li><li><code>:Adjoint</code> : <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> from SciMLSensitivity.jl</li><li><code>:Zygote</code> : all sensealg in SciMLSensitivity.jl </li></ul></li><li><code>sensealgSS=InterpolatingAdjoint()</code> : Sensitivity algorithm for adjoint gradient compuations for steady state simulations. Availble options are <code>SteadyStateAdjoint()</code>, <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> from SciMLSensitivity.jl. <code>SteadyStateAdjoint()</code> is most efficient but requires a non-singular jacobian, and in case of non-singular jacobian the code automatically switches to <code>InterpolatingAdjoint()</code>. </li><li><code>chunkSize=nothing</code> : Chunk-size for ForwardDiff.jl when computing the gradient and hessian via forward mode automatic different. If nothing default value is used. Tuning chunkSize is non-trivial and we plan to add automatic functionality for this.</li><li><code>splitOverConditions::Bool=false</code> : For gradient and hessian via ForwardDiff.jl whether or not to split calls to to ForwardDiff across experimental (simulation) conditions. Should only be set to true in case the model has many parameters tgat are specific to an experimental condition, else the overhead from the calls will increase run time.        See the Beer-example for an example where this is needed.</li><li><code>reuseS::Bool=false</code> : Reuse the sensitives from the gradient computations for the Gauss-Newton hessian approximation. Only applicable when <code>hessianMethod=:GaussNewton</code> and <code>gradientMethod=:ForwardEquations</code> and should <strong>only</strong> be used when the optimizer <strong>always</strong> computes the gradient before the hessian.</li><li><code>verbose::Bool=true</code> : Print progress when setting up PEtab ODEProblem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/Create_PEtab_ODEProblem.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getODESolverOptions" href="#PEtab.getODESolverOptions"><code>PEtab.getODESolverOptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getODESolverOptions(solver, &lt;keyword arguments&gt;)</code></pre><p>Setup ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. </p><p>More info of about the options and available solvers can be found in the documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommendeded settings for which solver and options to use for different problems can be found below and in the documentation.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: Any of the ODE-solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models composite solvers such as <code>AutoVern7(Rodas5P())</code> perform well. For stiff small models <code>Rodas5P()</code> performs well. For medium sized models (≤75states) <code>QNDF()</code>, <code>FBDF()</code> and <code>CVODE_BDF()</code> perform well. <code>CVODE_BDF()</code> is not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic differentiation, or if the Gauss-Newton hessian approximation is used. If the gradient is computed via adjoint sensitivity analysis <code>CVODE_BDF()</code> is often the best choices as it typically is more relaible than <code>QNDF()</code> and <code>FBDF()</code> (fails less often).</li><li><code>abstol=1e-8</code>: Absolute tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. </li><li><code>reltol=1e-8</code>: Relative tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. </li><li><code>force_dtmin=false</code>: Whether or not to force dtmin when solving the ODE-system.</li><li><code>dtmin=nothing</code>: Minimal acceptable step-size when solving the ODE-system.</li><li><code>maxiters=10000</code>: Maximum number of iterations when solving the ODE-system. Increasing above the default value can cause the optimization to take substantial time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/Create_PEtab_ODEProblem.jl#L823-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getSteadyStateSolverOptions" href="#PEtab.getSteadyStateSolverOptions"><code>PEtab.getSteadyStateSolverOptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getSteadyStateSolverOptions(method::Symbol;
                            howCheckSimulationReachedSteadyState::Symbol=:wrms,
                            rootfindingAlgorithm=nothing,
                            abstol=nothing, 
                            reltol=nothing, 
                            maxiters=nothing)::SteadyStateSolverOptions</code></pre><p>Setup steady-state solver options for finding steady-state via <strong>either</strong> method=:Rootfinding or method=:Simulate.</p><p>For <code>:Rootfinding</code> the steady state u* is found by solving the problem du = f(u, p, t) ≈ 0 with tolerances abstol and reltol via an automatically choosen optimisation algorithm (rootfindingAlgorithm=nothing) or via any algorithm in NonlinearSolve.jl (https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/), e.g. rootfindingAlgorithm=NonlinearSolve.TrustRegion(). (abstol, reltol, maxiters) defaults to (1e-8, 1e-8, 1e4).</p><p>For <code>:Simulate</code> the steady state u* is found by simulating the ODE-system until du = f(u, p, t) ≈ 0. Two options are availble for <code>howCheckSimulationReachedSteadyState</code>;</p><ul><li><code>:wrms</code> : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1</li><li><code>:Newton</code> : If Newton-step Δu is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1. </li></ul><p>Newton often perform better but requires an invertible Jacobian. In case not fulfilled code switches automatically to wrms. (abstol, reltol) defaults to ODE solver tolerances divided by 100 and maxiters to ODE solver value.</p><p><code>maxiters</code> refers to either maximum number of rootfinding steps, or maximum number of integration steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/b9c52bee5356bfcefa24a233f49922a2fd67857d/src/Solve_ODE/Solve_for_steady_state.jl#L1-L19">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Best_options/">« Choosing the best options for a PEtab problem</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 14 April 2023 13:27">Friday 14 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
