<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PEtab.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PEtab.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PEtab"><a class="docs-heading-anchor" href="#PEtab">PEtab</a><a id="PEtab-1"></a><a class="docs-heading-anchor-permalink" href="#PEtab" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/sebapersson/PEtab.jl">PEtab</a>.</p><ul><li><a href="#PEtab.ODESolverOptions"><code>PEtab.ODESolverOptions</code></a></li><li><a href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a></li><li><a href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a></li><li><a href="#PEtab.SteadyStateSolverOptions"><code>PEtab.SteadyStateSolverOptions</code></a></li><li><a href="#PEtab.JLToModellingToolkit-Tuple{String, String}"><code>PEtab.JLToModellingToolkit</code></a></li><li><a href="#PEtab.XmlToModellingToolkit-Tuple{String, AbstractString, AbstractString}"><code>PEtab.XmlToModellingToolkit</code></a></li><li><a href="#PEtab.checkDataFrameColumns-NTuple{5, Any}"><code>PEtab.checkDataFrameColumns</code></a></li><li><a href="#PEtab.createDerivative_σ_h_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Dict}"><code>PEtab.createDerivative_σ_h_File</code></a></li><li><a href="#PEtab.createTopOfFunction_h-Tuple{Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.createTopOfFunction_h</code></a></li><li><a href="#PEtab.createTopOf∂h∂_Function-Tuple{Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame}"><code>PEtab.createTopOf∂h∂_Function</code></a></li><li><a href="#PEtab.create_h_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create_h_Function</code></a></li><li><a href="#PEtab.create_u0_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Any}"><code>PEtab.create_u0_Function</code></a></li><li><a href="#PEtab.create_σ_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create_σ_Function</code></a></li><li><a href="#PEtab.create_σ_h_u0_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Any, Dict}"><code>PEtab.create_σ_h_u0_File</code></a></li><li><a href="#PEtab.create∂h∂_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create∂h∂_Function</code></a></li><li><a href="#PEtab.create∂σ∂_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create∂σ∂_Function</code></a></li><li><a href="#PEtab.dualToFloat-Tuple{AbstractFloat}"><code>PEtab.dualToFloat</code></a></li><li><a href="#PEtab.dualToFloat-Tuple{ForwardDiff.Dual}"><code>PEtab.dualToFloat</code></a></li><li><a href="#PEtab.getNoiseParametersStr-Tuple{String}"><code>PEtab.getNoiseParametersStr</code></a></li><li><a href="#PEtab.getODESolverOptions-Tuple{T1} where T1&lt;:SciMLBase.AbstractSciMLAlgorithm"><code>PEtab.getODESolverOptions</code></a></li><li><a href="#PEtab.getObservableParametersStr-Tuple{String}"><code>PEtab.getObservableParametersStr</code></a></li><li><a href="#PEtab.getSteadyStateSolverOptions-Tuple{Symbol}"><code>PEtab.getSteadyStateSolverOptions</code></a></li><li><a href="#PEtab.getWord-Tuple{String, Int64, Vector{Char}}"><code>PEtab.getWord</code></a></li><li><a href="#PEtab.isNumber-Tuple{SubString{String}}"><code>PEtab.isNumber</code></a></li><li><a href="#PEtab.isNumber-Tuple{AbstractString}"><code>PEtab.isNumber</code></a></li><li><a href="#PEtab.petabFormulaToJulia-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.petabFormulaToJulia</code></a></li><li><a href="#PEtab.processMeasurements-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}"><code>PEtab.processMeasurements</code></a></li><li><a href="#PEtab.processParameters-Tuple{DataFrames.DataFrame}"><code>PEtab.processParameters</code></a></li><li><a href="#PEtab.readPEtabModel-Tuple{String}"><code>PEtab.readPEtabModel</code></a></li><li><a href="#PEtab.replaceExplicitVariableWithRule-Tuple{String, Dict}"><code>PEtab.replaceExplicitVariableWithRule</code></a></li><li><a href="#PEtab.replaceVariablesWithArrayIndex-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.replaceVariablesWithArrayIndex</code></a></li><li><a href="#PEtab.replaceWholeWordWithNumberPrefix-Tuple{Any, Any, Any}"><code>PEtab.replaceWholeWordWithNumberPrefix</code></a></li><li><a href="#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParametersInfo}"><code>PEtab.setParamToFileValues!</code></a></li><li><a href="#PEtab.setupPEtabODEProblem-Tuple{PEtabModel, ODESolverOptions}"><code>PEtab.setupPEtabODEProblem</code></a></li><li><a href="#PEtab.transformMeasurementOrH-Tuple{Real, Symbol}"><code>PEtab.transformMeasurementOrH</code></a></li><li><a href="#PEtab.wordToJuliaSyntax-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.wordToJuliaSyntax</code></a></li><li><a href="#PEtab.writeODEModelToFile-NTuple{4, Any}"><code>PEtab.writeODEModelToFile</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="PEtab.ODESolverOptions" href="#PEtab.ODESolverOptions"><code>PEtab.ODESolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODESolverOptions

Stores ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. 

Constructed via `getODESolverOptions`. More info regarding the options and available solvers can be found in the 
documentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/), and 
in the documentation for `getODESolverOptions`.

# Fields
`solver`: Any of the ODE-solvers in DifferentialEquations.jl
`abstol`: Absolute tolerance when solving the ODE-system. 
`reltol`: Relative tolerance when solving the ODE-system
`force_dtmin`: Whether or not to force dtmin when solving the ODE-system.
`dtmin`: Minimal acceptable step-size when solving the ODE-system.
`maxiters`: Maximum number of iterations when solving the ODE-system.

See also [`getODESolverOptions`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/PEtab_structs.jl#L96-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabModel

A PEtab specified problem translated into a Julia compatible format.

Created from `readPEtabModel` contains helper functions needed to set up cost-, gradient-, hessian-computations, and 
for handling potential model events (callbacks). 

Note1 - Several of the functions in the PEtabModel are not meant to be accessible for the user. For example 
compute_h (and similar functions) require indices which are built in the background to efficiently map parameter 
between experimental (simulation) conditions. Rather, `PEtabModel` holds all information needed to create a 
PEtabODEProblem, and in the future PEtabSDEProblem etc ...
Note2 - ODEProblem.p refers to the parameters for underlying DifferentialEquations.jl ODEProblem.

# Fields
`modelName`: Model-name extracted from the PEtab yaml-file. 
`compute_h`: Compute the observable (h) for a specific time-point and simulation condition.
`compute_u0!`: In-place initial values using the ODEProblem.p for a simulation condition; compute_u0!(u0, p)
`compute_u0`: As above but not in-place; u0 = compute_u0(p)
`compute_σ`: Compute the noise parameter σ for specific time-point and simulation condition.
`compute_∂h∂u!`: Compute the gradient of h with respect to ODE-model states (u) for a specific time-point and 
 simulation condition.
`compute_∂σ∂u!`: As above but for the noise parameter σ
`compute_∂h∂p!`: As above for h but with respect to ODEProblem.p
`compute_∂σ∂p!`: As above for σ but with respect to ODEProblem.p
`computeTStops`: In case the model has DiscreteCallbacks (events) this function computes the event times. 
`convertTspan::Bool`: In case the model has DiscreteCallbacks (events) and the trigger-time is a parameter set to 
 be estimated this Bool tracks that for ForwardDiff.jl gradients the time-span should be converted to Dual-numbers. 
`dirModel`: Directory where the model.xml and PEtab files are stored.
`dirJulia`: Directory where the Julia-model files created by parsing the PEtab files (e.g SBML-file) are stored. 
`odeSystem`: A ModellingToolkit.jl ODE-system obtained from parsing the model SBML-file.  
`parameterMap`: A ModellingToolkit.jl parameter map for the ODE-system.
`stateMap`: A ModellingToolkit.jl state map for the ODE-system describing how the inital values are computed, e.g.
 whether or not certain initial values are computed from parameters in the parameterMap.
`parameterNames`: Names of the parameter in the odeSystem.
`stateNames`: Names of the states in the odeSystem.
`pathMeasurements`: Path to the PEtab measurements file
`pathConditions`: Path to the PEtab conditions file
`pathObservables`: Path to the PEtab observables file
`pathParameters`: Path to the PEtab parameters file
`pathSBML`: Path to the PEtab SBML file
`pathYAML`: Path to the PEtab yaml file
`modelCallbackSet`: Stores potential model callbacks (events)
`checkIfCallbackIsActive`: Piecewise SBML statements are rewritten to DiscreteCallbacks that are activated at a
specific time-point. The piecewise callback has a defult value at t0 which is only triggered upon reaching t_activation.
In case t_activation ≤ 0 (never reached when solvig the model) this function checks whether or not the callback 
should be triggered before solving the model. 

See also: [`readPEtabModel`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/PEtab_structs.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEtabODEProblem

All needed to setup an optimization problem (compute cost, gradient, hessian and parameter bounds) for a PEtab model.

The PEtabODEproblem for a PEtab problem allows for efficient cost, gradient and hessian computations. Constructed
via `setupPEtabODEProblem`, more info on tuneable options can be found in the documentation [add]. 

**Note** - the parameter vector θ is **always** assumed to be on parameter scale specified in the PEtab parameters 
file. If needed θ is transformed to linear scale inside of the function call. 

# Fields
`computeCost`: For θ computes the objective value cost = computeCost(θ)
`computeGradient!`: For θ computes in-place gradient computeGradient!(gradient, θ)
`computeHessian!`: For θ computes in-place hessian-(approximation) computeHessian!(hessian, θ)
`costMethod`: Method for computing the cost (:Standard, :Zygote)
`gradientMethod`: Method for computing the gradient (:ForwardDiff, :ForwardEquations :Adjoint, :Zygote)
`hessianMethod`:  Method for computing/approximating the hessian (:ForwardDiff, :BlocForwardDiff :GaussNewton)
`nParametersToEstimate`: Number of parameter to estimate.
`θ_estNames`: Names of the parameter in θ
`θ_nominal`: Nominal θ values as specified in the PEtab parameters-file. 
`θ_nominalT`: Nominal θ values on parameter-scale (e.g log) as specified in the PEtab parameters-file.
`lowerBounds`: Lower parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.
`upperBounds`: Upper parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.
`petabModel`: PEtabModel used to construct the PEtabODEProblem
`odeSolverOptions`: ODE-solver options specified when creating the PEtabODEProblem 
`odeSolverGradientOptions`: ODE-solver gradient options specified when creating the PEtabODEProblem 

See also [`setupPEtabODEProblem`](@ref), [`PEtabModel`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/PEtab_structs.jl#L165-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.SteadyStateSolverOptions" href="#PEtab.SteadyStateSolverOptions"><code>PEtab.SteadyStateSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolverOptions

Stores options (algorithm, tolerances, etc...) to use when computing steady state for models with pre-equlibration.

Constructed via `getSteadyStateSolverOptions` with several potential user options.

# Fields
`method`: Approach to find steady-state u*; du = f(u*, p, t) ≈ 0. Either :Rootfinding to directly solve the problem 
 via optimisation, or :Simulate to via ODE solver simulate model to steady state.
`rootfindingAlgorithm`: In case of :Rootfinding which algorithm to use. Supports any of the NonlinearSolve algorithms 
 (https://docs.sciml.ai/NonlinearSolve/stable/tutorials/nonlinear/).
`howCheckSimulationReachedSteadyState`: For :Simulate which method to check steady state been reached, options;
    wrms : Weighted root-mean square : √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1
    Newton : If Newton-step Δu is sufficiently small : √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1
`abstol`: Absolute tolerance when checking if steady state has been found. Defaults to 1e-8 for :Rootfinding and
 ODE-solver tolerance divided by 100 for :Simulate
`reltol`: Relative tolerance when checking if steady state has been found. As for abstol.
`maxiters`: Maximum number of root-finding or ODE-solver steps when solving for steady state. Defaults to 1e4
 for :Rootfinding and ODE-solver options for :Simulate.

See also [`getSteadyStateSolverOptions`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/PEtab_structs.jl#L126-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.JLToModellingToolkit-Tuple{String, String}" href="#PEtab.JLToModellingToolkit-Tuple{String, String}"><code>PEtab.JLToModellingToolkit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JLToModellingToolkit(modelName::String, dirModel::String)
Checks and fixes a Julia ModelingToolkit file and store 
the fixed file in dirModel with name modelName_fix.jl.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/SBML/SBML_to_ModellingToolkit.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.XmlToModellingToolkit-Tuple{String, AbstractString, AbstractString}" href="#PEtab.XmlToModellingToolkit-Tuple{String, AbstractString, AbstractString}"><code>PEtab.XmlToModellingToolkit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XmlToModellingToolkit(pathXml::String, modelName::String, dirModel::String)
Convert a SBML file in pathXml to a Julia ModelingToolkit file and store 
the resulting file in dirModel with name modelName.jl. 
The SBML importer goes via libsbml in Python and currently likelly only 
works with SBML level 3.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/SBML/SBML_to_ModellingToolkit.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.checkDataFrameColumns-NTuple{5, Any}" href="#PEtab.checkDataFrameColumns-NTuple{5, Any}"><code>PEtab.checkDataFrameColumns</code></a> — <span class="docstring-category">Method</span></header><section><div><p>checkDataFrameColumns(dataFrame, dataFrameName, colsToCheck, allowedTypesVec, requiredCols)</p><pre><code class="nohighlight hljs">Goes through each column from colsToCheck in dataFrame and checks
if each column is of any of the DataTypes specified in allowedTypesVec[colIndex].
Returns true if all columns are ok and false otherwise.
requiredCols is an array of mandatory columns. If a mandatory column is missing
an error is thrown, and if a mandatory column contains missing rows a warning is thrown.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Read_PEtab_files.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createDerivative_σ_h_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Dict}" href="#PEtab.createDerivative_σ_h_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Dict}"><code>PEtab.createDerivative_σ_h_File</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createFileDYmodSdU0(modelName::String, 
                   dirModel::String, 
                   odeSys::ODESystem, 
                   stateMap,
                   SBMLDict::Dict)

For a PeTab model with name modelName with all PeTab-files in dirModel and associated 
ModellingToolkit ODESystem (with its stateMap) build a file containing a functions for 
i) computing the observable model value (yMod) ii) compute the initial value u0 (by using the 
stateMap) and iii) computing the standard error (sd) for each observableFormula in the 
observables PeTab file.
Note - The produced Julia file will go via the JIT-compiler.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_h_sigma_derivatives.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createTopOfFunction_h-Tuple{Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}" href="#PEtab.createTopOfFunction_h-Tuple{Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.createTopOfFunction_h</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createTopOfFunction_h(modelStateNames::Vector{String},
                      paramData::ParametersInfo,
                      namesParamODEProb::Vector{String},
                      namesNonDynParam::Vector{String})

Extracts all variables needed for the observable h function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_u0_h_sigma.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createTopOf∂h∂_Function-Tuple{Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame}" href="#PEtab.createTopOf∂h∂_Function-Tuple{Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame}"><code>PEtab.createTopOf∂h∂_Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createTopOf∂h∂_Function(modelStateNames::Vector{String}, 
                        pODEProblemNames::Vector{String}, 
                        θ_nonDynamicNames::Vector{String},
                        observablesData::DataFrame)

Extracts all variables needed for the functions and add them as variables for Symbolics.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_h_sigma_derivatives.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.create_h_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}" href="#PEtab.create_h_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create_h_Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_h_Function(modelName::String,
                  dirModel::String,
                  modelStateNames::Vector{String},
                  paramData::ParametersInfo,
                  namesParamDyn::Vector{String},
                  namesNonDynParam::Vector{String},
                  observablesData::DataFrame,
                  SBMLDict::Dict)

For modelName create a function for computing yMod by translating the observablesData
PeTab-file into Julia syntax.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_u0_h_sigma.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.create_u0_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Any}" href="#PEtab.create_u0_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Any}"><code>PEtab.create_u0_Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_u0_Function(modelName::String,
                   dirModel::String,
                   parameterInfo::ParametersInfo,
                   pODEProblemNames::Vector{String},
                   stateMap;
                   inPlace::Bool=true)

For modelName create a function for computing initial value by translating the stateMap
into Julia syntax.

To correctly create the function the name of all parameters, paramData (to get constant parameters)
are required.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_u0_h_sigma.jl#L164-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.create_σ_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}" href="#PEtab.create_σ_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create_σ_Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_σ_Function(modelName::String,
                  dirModel::String,
                  parameterInfo::ParametersInfo,
                  modelStateNames::Vector{String},
                  pODEProblemNames::Vector{String},
                  θ_nonDynamicNames::Vector{String},
                  observablesData::DataFrame,
                  SBMLDict::Dict)

For modelName create a function for computing the standard deviation σ by translating the observablesData
PeTab-file into Julia syntax.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_u0_h_sigma.jl#L241-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.create_σ_h_u0_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Any, Dict}" href="#PEtab.create_σ_h_u0_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Any, Dict}"><code>PEtab.create_σ_h_u0_File</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_σ_h_u0_File(modelName::String,
                   dirModel::String,
                   odeSystem::ODESystem,
                   stateMap,
                   SBMLDict::Dict;
                   verbose::Bool=false)

For a PeTab model with name modelName with all PeTab-files in dirModel and associated
ModellingToolkit ODESystem (with its stateMap) build a file containing a functions for
i) computing the observable model value (h) ii) compute the initial value u0 (by using the
stateMap) and iii) computing the standard error (σ) for each observableFormula in the
observables PeTab file.

Note - The produced Julia file will go via the JIT-compiler. The SBML-dict is needed as
sometimes variables are encoded via explicit-SBML rules.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_u0_h_sigma.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.create∂h∂_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}" href="#PEtab.create∂h∂_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create∂h∂_Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create∂h∂_Function(modelName::String, 
                   dirModel::String, 
                   modelStateNames::Vector{String}, 
                   parameterInfo::ParametersInfo, 
                   pODEProblemNames::Vector{String}, 
                   θ_nonDynamicNames::Vector{String},
                   observablesData::DataFrame,
                   SBMLDict::Dict)

For modelName create using Symbolics function for computing ∂h/∂u and ∂h/∂p where 
u = modelStates and p = pODEProblem (parameters for ODE problem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_h_sigma_derivatives.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.create∂σ∂_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}" href="#PEtab.create∂σ∂_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}"><code>PEtab.create∂σ∂_Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create∂σ∂_Function(modelName::String, 
                        dirModel::String, 
                        parameterInfo::ParametersInfo, 
                        modelStateNames::Vector{String}, 
                        pODEProblemNames::Vector{String}, 
                        θ_nonDynamicNames::Vector{String},
                        observablesData::DataFrame,
                        SBMLDict::Dict)

For modelName create a function for computing the standard deviation by translating the observablesData</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Create_h_sigma_derivatives.jl#L214-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.dualToFloat-Tuple{AbstractFloat}" href="#PEtab.dualToFloat-Tuple{AbstractFloat}"><code>PEtab.dualToFloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dualToFloat(x::AbstractFloat)::AbstractFloat</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Common.jl#L286-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.dualToFloat-Tuple{ForwardDiff.Dual}" href="#PEtab.dualToFloat-Tuple{ForwardDiff.Dual}"><code>PEtab.dualToFloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dualToFloat(x::ForwardDiff.Dual)::Real

Via recursion convert a Dual to a Float.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Common.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getNoiseParametersStr-Tuple{String}" href="#PEtab.getNoiseParametersStr-Tuple{String}"><code>PEtab.getNoiseParametersStr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNoiseParametersStr(formula::String)::String

Helper function to extract all the noiseParameter in noiseParameter formula in the PEtab file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getODESolverOptions-Tuple{T1} where T1&lt;:SciMLBase.AbstractSciMLAlgorithm" href="#PEtab.getODESolverOptions-Tuple{T1} where T1&lt;:SciMLBase.AbstractSciMLAlgorithm"><code>PEtab.getODESolverOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getODESolverOptions(solver, &lt;keyword arguments&gt;)

Setup ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. 

More info of about the options and available solvers can be found in the documentation for DifferentialEquations.jl 
(https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommendeded settings for which solver and options 
to use for different problems can be found below and in the documentation.

# Arguments
`solver`: Any of the ODE-solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models 
 composite solvers such as `AutoVern7(Rodas5P())` perform well. For stiff small models `Rodas5P()` performs 
 well. For medium sized models (≤75states) `QNDF()`, `FBDF()` and `CVODE_BDF()` perform well. `CVODE_BDF()` is 
 not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic 
 differentiation, or if the Gauss-Newton hessian approximation is used. If the gradient is computed via adjoint 
 sensitivity analysis `CVODE_BDF()` is often the best choices as it typically is more relaible than `QNDF()` and 
 `FBDF()` (fails less often).
`abstol=1e-8`: Absolute tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. 
`reltol=1e-8`: Relative tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. 
`force_dtmin=false`: Whether or not to force dtmin when solving the ODE-system.
`dtmin=nothing`: Minimal acceptable step-size when solving the ODE-system.
`maxiters=10000`: Maximum number of iterations when solving the ODE-system. Increasing above the default value can 
 cause the optimization to take substantial time.

See also [`ODESolverOptions`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Create_PEtab_ODEProblem.jl#L847-L872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getObservableParametersStr-Tuple{String}" href="#PEtab.getObservableParametersStr-Tuple{String}"><code>PEtab.getObservableParametersStr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getObservableParametersStr(formula::String)::String

Helper function to extract all observableParameter in the observableFormula in the PEtab-file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getSteadyStateSolverOptions-Tuple{Symbol}" href="#PEtab.getSteadyStateSolverOptions-Tuple{Symbol}"><code>PEtab.getSteadyStateSolverOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getSteadyStateSolverOptions(method::Symbol;
                            howCheckSimulationReachedSteadyState::Symbol=:wrms,
                            rootfindingAlgorithm::Union{Nothing, NonlinearSolve.AbstractNonlinearSolveAlgorithm}=nothing,
                            abstol=nothing, 
                            reltol=nothing, 
                            maxiters=nothing)::SteadyStateSolverOptions

Setup steady-state solver options for finding steady-state via **either** method=:Rootfinding or method=:Simulate.

For :Rootfinding the steady state u* is found by solving the problem du = f(u, p, t) ≈ 0 with tolerances 
abstol and reltol via an automatically choosen optimisation algorithm (rootfindingAlgorithm=nothing) or via any 
algorithm in NonlinearSolve.jl (https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/), e.g. 
rootfindingAlgorithm=NonlinearSolve.TrustRegion(). (abstol, reltol, maxiters) defaults to (1e-8, 1e-8, 1e4).

For :Simulate the steady state u* is found by simulating the ODE-system until du = f(u, p, t) ≈ 0.
Two options are availble for howCheckSimulationReachedSteadyState;
    - :wrms : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1
    - :Newton : If Newton-step Δu is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) &lt; 1. 
Newton often perform better but requires an invertible Jacobian. In case not fulfilled code switches automatically
to wrms. (abstol, reltol) defaults to ODE solver tolerances divided by 100 and maxiters to ODE solver value.
    
maxiters refers to either maximum number of rootfinding steps, or maximum number of integration steps.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Solve_ODE/Solve_for_steady_state.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getWord-Tuple{String, Int64, Vector{Char}}" href="#PEtab.getWord-Tuple{String, Int64, Vector{Char}}"><code>PEtab.getWord</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getWord(str::String, iStart::Int, charTerminate::Vector{Char})

In a string starting from position iStart extract the next &quot;word&quot;, which is the longest
concurent occurance of characters that are not in the character list with word termination
characters. Returns the word and iEnd (the position where the word ends).

For example, if charListTerm = [&#39;(&#39;, &#39;)&#39;, &#39;+&#39;, &#39;-&#39;, &#39;/&#39;, &#39;*&#39;, &#39;^&#39;] abc123 is
considered a word but not abc123*.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.isNumber-Tuple{AbstractString}" href="#PEtab.isNumber-Tuple{AbstractString}"><code>PEtab.isNumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isNumber(x::String)::Bool

Check if a string x is a number (Float) taking sciencetific notation into account.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Common.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.isNumber-Tuple{SubString{String}}" href="#PEtab.isNumber-Tuple{SubString{String}}"><code>PEtab.isNumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isNumber(x::SubString{String})::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Common.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.petabFormulaToJulia-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}" href="#PEtab.petabFormulaToJulia-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.petabFormulaToJulia</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">petabFormulaToJulia(formula::String, stateNames, paramData::ParametersInfo, namesParamDyn::Vector{String}, namesNonDynParam::Vector{String})::String

Translate a peTab formula (e.g for observable or for sd-parameter) into Julia syntax and output the result
as a string.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.processMeasurements-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}" href="#PEtab.processMeasurements-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}"><code>PEtab.processMeasurements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processMeasurements(measurementsFile::DataFrame, observableData::DataFrame)::MeasurementData

Process the PeTab measurementsFile file into a type-stable Julia struct.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Process_measurements.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.processParameters-Tuple{DataFrames.DataFrame}" href="#PEtab.processParameters-Tuple{DataFrames.DataFrame}"><code>PEtab.processParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processParameters(parametersFile::DataFrame)::ParameterInfo

Process the PeTab parametersFile file into a type-stable Julia struct.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Process_parameters.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.readPEtabModel-Tuple{String}" href="#PEtab.readPEtabModel-Tuple{String}"><code>PEtab.readPEtabModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readPEtabModel(pathYAML::String;
               forceBuildJuliaFiles::Bool=false,
               verbose::Bool=true,
               ifElseToEvent::Bool=true)::PEtabModel

Parses a PEtab specified problem with yaml-file at `pathYAML` into a Julia accessible format. 

When parsing a PEtab problem several things happens under the hood;
1) The SBML file is translated into ModelingToolkit.jl format (e.g allow symbolic computations of the ODE-model 
   Jacobian). Piecewise and model events are further written into DifferentialEquations.jl callbacks.
2) The observable PEtab-table is translated into Julia-file with functions for computing the observable (h), 
   noise parameter (σ) and initial values (u0). 
3) To allow gradients via adjoint sensitivity analysis and/or forward sensitivity equations the gradients of 
   h and σ are computed symbolically with respect to the ODE-models states (u) and parameters (odeProblem.p).
All this happens automatically, and resulting files are stored under petabModel.dirJulia. To save time 
`forceBuildJlFiles=false` meaning that Julia files are not rebuilt in case the already exist.

In the future we plan to allow the user to also provide a Julia file instead of a SBML file.

See also: [`PEtabModel`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Create_PEtab_model.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.replaceExplicitVariableWithRule-Tuple{String, Dict}" href="#PEtab.replaceExplicitVariableWithRule-Tuple{String, Dict}"><code>PEtab.replaceExplicitVariableWithRule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replaceExplicitVariableWithRule(formula::String, SBMLDict::Dict)::String

Replace the explicit rule variable with the explicit rule</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.replaceVariablesWithArrayIndex-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}" href="#PEtab.replaceVariablesWithArrayIndex-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.replaceVariablesWithArrayIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replaceVariablesWithArrayIndex(formula,stateNames,parameterNames,namesNonDynParam,paramData)::String

Replaces any state or parameter from formula with their corresponding index in the ODE system
Symbolics can return strings without multiplication sign, e.g. 100.0STAT5 instead of 100.0*STAT5
so replaceWholeWord cannot be used here</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.replaceWholeWordWithNumberPrefix-Tuple{Any, Any, Any}" href="#PEtab.replaceWholeWordWithNumberPrefix-Tuple{Any, Any, Any}"><code>PEtab.replaceWholeWordWithNumberPrefix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replaceWholeWordWithNumberPrefix(formula, from, to)::String

Replaces variables that can be prefixed with numbers, e.g.,
replaceWholeWordWithNumberPrefix(&quot;4STAT5 + 100.0STAT5 + RE*STAT5 + STAT5&quot;,&quot;STAT5&quot;,&quot;u[1]&quot;) gives
4u[1] + 100.0u[1] + RE*u[1] + u[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L266-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParametersInfo}" href="#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParametersInfo}"><code>PEtab.setParamToFileValues!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setParamToFileValues!(paramMap, stateMap, paramData::ParamData)

Function that sets the parameter and state values in paramMap and stateMap
to those in the PeTab parameters file.

Used when setting up the PeTab cost function, and when solving the ODE-system
for the values in the parameters-file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Common.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setupPEtabODEProblem-Tuple{PEtabModel, ODESolverOptions}" href="#PEtab.setupPEtabODEProblem-Tuple{PEtabModel, ODESolverOptions}"><code>PEtab.setupPEtabODEProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setupPEtabODEProblem(petabModel::PEtabModel, 
                     odeSolverOptions::ODESolverOptions; 
                     &lt;keyword arguments&gt;)

For a PEtabModel and ODE-solver options (e.g. solver and tolerances) returns a PEtabODEProblem.

The PEtabODEproblem allows for efficient cost, gradient and hessian computations for a PEtab specified problem.  
Using the keyword arguments (see below) the user can select cost method, gradient method, hessian method, ODE 
solver options, and a few tuneable options that potentially can make computations more efficient for a subset of 
&quot;edge-case&quot; models. A discussion about the most efficient option for different model types can be found in the 
documentation [add]. 

# Arguments
- `petabModel::PEtabModel`: a PEtab-specified problem processed into Julia syntax by `readPEtabModel`
- `odeSolverOptions::ODESolverOptions`: ODE-solver options when computing the cost (e.g solver and tolerances)
- `odeSolverGradientOptions=nothing` : ODE-solver options when computing the gradient, e.g. the ODE solver options 
   used when doing adjoint sensitivity analysis. If nothing defaults to `odeSolverOptions`. 
- `ssSolverOptions=nothing` : Options used when solving for steady-state for models with pre-equlibrium. Steady-state
   can be found either via simulation or rootfinding and can be set via `getSteadyStateSolverOptions` (see 
   documentation), if nothing defaults to simulation with wrms &lt; 1 termination.
   used when doing adjoint sensitivity analysis. If nothing defaults to `odeSolverOptions`. 
- `ssSolverGradientOptions=nothing` : Options used when solving for steady-state for models with pre-equlibrium when
   doing gradient computations. If nothing defaults to `ssSolverOptions` value.
- `costMethod::Symbol=:Standard` : method for computing the cost (objective). Two options are available, :Standard is 
   most efficient, while :Zygote is less efficient but compatible with the Zygote automatic differentiation library.
- `gradientMethod::Symbol=:ForwardDiff` : method for computing the gradient of the (objective). Four availble options:
    * :ForwardDiff - Compute the gradient via forward-mode automatic differentiation using ForwardDiff.jl. Most 
      efficient for models with ≤50 parameters. Optionally the number of chunks can be set by `chunkSize`.
    * :ForwardEquations - Compute the gradient via the model sensitivities, where `sensealg` species how to solve 
      for the sensitivities. Most efficient if the hessian is approximated via the Gauss-Newton method, and if in the 
      optimizer we can reuse the sensitives (see `reuseS`) from the gradient computations in the hessian computations 
      (e.g when the optimizer always computes the gradient before the hessian). 
    * :Adjoint - Compute the gradient via adjoint sensitivity analysis, where `sensealg` specifies which algorithm 
      to use. Most efficient for large models (≥75 parameters). 
    * :Zygote - Compute the gradient via the Zygote package, where `sensealg` specifies which sensitivity algorithm 
      to use when solving the ODE-model. Most inefficient option and not recommended to use at all. 
- `hessianMethod::Symbol=:ForwardDiff` : method for computing the hessian of the cost. Three available options:
    * :ForwardDiff - Compute the hessian via forward-mode automatic differentiation using ForwardDiff.jl. Often only 
      computationally feasible for models with ≤20 parameters, but often greatly improves optimizer convergence. 
    * :BlockForwardDiff - Compute hessian block approximation via forward-mode automatic differentiation using 
      ForwardDiff.jl. Approximation consists of two block matrices, the first is the hessian for only the dynamic 
      parameters (parameter part of the ODE system), and the second for the non-dynamic parameters (e.g noise 
      parameters). Computationally feasible for models with ≤ 20 dynamic parameters and often performs better than 
      BFGS-methods. 
    * :GaussNewton - Approximate the hessian via the Gauss-Newton method. Often performs better than the BFGS method.
      If in the optimizer we can reuse the sensitives from the gradient (see `reuseS`) this method is best paired with 
      `gradientMethod=:ForwardEquations`. 
- `sparseJacobian::Bool=false` : when solving the ODE du/dt=f(u, p, t) whether or not for implicit solvers use a 
   sparse-jacobian. Sparse jacobian often performs best for large models (≥100 states). 
- `specializeLevel=SciMLBase.FullSpecialize` : specialization level when building the ODE-problem. Not recommended 
   to change (see https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/)
- `solverSSRelTol::Float64=1e-6` : For models with pre-eq. Will refactor this part of the code. 
- `solverSSAbsTol::Float64=1e-6` : For models with pre-eq. Will refactor this part of the code. 
- `terminateSSMethod::Symbol=:Norm` : For models with pre-eq. Will refactor this part of the code. 
- `sensealg=InterpolatingAdjoint()` : Sensitivity algorithm for gradient computations. Available options for each 
   gradient method are:
    * :ForwardDiff : None (as ForwardDiff takes care of all computation steps)
    * :ForwardEquations : :ForwardDiff (uses ForwardDiff.jl) or ForwardDiffSensitivity() and ForwardSensitivity() 
      from SciMLSensitivity.jl (https://github.com/SciML/SciMLSensitivity.jl). 
    * :Adjoint : InterpolatingAdjoint() and QuadratureAdjoint() from SciMLSensitivity.jl
    * :Zygote : all sensealg in SciMLSensitivity.jl 
- `sensealgSS=SteadyStateAdjoint()` : Sensitivity algorithm for adjoint gradient compuations for steady state 
   simulations. Availble options are SteadyStateAdjoint() InterpolatingAdjoint() and QuadratureAdjoint() from 
   SciMLSensitivity.jl. SteadyStateAdjoint() is most efficient but requires a non-singular jacobian, and in case
   of non-singular jacobian the code automatically switches to InterpolatingAdjoint(). 
- `chunkSize=nothing` : Chunk-size for ForwardDiff.jl when computing the gradient and hessian via forward mode 
   automatic different. If nothing default value is used. Tuning chunkSize is non-trivial and we plan to add 
   automatic functionality for this.
- `splitOverConditions::Bool=false` : For gradient and hessian via ForwardDiff.jl whether or not to split calls to 
  to ForwardDiff across experimental (simulation) conditions. Should only be set to true in case the model has many 
  parameters tgat are specific to an experimental condition, else the overhead from the calls will increase run time. 
  See the Beer-example for an example where this is needed.
- `reuseS::Bool=false` : Reuse the sensitives from the gradient computations for the Gauss-Newton hessian approximation.
  Only applicable when `hessianMethod=:GaussNewton` and `gradientMethod=:ForwardEquations` and should **only** be used 
  when the optimizer **always** computes the gradient before the hessian.

See also [`PEtabODEProblem`](@ref), [`PEtabModel`](@ref), [`getODESolverOptions`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Create_PEtab_ODEProblem.jl#L1-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.transformMeasurementOrH-Tuple{Real, Symbol}" href="#PEtab.transformMeasurementOrH-Tuple{Real, Symbol}"><code>PEtab.transformMeasurementOrH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformMeasurementOrH(val::Real, transformationArr::Array{Symbol, 1})

Transform val using either :lin (identify), :log10 and :log transforamtions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Common.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.wordToJuliaSyntax-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}" href="#PEtab.wordToJuliaSyntax-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}"><code>PEtab.wordToJuliaSyntax</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;     wordToJuliaSyntax(wordTranslate::String,                       stateNames,                       paramData::ParametersInfo,                       namesParamDyn::Vector{String})::String</p><pre><code class="nohighlight hljs">Translate a word (state, parameter, math-expression or number) into Julia syntax
when building Ymod, U0 and Sd functions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/Process_PEtab_files/Observables/Common.jl#L102-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.writeODEModelToFile-NTuple{4, Any}" href="#PEtab.writeODEModelToFile-NTuple{4, Any}"><code>PEtab.writeODEModelToFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">writeODEModelToFile(modelDict, modelName, dirModel)
Takes a modelDict as defined by buildODEModelDictionary
and creates a Julia ModelingToolkit file and stores 
the resulting file in dirModel with name modelName.jl.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/bf2f59fa526ed40a44114c3e672c26e2a04ef33a/src/SBML/SBML_to_ModellingToolkit.jl#L434-L439">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 29 March 2023 06:28">Wednesday 29 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
