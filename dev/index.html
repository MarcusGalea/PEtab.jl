<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PEtab.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PEtab.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PEtab"><a class="docs-heading-anchor" href="#PEtab">PEtab</a><a id="PEtab-1"></a><a class="docs-heading-anchor-permalink" href="#PEtab" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/sebapersson/PEtab.jl">PEtab</a>.</p><ul><li><a href="#PEtab.MeasurementData"><code>PEtab.MeasurementData</code></a></li><li><a href="#PEtab.ParamData"><code>PEtab.ParamData</code></a></li><li><a href="#PEtab.ParamMap"><code>PEtab.ParamMap</code></a></li><li><a href="#PEtab.ParameterIndices"><code>PEtab.ParameterIndices</code></a></li><li><a href="#PEtab.PeTabModel"><code>PEtab.PeTabModel</code></a></li><li><a href="#PEtab.SimulationInfo"><code>PEtab.SimulationInfo</code></a></li><li><a href="#PEtab.XmlToModellingToolkit-Tuple{String, String, String}"><code>PEtab.XmlToModellingToolkit</code></a></li><li><a href="#PEtab.calcAccuracyOdeSolver-Tuple{SciMLBase.ODEProblem, Vector{&lt;:SciMLBase.AbstractODESolution}, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}"><code>PEtab.calcAccuracyOdeSolver</code></a></li><li><a href="#PEtab.calcCost-Tuple{Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}"><code>PEtab.calcCost</code></a></li><li><a href="#PEtab.calcGradCost!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1&lt;:(Vector{&lt;:AbstractFloat}), T2&lt;:(Vector{&lt;:Real})}"><code>PEtab.calcGradCost!</code></a></li><li><a href="#PEtab.calcHessianApprox!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1&lt;:(Matrix{&lt;:AbstractFloat}), T2&lt;:(Vector{&lt;:Real})}"><code>PEtab.calcHessianApprox!</code></a></li><li><a href="#PEtab.calcHighAccOdeSolution-Tuple{SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo}"><code>PEtab.calcHighAccOdeSolution</code></a></li><li><a href="#PEtab.calcLogLik-Tuple{Any, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData}"><code>PEtab.calcLogLik</code></a></li><li><a href="#PEtab.calcLogLikNotSolveODE-Union{Tuple{T1}, Tuple{T1, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, PEtab.PriorInfo}} where T1&lt;:(Vector{&lt;:Real})"><code>PEtab.calcLogLikNotSolveODE</code></a></li><li><a href="#PEtab.calcLogLikSolveODE-Tuple{Any, Any, Any, Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}"><code>PEtab.calcLogLikSolveODE</code></a></li><li><a href="#PEtab.calcSqErrVal-Tuple{Any, Any, Float64}"><code>PEtab.calcSqErrVal</code></a></li><li><a href="#PEtab.changeExperimentalCond!-Tuple{Any, Any, String, PEtab.ParamData, DataFrames.DataFrame, PeTabModel}"><code>PEtab.changeExperimentalCond!</code></a></li><li><a href="#PEtab.changeModelParam!-Tuple{Any, Any, Any, PEtab.ParameterIndices, PeTabModel}"><code>PEtab.changeModelParam!</code></a></li><li><a href="#PEtab.checkForPeTabFile-Tuple{String, String}"><code>PEtab.checkForPeTabFile</code></a></li><li><a href="#PEtab.createBigFloatODEProblem-Tuple{SciMLBase.ODEProblem}"><code>PEtab.createBigFloatODEProblem</code></a></li><li><a href="#PEtab.createBigFloatODEProblem-Tuple{PeTabModel}"><code>PEtab.createBigFloatODEProblem</code></a></li><li><a href="#PEtab.createFileYmodSdU0-Tuple{String, String, ModelingToolkit.ODESystem, Any, Any}"><code>PEtab.createFileYmodSdU0</code></a></li><li><a href="#PEtab.createSdFunction-Tuple{String, String, PEtab.ParamData, Any, Vector{String}, Vector{String}, DataFrames.DataFrame}"><code>PEtab.createSdFunction</code></a></li><li><a href="#PEtab.createU0Function-Tuple{String, String, PEtab.ParamData, Vector{String}, Any}"><code>PEtab.createU0Function</code></a></li><li><a href="#PEtab.createYmodFunction-Tuple{String, String, Any, PEtab.ParamData, Vector{String}, Vector{String}, DataFrames.DataFrame, Any}"><code>PEtab.createYmodFunction</code></a></li><li><a href="#PEtab.getIndicesParam-Tuple{PEtab.ParamData, PEtab.MeasurementData, ModelingToolkit.ODESystem, DataFrames.DataFrame}"><code>PEtab.getIndicesParam</code></a></li><li><a href="#PEtab.getNoiseParamStr-Tuple{String}"><code>PEtab.getNoiseParamStr</code></a></li><li><a href="#PEtab.getObsParamStr-Tuple{String}"><code>PEtab.getObsParamStr</code></a></li><li><a href="#PEtab.getRowExpId-Tuple{String, DataFrames.DataFrame}"><code>PEtab.getRowExpId</code></a></li><li><a href="#PEtab.getSimulationInfo-Tuple{DataFrames.DataFrame, PEtab.MeasurementData}"><code>PEtab.getSimulationInfo</code></a></li><li><a href="#PEtab.getTimeMax-Tuple{DataFrames.DataFrame, String}"><code>PEtab.getTimeMax</code></a></li><li><a href="#PEtab.getWord-Tuple{String, Int64, Vector{Char}}"><code>PEtab.getWord</code></a></li><li><a href="#PEtab.isNumber-Tuple{AbstractString}"><code>PEtab.isNumber</code></a></li><li><a href="#PEtab.peTabFormulaToJulia-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}"><code>PEtab.peTabFormulaToJulia</code></a></li><li><a href="#PEtab.processMeasurementData-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}"><code>PEtab.processMeasurementData</code></a></li><li><a href="#PEtab.processParameterData-Tuple{DataFrames.DataFrame}"><code>PEtab.processParameterData</code></a></li><li><a href="#PEtab.readDataFiles-Tuple{String}"><code>PEtab.readDataFiles</code></a></li><li><a href="#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParamData}"><code>PEtab.setParamToFileValues!</code></a></li><li><a href="#PEtab.setUpCostGradHess-Tuple{PeTabModel, Any, Float64}"><code>PEtab.setUpCostGradHess</code></a></li><li><a href="#PEtab.setUpPeTabModel-Tuple{String, String}"><code>PEtab.setUpPeTabModel</code></a></li><li><a href="#PEtab.solveOdeModelAllExperimentalCond!-Tuple{Vector{&lt;:SciMLBase.AbstractODESolution}, SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}"><code>PEtab.solveOdeModelAllExperimentalCond!</code></a></li><li><a href="#PEtab.solveOdeModelAtFileValues-Tuple{PeTabModel, Any, Float64}"><code>PEtab.solveOdeModelAtFileValues</code></a></li><li><a href="#PEtab.solveOdeNoSS-Tuple{SciMLBase.ODEProblem, Function, String, Float64, Float64, Any, Float64}"><code>PEtab.solveOdeNoSS</code></a></li><li><a href="#PEtab.solveOdeSS-Tuple{SciMLBase.ODEProblem, Function, String, String, Float64, Float64, Float64, Any}"><code>PEtab.solveOdeSS</code></a></li><li><a href="#PEtab.transformObsOrData-Tuple{Any, Symbol}"><code>PEtab.transformObsOrData</code></a></li><li><a href="#PEtab.transformParamVec-Tuple{Any, Vector{String}, PEtab.ParamData}"><code>PEtab.transformParamVec</code></a></li><li><a href="#PEtab.transformParamVec!-Tuple{Any, Vector{String}, PEtab.ParamData}"><code>PEtab.transformParamVec!</code></a></li><li><a href="#PEtab.transformYobsOrYmodArr!-Tuple{Any, AbstractVector{&lt;:Symbol}}"><code>PEtab.transformYobsOrYmodArr!</code></a></li><li><a href="#PEtab.wordToJuliaSyntax-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}"><code>PEtab.wordToJuliaSyntax</code></a></li><li><a href="#PEtab.writeODEModelToFile-Tuple{Any, Any, Any}"><code>PEtab.writeODEModelToFile</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="PEtab.MeasurementData" href="#PEtab.MeasurementData"><code>PEtab.MeasurementData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeasurementData</code></pre><p>Struct storing the data in the PeTab measurementData-file in type-stable manner.</p><p>Transform data supports log and log10 transformations of the data.</p><p>See also: [<code>processMeasurementData</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_structs.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ParamData" href="#PEtab.ParamData"><code>PEtab.ParamData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamData</code></pre><p>Struct storing the data in the PeTab parameter-file in type-stable manner.</p><p>Currently logScale notices whether or not parameters are estimated on the log10 scale or not.</p><p>See also: [<code>processParameterData</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_structs.jl#L65-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ParamMap" href="#PEtab.ParamMap"><code>PEtab.ParamMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamMap</code></pre><p>Struct which makes out a map to correctly for an observation extract the correct observable or sd-param via the getObsOrSdParam function when computing the likelihood. Correctly built by <code>buildMapParameters</code>, and is part of the ParameterIndices-struct.</p><p>For noise or observable parameters belong to an observation, e.g (obsParam1, obsParam2), this struct stores which parameters should be estimtated, and for those parameters which index they correspond to in the parameter estimation vector. For constant parameters the struct stores the values.</p><p>See also: [<code>getIndicesParam</code>, <code>buildMapParameters</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_structs.jl#L155-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.ParameterIndices" href="#PEtab.ParameterIndices"><code>PEtab.ParameterIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterIndices</code></pre><p>Struct storing names and mapping indices for mapping the parameter provided to the optimizers correctly.</p><p>Optimizers require a single vector input of parameters (pVecEst). However, the PeTab model has three kind of parameters, Dynmaic (part of the ODE-system), Observable (only part of the observation model) and Standard-deviation (only part of the standard deviation expression in the log-likelhood). This struct stores mapping indices (starting with i) to map pVecEst correctly when computing the likelihood (e.g map the SD-parameters in pVecEst correctly to a vector of SD-vals). Also stores the name of each parameter.</p><p>Furthermore, when computing yMod or SD the correct observable and sd parameters has to be used for each observation. The mapArrays effectively contains precomputed maps allowing said parameter to be effectively be extracted by the getObsOrSdParam function.</p><p>See also: [<code>getIndicesParam</code>, <code>ParamMap</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_structs.jl#L195-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.PeTabModel" href="#PEtab.PeTabModel"><code>PEtab.PeTabModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeTabModel</code></pre><p>Struct storing information about a PeTab-model. Create by the <code>setUpCostFunc</code> function.</p><p><strong>Args</strong></p><p><code>modelName</code>: PeTab model name (must match the xml-file name) <code>evalYmod</code>: Function to evaluate yMod for the log-likelhood. <code>evalU0!</code>: Function that computes the initial u0 value for the ODE-system. <code>evalSd!</code>: Function that computes the standard deviation value for the log-likelhood. <code>odeSystem</code>: ModellingToolkit ODE-system for the PeTab model. <code>paramMap</code>: A map to correctly map model parameters to the ODE-system. <code>stateMap</code>: A map to correctly mapping the parameters to the u0 values. <code>paramNames</code>: Names of the model parameters (both fixed and those to be estimated). <code>stateNames</code>: Names of the model states. <code>dirModel</code>: Directory where the model.xml and PeTab files are stored. <code>pathMeasurementData</code>: Path to the measurementData PeTab file. <code>pathMeasurementData</code>: Path to the experimentaCondition PeTab file <code>pathMeasurementData</code>: Path to the observables PeTab file <code>pathMeasurementData</code>: Path to the parameters PeTab file</p><p>See also: [<code>setUpCostFunc</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_structs.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.SimulationInfo" href="#PEtab.SimulationInfo"><code>PEtab.SimulationInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimulationInfo</code></pre><p>Struct storing simulation (forward ODE-solution) information. Specifcially stores the experimental ID:s from the experimentalCondition - PeTab file; firstExpIds (preequilibration ID:s), the shiftExpIds (postequilibration), and simulateSS (whether or not to simulate ODE-model to steady state). Further stores a solArray with the ODE solution where conditionIdSol of the ID for each forward solution. It also stores for each experimental condition which time-points we have observed data at</p><p>See also: [<code>getSimulationInfo</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_structs.jl#L123-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.XmlToModellingToolkit-Tuple{String, String, String}" href="#PEtab.XmlToModellingToolkit-Tuple{String, String, String}"><code>PEtab.XmlToModellingToolkit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XmlToModellingToolkit(pathXml::String, modelName::String, dirModel::String)

Convert a SBML file in pathXml to a Julia ModelingToolkit file and store
the resulting file in dirModel with name modelName.jl.

The SBML importer goes via libsbml in Python and currently likelly only
works with SBML level 3.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/SBML/SBML_to_ModellingToolkit.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcAccuracyOdeSolver-Tuple{SciMLBase.ODEProblem, Vector{&lt;:SciMLBase.AbstractODESolution}, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}" href="#PEtab.calcAccuracyOdeSolver-Tuple{SciMLBase.ODEProblem, Vector{&lt;:SciMLBase.AbstractODESolution}, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}"><code>PEtab.calcAccuracyOdeSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcAccuracyOdeSolver(prob::ODEProblem,
                      solArrayHighAccuracy::Vector{&lt;:SciMLBase.AbstractODESolution},
                      changeToExperimentalCondUse!::Function,
                      measurementData::DataFrame,
                      simulationInfo::SimulationInfo,
                      solver,
                      absTol::Float64,
                      relTol::Float64)::Float64</code></pre><p>Check the accuracy of an ODE solver at specific tol=absTol=relTol for a PeTab ODE model (odeProb) by for each experimental condition computing the squared sum difference against a high accuracy ODE solution (for each experimental condition) stored in solArrayHighAccuracy.</p><p>Recomended to compute high accuracy solution with small tolerances (1e-15) using a high accuracy solver and BigFloat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Check_accuracy_ode_solver.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcCost-Tuple{Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}" href="#PEtab.calcCost-Tuple{Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}"><code>PEtab.calcCost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcCost(paramVecEst,
         odeProb::ODEProblem,
         peTabModel::PeTabModel,
         simulationInfo::SimulationInfo,
         paramIndices::ParameterIndices,
         measurementData::MeasurementData,
         parameterData::ParamData,
         changeModelParamUse!::Function,
         solveOdeModelAllCondUse!::Function;
         calcHessian::Bool=false)

For a PeTab model compute the cost (likelhood) for a parameter vector
paramVecEst. With respect to paramVecEst (all other inputs fixed)
the function is compatible with ForwardDiff.

To compute the cost an ODE-problem, peTabModel, ODE simulation info,
indices to map parameter from paramVecEst, measurement data, parameter
data (e.g constant parameters), function to map parameters correctly to
ODE-model, and a function to solve the ODE model are required. These
are all set up correctly by the `setUpCostGradHess` function.

See also: [`setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L95-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcGradCost!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1&lt;:(Vector{&lt;:AbstractFloat}), T2&lt;:(Vector{&lt;:Real})}" href="#PEtab.calcGradCost!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1&lt;:(Vector{&lt;:AbstractFloat}), T2&lt;:(Vector{&lt;:Real})}"><code>PEtab.calcGradCost!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcGradCost!(grad::T1,
              paramVecEst,
              odeProb::ODEProblem,
              peTabModel::PeTabModel,
              simulationInfo::SimulationInfo,
              paramIndices::ParameterIndices,
              measurementData::MeasurementData,
              parameterData::ParamData,
              changeModelParamUse!::Function,
              solveOdeModelAllCondUse!::Function) where T1&lt;:Array{&lt;:AbstractFloat, 1}

For a PeTab model compute inplace the gradient  of the cost (likelhood) for
a parameter vector paramVecEst.

Currently the gradient for dynamic parameters (part of ODE-system) is computed via ForwardDiff,
and ReverseDiff is used for observable and sd parameters. The input arguements are the same
as for `calcCost`, and everything is setup by `setUpCostGradHess` function.

See also: [`setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L150-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcHessianApprox!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1&lt;:(Matrix{&lt;:AbstractFloat}), T2&lt;:(Vector{&lt;:Real})}" href="#PEtab.calcHessianApprox!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1&lt;:(Matrix{&lt;:AbstractFloat}), T2&lt;:(Vector{&lt;:Real})}"><code>PEtab.calcHessianApprox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcHessianApprox!(hessian::T1,
                   paramVecEst,
                   odeProb::ODEProblem,
                   peTabModel::PeTabModel,
                   simulationInfo::SimulationInfo,
                   paramIndices::ParameterIndices,
                   measurementData::MeasurementData,
                   parameterData::ParamData,
                   changeModelParamUse!::Function,
                   solveOdeModelAllCondUse!::Function) where T1&lt;:Array{&lt;:AbstractFloat, 2}

For a PeTab model compute inplace hessian approximation of the cost (likelhood) for
a parameter vector paramVecEst.

The hessian approximation assumes the interaction betweeen dynamic and (observable, sd) parameters is zero.
The input arguements are the same as for `calcCost`, and everything is setup by `setUpCostGradHess` function.

See also: [`setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L215-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcHighAccOdeSolution-Tuple{SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo}" href="#PEtab.calcHighAccOdeSolution-Tuple{SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo}"><code>PEtab.calcHighAccOdeSolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcHighAccOdeSolution(prob::ODEProblem,
                       changeToExperimentalCondUse!::Function,
                       measurementData::DataFrame,
                       simulationInfo::SimulationInfo;
                       absTol::Float64=1e-15,
                       relTol::Float64=1e-15,
                       nTSave=100)</code></pre><p>For a PeTab ODE model with the parameter values in prob compute a high accuracy ODE solution with absTol=relTol=tol using BigFloats for the ode-problem. The ODE is solved for all experimental conditions specified in the PeTab files. Returns an array with ODE-solution and a bool which is true if the ODE model could be solved.</p><p>By default the function first tries to solve the ODE problem using a non-stiff solver AutoVern9(Rodas4P()). In case the non-stiff solver fails the Rodas4P() is used to compute the high accuracy solution. If both solvers fail status fail is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Check_accuracy_ode_solver.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcLogLik-Tuple{Any, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData}" href="#PEtab.calcLogLik-Tuple{Any, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData}"><code>PEtab.calcLogLik</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLogLik(dynamicParamEst::T1,
                sdParamEst,
                obsPar,
                peTabModel::PeTabModel,
                simulationInfo::SimulationInfo,
                paramIndices::ParameterIndices,
                measurementData::MeasurementData,
                parameterData::ParamData;
                gradHessDynParam::Bool=false)::Real where T1&lt;:Vector{&lt;:Real}

Helper function computing the likelhood by given after solving the ODE-system using
using the dynamic-parameters, sd-parameters and observable parameters.

Currently for Gaussian data log10 and non-transformed data is accepted.

See also: [`calcCost`, `setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L401-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcLogLikNotSolveODE-Union{Tuple{T1}, Tuple{T1, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, PEtab.PriorInfo}} where T1&lt;:(Vector{&lt;:Real})" href="#PEtab.calcLogLikNotSolveODE-Union{Tuple{T1}, Tuple{T1, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, PEtab.PriorInfo}} where T1&lt;:(Vector{&lt;:Real})"><code>PEtab.calcLogLikNotSolveODE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLogLikNotSolveODE(dynamicParamEst,
                      sdParamEst,
                      obsParamEst,
                      peTabModel::PeTabModel,
                      simulationInfo::SimulationInfo,
                      paramIndices::ParameterIndices,
                      measurementData::MeasurementData,
                      parameterData::ParamData)

Helper function computing the likelhood by given  an already existing ODE-solution stored
in simulationInfo using the dynamic-parameters, sd-parameters and observable parameters.

When computing the cost and gradient/hessian for the sd- and observable-parameters
only a solved ODE-system is needed (no need to resolve). This greatly reduces run-time
since a lot of dual numbers do not have to be propegated through the ODE solver.
Besides the different parameter vector the input arguements are the same as for `calcCost`,
and everything is setup by `setUpCostGradHess` function.

See also: [`calcCost`, `setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L349-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcLogLikSolveODE-Tuple{Any, Any, Any, Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}" href="#PEtab.calcLogLikSolveODE-Tuple{Any, Any, Any, Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}"><code>PEtab.calcLogLikSolveODE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcLogLikSolveODE(dynamicParamEst,
                   sdParamEst,
                   obsParEst,
                   nonDynParamEst,
                   odeProb::ODEProblem,
                   peTabModel::PeTabModel,
                   simulationInfo::SimulationInfo,
                   measurementData ::MeasurementData,
                   parameterData::ParamData,
                   changeModelParamUse!::Function,
                   solveOdeModelAllCondUse!::Function,
                   computeGradOrHess::Bool=false)

Helper function computing the likelhood by solving the ODE system for all
PeTab-specifed experimental conditions using the dynamic-parameters,
sd-parameters and observable parameters.

When computing the cost and gradient/hessian for dynamic parameters the ODE
system must be solved before getting the likelhood. Besides the different
parameter vector the input arguements are the same as for `calcCost`, and
everything is setup by `setUpCostGradHess` function.

See also: [`calcCost`, `setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L279-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.calcSqErrVal-Tuple{Any, Any, Float64}" href="#PEtab.calcSqErrVal-Tuple{Any, Any, Float64}"><code>PEtab.calcSqErrVal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcSqErrVal(solHighAccuracy, sol, t_max::Float64)::Float64</code></pre><p>Helper function to compute the squared sum difference betweeen two ODESolutions solved to t_max. Here solHighAccuracy is meant to be a high accuracy solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Check_accuracy_ode_solver.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.changeExperimentalCond!-Tuple{Any, Any, String, PEtab.ParamData, DataFrames.DataFrame, PeTabModel}" href="#PEtab.changeExperimentalCond!-Tuple{Any, Any, String, PEtab.ParamData, DataFrames.DataFrame, PeTabModel}"><code>PEtab.changeExperimentalCond!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeExperimentalCond!(paramVec,
                        stateVec,
                        expID::String,
                        parameterData::ParamData,
                        experimentalConditions::DataFrame,
                        peTabModel::PeTabModel)</code></pre><p>Change the ODE parameter vector (paramVec) and initial value vector (stateVec) values to the values specified for the experimental ID expID given by the experimentalConditions peTab-file for a specific peTabModel.</p><p>parameterData is needed to correctly map the parameters. The function can handle that paramVec is a Float64 vector or a vector of Duals for the gradient calculations. This function is used by the <code>solveOdeModelAllExperimentalCond!</code>.</p><p>See also: [<code>solveOdeModelAllExperimentalCond!</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Solve_ode_model.jl#L571-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.changeModelParam!-Tuple{Any, Any, Any, PEtab.ParameterIndices, PeTabModel}" href="#PEtab.changeModelParam!-Tuple{Any, Any, Any, PEtab.ParameterIndices, PeTabModel}"><code>PEtab.changeModelParam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeModelParam!(paramVecOdeModel,
                  stateVecOdeModel,
                  paramVecEst,
                  paramEstNames::Array{String, 1},
                  paramIndices::ParameterIndices,
                  peTabModel::PeTabModel)

Change the ODE parameter vector (paramVecOdeModel) and initial value vector (stateVecOdeModel)
values to the values in parameter vector used for parameter estimation paramVecEst.
Basically, map the parameter-estiamtion vector to the ODE model.

The function can handle that paramVecEst is a Float64 vector or a vector of Duals for the
gradient calculations. This function is used when computing the cost, and everything
is set up by `setUpCostGradHess`.

See also: [`setUpCostGradHess`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L693-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.checkForPeTabFile-Tuple{String, String}" href="#PEtab.checkForPeTabFile-Tuple{String, String}"><code>PEtab.checkForPeTabFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkForPeTabFile(fileSearchFor::String, dirModel::String)::String

Helper function to check in dirModel if a file starting with fileSearchFor exists.
If true return file path.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L400-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createBigFloatODEProblem-Tuple{PeTabModel}" href="#PEtab.createBigFloatODEProblem-Tuple{PeTabModel}"><code>PEtab.createBigFloatODEProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createBigFloatODEProblem(peTabModel::PeTabModel)::ODEProblem</code></pre><p>From a PeTab model create its corresponding ODE-problem with BigFloat (long double).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Check_accuracy_ode_solver.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createBigFloatODEProblem-Tuple{SciMLBase.ODEProblem}" href="#PEtab.createBigFloatODEProblem-Tuple{SciMLBase.ODEProblem}"><code>PEtab.createBigFloatODEProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createBigFloatODEProblem(odeProb::ODEProblem)::ODEProblem</code></pre><p>Convert an ODE problem with arbitrary float to one an ODE-problem with BigFloat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Check_accuracy_ode_solver.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createFileYmodSdU0-Tuple{String, String, ModelingToolkit.ODESystem, Any, Any}" href="#PEtab.createFileYmodSdU0-Tuple{String, String, ModelingToolkit.ODESystem, Any, Any}"><code>PEtab.createFileYmodSdU0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createFileYmodSdU0(modelName::String,
                   dirModel::String,
                   odeSys::ODESystem,
                   stateMap,
                   modelDict)

For a PeTab model with name modelName with all PeTab-files in dirModel and associated
ModellingToolkit ODESystem (with its stateMap) build a file containing a functions for
i) computing the observable model value (yMod) ii) compute the initial value u0 (by using the
stateMap) and iii) computing the standard error (sd) for each observableFormula in the
observables PeTab file.

Note - The produced Julia file will go via the JIT-compiler.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createSdFunction-Tuple{String, String, PEtab.ParamData, Any, Vector{String}, Vector{String}, DataFrames.DataFrame}" href="#PEtab.createSdFunction-Tuple{String, String, PEtab.ParamData, Any, Vector{String}, Vector{String}, DataFrames.DataFrame}"><code>PEtab.createSdFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createSdFunction(modelName::String,
                      dirModel::String,
                      paramData::ParamData,
                      stateNames,
                      namesParamDyn::Array{String, 1},
                      observablesData::DataFrame)

For modelName create a function for computing the standard deviation by translating the observablesData
PeTab-file into Julia syntax.

To correctly create the function the state-names, names of dynamic parameters to estiamte
(namesDynParam) and PeTab parameter-file (to get constant parameters) data are needed.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L248-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createU0Function-Tuple{String, String, PEtab.ParamData, Vector{String}, Any}" href="#PEtab.createU0Function-Tuple{String, String, PEtab.ParamData, Vector{String}, Any}"><code>PEtab.createU0Function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createU0Function(modelName::String,
                     dirModel::String,
                     paramData::ParamData,
                     namesParameter::Array{String, 1},
                     stateMap)

For modelName create a function for computing initial value by translating the stateMap
into Julia syntax.

To correctly create the function the name of all parameters, paramData (to get constant parameters)
are required.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L173-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.createYmodFunction-Tuple{String, String, Any, PEtab.ParamData, Vector{String}, Vector{String}, DataFrames.DataFrame, Any}" href="#PEtab.createYmodFunction-Tuple{String, String, Any, PEtab.ParamData, Vector{String}, Vector{String}, DataFrames.DataFrame, Any}"><code>PEtab.createYmodFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createYmodFunction(modelName::String,
                   dirModel::String,
                   stateNames,
                   paramData::ParamData,
                   namesParamDyn::Array{String, 1},
                   observablesData::DataFrame,
                   modelDict)

For modelName create a function for computing yMod by translating the observablesData
PeTab-file into Julia syntax.

To correctly create the function the state-names, names of dynamic parameters to estiamte
(namesDynParam) and PeTab parameter-file (to get constant parameters) data are needed.

The modelDict is used to define explicit rules to the Ymod file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L54-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getIndicesParam-Tuple{PEtab.ParamData, PEtab.MeasurementData, ModelingToolkit.ODESystem, DataFrames.DataFrame}" href="#PEtab.getIndicesParam-Tuple{PEtab.ParamData, PEtab.MeasurementData, ModelingToolkit.ODESystem, DataFrames.DataFrame}"><code>PEtab.getIndicesParam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIndicesParam(paramData::ParamData, measurementData::MeasurementData)::ParameterIndices

For a PeTab-model creates index vectors for extracting the dynamic-, observable- and sd-parameters from
the  optimizsing parameter vector, and indices and maps to effectively for an observation, when computing
the likelhood, to extract the correct SD- and obs-parameters.

When correctly extracting sd- or obs-parameters the `ParamMap` struct is used. This struct has precomputed
values for which parameters belong to a specific observation, for example, which of the to be estimated
observable parameters should be used when computing a part of the likelihood.

See also: [`ParameterIndices`, `ParamMap`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Map_parameters.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getNoiseParamStr-Tuple{String}" href="#PEtab.getNoiseParamStr-Tuple{String}"><code>PEtab.getNoiseParamStr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNoiseParamStr(sdFormula::String)::String

Helper function to extract all the noiseParameter in noiseParameter formula in the PeTab file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L533-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getObsParamStr-Tuple{String}" href="#PEtab.getObsParamStr-Tuple{String}"><code>PEtab.getObsParamStr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getObsParamStr(measurmentFormula::String)::String

Helper function to extract all observableParameter in the observableFormula in the PeTab-file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L511-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getRowExpId-Tuple{String, DataFrames.DataFrame}" href="#PEtab.getRowExpId-Tuple{String, DataFrames.DataFrame}"><code>PEtab.getRowExpId</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getRowExpId(expId::String, data::DataFrame; colSearch=&quot;conditionId&quot;)</code></pre><p>Small helper function to get which row in a DataFrame corresponds to specific ExpId</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Solve_ode_model.jl#L693-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getSimulationInfo-Tuple{DataFrames.DataFrame, PEtab.MeasurementData}" href="#PEtab.getSimulationInfo-Tuple{DataFrames.DataFrame, PEtab.MeasurementData}"><code>PEtab.getSimulationInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getSimulationInfo(measurementData::DataFrame)::SimulationInfo

Using the PeTab measurementData-file extract information on the foward ODE simulations.

Specifcially extract the experimental ID:s from the experimentalCondition - PeTab file;
firstExpIds (preequilibration ID:s), the shiftExpIds (postequilibration), and
simulateSS (whether or not to simulate ODE-model to steady state). Further
stores a solArray with the ODE solution where conditionIdSol of the ID for
each forward solution

TODO: Compute t-vec save at from measurementDataFile (instead of providing another struct)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getTimeMax-Tuple{DataFrames.DataFrame, String}" href="#PEtab.getTimeMax-Tuple{DataFrames.DataFrame, String}"><code>PEtab.getTimeMax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getTimeMax(measurementData::DataFrame, expId::String)::Float64

Small helper function to get the time-max value for a specific simulationConditionId when simulating
the PeTab ODE-model</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.getWord-Tuple{String, Int64, Vector{Char}}" href="#PEtab.getWord-Tuple{String, Int64, Vector{Char}}"><code>PEtab.getWord</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getWord(str::String, iStart, charListTerm)

In a string starting from position iStart extract the next &quot;word&quot;, which is the longest
concurent occurance of characters that are not in the character list with word termination
characters. Returns the word and iEnd (the position where the word ends).

For example, if charListTerm = [&#39;(&#39;, &#39;)&#39;, &#39;+&#39;, &#39;-&#39;, &#39;/&#39;, &#39;*&#39;, &#39;^&#39;] abc123 is
considered a word but not abc123*.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L382-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.isNumber-Tuple{AbstractString}" href="#PEtab.isNumber-Tuple{AbstractString}"><code>PEtab.isNumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isNumber(x::AbstractString)::Bool</code></pre><p>Check if a string x is a number (Float).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Common.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.peTabFormulaToJulia-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}" href="#PEtab.peTabFormulaToJulia-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}"><code>PEtab.peTabFormulaToJulia</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">peTabFormulaToJulia(formula::String, stateNames, paramData::ParamData, namesParamDyn::Array{String, 1}, namesNonDynParam::Array{String, 1}, namesExplicitRules::Array{String, 1})::String
Translate a peTab formula (e.g for observable or for sd-parameter) into Julia syntax and output the result
as a string.

State-names, namesParamDyn and paramData are all required to correctly identify states and parameters in the formula.
namesExplicitRules is optional and is only set if there are any explicit rules in the SBML-file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L342-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.processMeasurementData-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}" href="#PEtab.processMeasurementData-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}"><code>PEtab.processMeasurementData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processMeasurementData(measurementData::DataFrame, observableData::DataFrame)::MeasurementData

Process the PeTab measurementData file into a type-stable Julia struct.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.processParameterData-Tuple{DataFrames.DataFrame}" href="#PEtab.processParameterData-Tuple{DataFrames.DataFrame}"><code>PEtab.processParameterData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processParameterData(parameterData::DataFrame)::ParamData

Process the PeTab parameterData file into a type-stable Julia struct.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.readDataFiles-Tuple{String}" href="#PEtab.readDataFiles-Tuple{String}"><code>PEtab.readDataFiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readDataFiles(dirModel::String; readObs::Bool=false)

Given a directory for a model, e.g ./Beer_MolBioSystems2014, read the associated PeTab files
for the measurements, parameters, experimental conditions and (if true) the observables.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParamData}" href="#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParamData}"><code>PEtab.setParamToFileValues!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setParamToFileValues!(paramMap, stateMap, paramData::ParamData)

Function that sets the parameter and state values in paramMap and stateMap
to those in the PeTab parameters file.

Used when setting up the PeTab cost function, and when solving the ODE-system
for the values in the parameters-file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Common.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setUpCostGradHess-Tuple{PeTabModel, Any, Float64}" href="#PEtab.setUpCostGradHess-Tuple{PeTabModel, Any, Float64}"><code>PEtab.setUpCostGradHess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setUpCostGradHess(peTabModel::PeTabModel, solver, tol::Float64)

For a PeTab-model set up functions for computing i) the likelihood, ii) likelhood gradient,
and iii) likelhood Hessian block approximation. The functions are stored in PeTabOpt-struct
that can be used as input to the optimizers.

Currently the gradient for dynamic parameters (part of ODE-system) is computed via ForwardDiff,
and ReverseDiff is used for observable and sd parameters. The hessian approximation assumes the
interaction betweeen dynamic and (observable, sd) parameters is zero.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.setUpPeTabModel-Tuple{String, String}" href="#PEtab.setUpPeTabModel-Tuple{String, String}"><code>PEtab.setUpPeTabModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setUpPeTabModel(modelName::String, dirModel::String)::PeTabModel

Given a model directory (dirModel) containing the PeTab files and a
xml-file on format modelName.xml will return a PeTabModel struct holding
paths to PeTab files, ode-system in ModellingToolkit format, functions for
evaluating yMod, u0 and standard deviations, and a parameter and state maps
for how parameters and states are mapped in the ModellingToolkit ODE system
along with state and parameter names.

dirModel must contain a SBML file named modelName.xml, and files starting with
measurementData, experimentalCondition, parameter, and observables (tsv-files).
The latter files must be unique (e.g only one file starting with measurementData)

TODO : Example</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Process_PeTab_files.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.solveOdeModelAllExperimentalCond!-Tuple{Vector{&lt;:SciMLBase.AbstractODESolution}, SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}" href="#PEtab.solveOdeModelAllExperimentalCond!-Tuple{Vector{&lt;:SciMLBase.AbstractODESolution}, SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}"><code>PEtab.solveOdeModelAllExperimentalCond!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solveOdeModelAllExperimentalCond!(solArray::Vector{&lt;:SciMLBase.AbstractODESolution},
                                  prob::ODEProblem,
                                  changeToExperimentalCondUse!::Function,
                                  measurementData::DataFrame,
                                  simulationInfo::SimulationInfo,
                                  solver,
                                  tol::Float64;
                                  nTSave::Int64=0,
                                  denseSol::Bool=true)::Bool

Solve a PeTab ODE model for all experimental conditions specified in the PeTab experimentaCondition-file
and store each ODE-soluation into solArray. Returns true if model could be solved succesfully for all
conditions, else returns false.

All inputs are automatically computed by the PeTab importer. Each experimental condition is simulated to the
maximum time for that condition found in the the measurementData PeTab-file. In case a pre-equlibration condition
exists the model is first simulated to a steady-state. Then starting from the steady state the solution stored in
solArray is calculcated.

# Args
`solArray`: array storing ODE-solution for each experimental condition. Is pre-allocated by PeTab importer.
`prob`: ODEProblem struct for the model to be simulated.
`changeToExperimentalCondUse!`: function that changes the parameters for the ODE-problem to those for a specific experimental condition
`measurementData`: the PeTab measurementData file
`simulationInfo`: struct storing simulation info like experimental conditions, whether or not to simulate to a steady state.
`solver`: ode-solver for solving the ode-problem. Any Julia solver or alg-hint works.
`tol`: rel- and abs-tol for the ODE solver
`nTSave`: number of equidistant data-points to save for each ODE-solution. If 0 the ODE-solver outputs a dense solution.
`denseSol`: whether to have a dense (true) or none-dense (false) ODE-solution for each experimental condition.

See also: [`setUpCostFunc`, `SimulationInfo`, `changeToExperimentalCond!`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Solve_ode_model.jl#L41-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.solveOdeModelAtFileValues-Tuple{PeTabModel, Any, Float64}" href="#PEtab.solveOdeModelAtFileValues-Tuple{PeTabModel, Any, Float64}"><code>PEtab.solveOdeModelAtFileValues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solveOdeModelAtFileValues(peTabModel::PeTabModel)

For a peTab model solve the ODE:s at the values in the parameters-PeTab-file
using a specific solver with absTol=relTol=tol. Returns an array with the
solution for each experimenta condition along with a vector with the condition
name for each solution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Solve_ode_model.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.solveOdeNoSS-Tuple{SciMLBase.ODEProblem, Function, String, Float64, Float64, Any, Float64}" href="#PEtab.solveOdeNoSS-Tuple{SciMLBase.ODEProblem, Function, String, Float64, Float64, Any, Float64}"><code>PEtab.solveOdeNoSS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solveOdeNoSS(prob::ODEProblem,
             changeToExperimentalCondUse!::Function,
             firstExpId::String,
             tol::Float64,
             t_max::Float64,
             solver;
             tSave=Float64[],
             nTSave=0,
             denseSol=true)

For an experimentaCondition specifed by firstExpId solve a PeTab ODE-problem using any Julia ODE-solver
(solver can also be an alg-hint) using absTol and relTol value given by tol. Returns an ODE-solution.

Here the model is not simulated to steady state first first simualted to a steady state
Optional args are the save as for `solveOdeModelAllExperimentalCond!`, and this function
is called by `solveOdeModelAllExperimentalCond!`.

See also: [`solveOdeModelAllExperimentalCond!`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Solve_ode_model.jl#L466-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.solveOdeSS-Tuple{SciMLBase.ODEProblem, Function, String, String, Float64, Float64, Float64, Any}" href="#PEtab.solveOdeSS-Tuple{SciMLBase.ODEProblem, Function, String, String, Float64, Float64, Float64, Any}"><code>PEtab.solveOdeSS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solveOdeSS(prob::ODEProblem,
           changeToExperimentalCondUse!::Function,
           firstExpId::String,
           shiftExpId::String,
           tol::Float64,
           t_max_ss::Float64,
           solver;
           tSave=Float64[],
           nTSave=0,
           denseSol=true)

For an experimentaCondition specifed by firstExpId (preequilibration ID) and shiftExpId
(postequilibration ID) solve a PeTab ODE-problem using any Julia ODE-solver (solver can
also be an alg-hint) using absTol and relTol value given by tol. Returns an ODE-solution.

Here the model is first simualted to a steady state using the experimental-condition parameters
corresponding to firstExpId in the experimentaCondition peTab-file. Then using the experimental-condition
parameters specifed by shiftExpId the actual simulation that is saved and returned is produced.
Optional args are the save as for `solveOdeModelAllExperimentalCond!`, and this function is called
by solveOdeModelAllExperimentalCond!.

See also: [`solveOdeModelAllExperimentalCond!`]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/Solve_ODE_model/Solve_ode_model.jl#L355-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.transformObsOrData-Tuple{Any, Symbol}" href="#PEtab.transformObsOrData-Tuple{Any, Symbol}"><code>PEtab.transformObsOrData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformObsOrData(val, transform::Symbol)</code></pre><p>Transform val using either :lin (identity), :log10 and :log transforamtions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Common.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.transformParamVec!-Tuple{Any, Vector{String}, PEtab.ParamData}" href="#PEtab.transformParamVec!-Tuple{Any, Vector{String}, PEtab.ParamData}"><code>PEtab.transformParamVec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformParamVec!(paramVec, namesParam::Array{String, 1}, paramData::ParamData; revTransform::Bool=false)

Helper function which transforms in-place a parameter vector with parameters specied in namesParam according to the
transformation for said parameter specifid in paramData.shouldTransform. In case revTransform is true
performs the inverse parameter transformation (e.g exp10 instead of log10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L744-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.transformParamVec-Tuple{Any, Vector{String}, PEtab.ParamData}" href="#PEtab.transformParamVec-Tuple{Any, Vector{String}, PEtab.ParamData}"><code>PEtab.transformParamVec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformParamVec!(paramVec, namesParam::Array{String, 1}, paramData::ParamData; revTransform::Bool=false)

Helper function which returns a transformed parameter vector with parameters specied in namesParam according to the
transformation for said parameter specifid in paramData.shouldTransform. In case revTransform is true
performs the inverse parameter transformation (e.g exp10 instead of log10).

The function is fully compatible with Zygote.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_cost_grad_hessian.jl#L770-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.transformYobsOrYmodArr!-Tuple{Any, AbstractVector{&lt;:Symbol}}" href="#PEtab.transformYobsOrYmodArr!-Tuple{Any, AbstractVector{&lt;:Symbol}}"><code>PEtab.transformYobsOrYmodArr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformYobsOrYmodArr!(vals, transformationArr::Vector{Symbol})</code></pre><p>Transform the Yobs or Ymod arrays (vals) in place using for each value in vals the transformation specifed in transformationArr.</p><p>Currently :lin, :log10 and :log transforamtions are supported, see <code>setUpCostFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Common.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.wordToJuliaSyntax-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}" href="#PEtab.wordToJuliaSyntax-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}"><code>PEtab.wordToJuliaSyntax</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;     wordToJuliaSyntax(wordTranslate::String,                            stateNames,                            paramData::ParamData,                            namesParamDyn::Array{String, 1},                            namesExplicitRules::Array{String, 1})::String</p><pre><code class="nohighlight hljs">Translate a word (state, parameter, math-expression or number) into Julia syntax
when building Ymod, U0 and Sd functions.
namesExplicitRules is optional and is only set if there are any explicit rules in the SBML-file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/PeTab_importer/Create_obs_u0_sd_functions.jl#L434-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEtab.writeODEModelToFile-Tuple{Any, Any, Any}" href="#PEtab.writeODEModelToFile-Tuple{Any, Any, Any}"><code>PEtab.writeODEModelToFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">writeODEModelToFile(modelDict, modelName, dirModel)

Takes a modelDict as defined by buildODEModelDictionary
and creates a Julia ModelingToolkit file and stores
the resulting file in dirModel with name modelName.jl.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/efc0fc6b70823555d5bf6a4f5254356ff6b63b40/src/SBML/SBML_to_ModellingToolkit.jl#L312-L319">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 8 December 2022 20:58">Thursday 8 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
