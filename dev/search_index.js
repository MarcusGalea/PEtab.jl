var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PEtab","category":"page"},{"location":"#PEtab","page":"Home","title":"PEtab","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PEtab.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PEtab]","category":"page"},{"location":"#PEtab.MeasurementData","page":"Home","title":"PEtab.MeasurementData","text":"MeasurementData\n\nStruct storing the data in the PeTab measurementData-file in type-stable manner.\n\nTransform data supports log and log10 transformations of the data.\n\nSee also: [processMeasurementData]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.ParamData","page":"Home","title":"PEtab.ParamData","text":"ParamData\n\nStruct storing the data in the PeTab parameter-file in type-stable manner.\n\nCurrently logScale notices whether or not parameters are estimated on the log10 scale or not.\n\nSee also: [processParameterData]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.ParamMap","page":"Home","title":"PEtab.ParamMap","text":"ParamMap\n\nStruct which makes out a map to correctly for an observation extract the correct observable or sd-param via the getObsOrSdParam function when computing the likelihood. Correctly built by buildMapParameters, and is part of the ParameterIndices-struct.\n\nFor noise or observable parameters belong to an observation, e.g (obsParam1, obsParam2), this struct stores which parameters should be estimtated, and for those parameters which index they correspond to in the parameter estimation vector. For constant parameters the struct stores the values.\n\nSee also: [getIndicesParam, buildMapParameters]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.ParameterIndices","page":"Home","title":"PEtab.ParameterIndices","text":"ParameterIndices\n\nStruct storing names and mapping indices for mapping the parameter provided to the optimizers correctly.\n\nOptimizers require a single vector input of parameters (pVecEst). However, the PeTab model has three kind of parameters, Dynmaic (part of the ODE-system), Observable (only part of the observation model) and Standard-deviation (only part of the standard deviation expression in the log-likelhood). This struct stores mapping indices (starting with i) to map pVecEst correctly when computing the likelihood (e.g map the SD-parameters in pVecEst correctly to a vector of SD-vals). Also stores the name of each parameter.\n\nFurthermore, when computing yMod or SD the correct observable and sd parameters has to be used for each observation. The mapArrays effectively contains precomputed maps allowing said parameter to be effectively be extracted by the getObsOrSdParam function.\n\nSee also: [getIndicesParam, ParamMap]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.PeTabModel","page":"Home","title":"PEtab.PeTabModel","text":"PeTabModel\n\nStruct storing information about a PeTab-model. Create by the setUpCostFunc function.\n\nArgs\n\nmodelName: PeTab model name (must match the xml-file name) evalYmod: Function to evaluate yMod for the log-likelhood. evalU0!: Function that computes the initial u0 value for the ODE-system. evalSd!: Function that computes the standard deviation value for the log-likelhood. odeSystem: ModellingToolkit ODE-system for the PeTab model. paramMap: A map to correctly map model parameters to the ODE-system. stateMap: A map to correctly mapping the parameters to the u0 values. paramNames: Names of the model parameters (both fixed and those to be estimated). stateNames: Names of the model states. dirModel: Directory where the model.xml and PeTab files are stored. pathMeasurementData: Path to the measurementData PeTab file. pathMeasurementData: Path to the experimentaCondition PeTab file pathMeasurementData: Path to the observables PeTab file pathMeasurementData: Path to the parameters PeTab file\n\nSee also: [setUpCostFunc]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.SimulationInfo","page":"Home","title":"PEtab.SimulationInfo","text":"SimulationInfo\n\nStruct storing simulation (forward ODE-solution) information. Specifcially stores the experimental ID:s from the experimentalCondition - PeTab file; firstExpIds (preequilibration ID:s), the shiftExpIds (postequilibration), and simulateSS (whether or not to simulate ODE-model to steady state). Further stores a solArray with the ODE solution where conditionIdSol of the ID for each forward solution. It also stores for each experimental condition which time-points we have observed data at\n\nSee also: [getSimulationInfo]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.XmlToModellingToolkit-Tuple{String, String, String}","page":"Home","title":"PEtab.XmlToModellingToolkit","text":"XmlToModellingToolkit(pathXml::String, modelName::String, dirModel::String)\n\nConvert a SBML file in pathXml to a Julia ModelingToolkit file and store\nthe resulting file in dirModel with name modelName.jl.\n\nThe SBML importer goes via libsbml in Python and currently likelly only\nworks with SBML level 3.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcAccuracyOdeSolver-Tuple{SciMLBase.ODEProblem, Vector{<:SciMLBase.AbstractODESolution}, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}","page":"Home","title":"PEtab.calcAccuracyOdeSolver","text":"calcAccuracyOdeSolver(prob::ODEProblem,\n                      solArrayHighAccuracy::Vector{<:SciMLBase.AbstractODESolution},\n                      changeToExperimentalCondUse!::Function,\n                      measurementData::DataFrame,\n                      simulationInfo::SimulationInfo,\n                      solver,\n                      absTol::Float64,\n                      relTol::Float64)::Float64\n\nCheck the accuracy of an ODE solver at specific tol=absTol=relTol for a PeTab ODE model (odeProb) by for each experimental condition computing the squared sum difference against a high accuracy ODE solution (for each experimental condition) stored in solArrayHighAccuracy.\n\nRecomended to compute high accuracy solution with small tolerances (1e-15) using a high accuracy solver and BigFloat.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcCost-Tuple{Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}","page":"Home","title":"PEtab.calcCost","text":"calcCost(paramVecEst,\n         odeProb::ODEProblem,\n         peTabModel::PeTabModel,\n         simulationInfo::SimulationInfo,\n         paramIndices::ParameterIndices,\n         measurementData::MeasurementData,\n         parameterData::ParamData,\n         changeModelParamUse!::Function,\n         solveOdeModelAllCondUse!::Function;\n         calcHessian::Bool=false)\n\nFor a PeTab model compute the cost (likelhood) for a parameter vector\nparamVecEst. With respect to paramVecEst (all other inputs fixed)\nthe function is compatible with ForwardDiff.\n\nTo compute the cost an ODE-problem, peTabModel, ODE simulation info,\nindices to map parameter from paramVecEst, measurement data, parameter\ndata (e.g constant parameters), function to map parameters correctly to\nODE-model, and a function to solve the ODE model are required. These\nare all set up correctly by the `setUpCostGradHess` function.\n\nSee also: [`setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcGradCost!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1<:(Vector{<:AbstractFloat}), T2<:(Vector{<:Real})}","page":"Home","title":"PEtab.calcGradCost!","text":"calcGradCost!(grad::T1,\n              paramVecEst,\n              odeProb::ODEProblem,\n              peTabModel::PeTabModel,\n              simulationInfo::SimulationInfo,\n              paramIndices::ParameterIndices,\n              measurementData::MeasurementData,\n              parameterData::ParamData,\n              changeModelParamUse!::Function,\n              solveOdeModelAllCondUse!::Function) where T1<:Array{<:AbstractFloat, 1}\n\nFor a PeTab model compute inplace the gradient  of the cost (likelhood) for\na parameter vector paramVecEst.\n\nCurrently the gradient for dynamic parameters (part of ODE-system) is computed via ForwardDiff,\nand ReverseDiff is used for observable and sd parameters. The input arguements are the same\nas for `calcCost`, and everything is setup by `setUpCostGradHess` function.\n\nSee also: [`setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcHessianApprox!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}} where {T1<:(Matrix{<:AbstractFloat}), T2<:(Vector{<:Real})}","page":"Home","title":"PEtab.calcHessianApprox!","text":"calcHessianApprox!(hessian::T1,\n                   paramVecEst,\n                   odeProb::ODEProblem,\n                   peTabModel::PeTabModel,\n                   simulationInfo::SimulationInfo,\n                   paramIndices::ParameterIndices,\n                   measurementData::MeasurementData,\n                   parameterData::ParamData,\n                   changeModelParamUse!::Function,\n                   solveOdeModelAllCondUse!::Function) where T1<:Array{<:AbstractFloat, 2}\n\nFor a PeTab model compute inplace hessian approximation of the cost (likelhood) for\na parameter vector paramVecEst.\n\nThe hessian approximation assumes the interaction betweeen dynamic and (observable, sd) parameters is zero.\nThe input arguements are the same as for `calcCost`, and everything is setup by `setUpCostGradHess` function.\n\nSee also: [`setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcHighAccOdeSolution-Tuple{SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo}","page":"Home","title":"PEtab.calcHighAccOdeSolution","text":"calcHighAccOdeSolution(prob::ODEProblem,\n                       changeToExperimentalCondUse!::Function,\n                       measurementData::DataFrame,\n                       simulationInfo::SimulationInfo;\n                       absTol::Float64=1e-15,\n                       relTol::Float64=1e-15,\n                       nTSave=100)\n\nFor a PeTab ODE model with the parameter values in prob compute a high accuracy ODE solution with absTol=relTol=tol using BigFloats for the ode-problem. The ODE is solved for all experimental conditions specified in the PeTab files. Returns an array with ODE-solution and a bool which is true if the ODE model could be solved.\n\nBy default the function first tries to solve the ODE problem using a non-stiff solver AutoVern9(Rodas4P()). In case the non-stiff solver fails the Rodas4P() is used to compute the high accuracy solution. If both solvers fail status fail is returned.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcLogLik-Tuple{Any, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData}","page":"Home","title":"PEtab.calcLogLik","text":"calcLogLik(dynamicParamEst::T1,\n                sdParamEst,\n                obsPar,\n                peTabModel::PeTabModel,\n                simulationInfo::SimulationInfo,\n                paramIndices::ParameterIndices,\n                measurementData::MeasurementData,\n                parameterData::ParamData;\n                gradHessDynParam::Bool=false)::Real where T1<:Vector{<:Real}\n\nHelper function computing the likelhood by given after solving the ODE-system using\nusing the dynamic-parameters, sd-parameters and observable parameters.\n\nCurrently for Gaussian data log10 and non-transformed data is accepted.\n\nSee also: [`calcCost`, `setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcLogLikNotSolveODE-Union{Tuple{T1}, Tuple{T1, Any, Any, Any, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, PEtab.PriorInfo}} where T1<:(Vector{<:Real})","page":"Home","title":"PEtab.calcLogLikNotSolveODE","text":"calcLogLikNotSolveODE(dynamicParamEst,\n                      sdParamEst,\n                      obsParamEst,\n                      peTabModel::PeTabModel,\n                      simulationInfo::SimulationInfo,\n                      paramIndices::ParameterIndices,\n                      measurementData::MeasurementData,\n                      parameterData::ParamData)\n\nHelper function computing the likelhood by given  an already existing ODE-solution stored\nin simulationInfo using the dynamic-parameters, sd-parameters and observable parameters.\n\nWhen computing the cost and gradient/hessian for the sd- and observable-parameters\nonly a solved ODE-system is needed (no need to resolve). This greatly reduces run-time\nsince a lot of dual numbers do not have to be propegated through the ODE solver.\nBesides the different parameter vector the input arguements are the same as for `calcCost`,\nand everything is setup by `setUpCostGradHess` function.\n\nSee also: [`calcCost`, `setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcLogLikSolveODE-Tuple{Any, Any, Any, Any, SciMLBase.ODEProblem, PeTabModel, PEtab.SimulationInfo, PEtab.ParameterIndices, PEtab.MeasurementData, PEtab.ParamData, Function, Function, PEtab.PriorInfo}","page":"Home","title":"PEtab.calcLogLikSolveODE","text":"calcLogLikSolveODE(dynamicParamEst,\n                   sdParamEst,\n                   obsParEst,\n                   nonDynParamEst,\n                   odeProb::ODEProblem,\n                   peTabModel::PeTabModel,\n                   simulationInfo::SimulationInfo,\n                   measurementData ::MeasurementData,\n                   parameterData::ParamData,\n                   changeModelParamUse!::Function,\n                   solveOdeModelAllCondUse!::Function,\n                   computeGradOrHess::Bool=false)\n\nHelper function computing the likelhood by solving the ODE system for all\nPeTab-specifed experimental conditions using the dynamic-parameters,\nsd-parameters and observable parameters.\n\nWhen computing the cost and gradient/hessian for dynamic parameters the ODE\nsystem must be solved before getting the likelhood. Besides the different\nparameter vector the input arguements are the same as for `calcCost`, and\neverything is setup by `setUpCostGradHess` function.\n\nSee also: [`calcCost`, `setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.calcSqErrVal-Tuple{Any, Any, Float64}","page":"Home","title":"PEtab.calcSqErrVal","text":"calcSqErrVal(solHighAccuracy, sol, t_max::Float64)::Float64\n\nHelper function to compute the squared sum difference betweeen two ODESolutions solved to t_max. Here solHighAccuracy is meant to be a high accuracy solution.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.changeExperimentalCond!-Tuple{Any, Any, String, PEtab.ParamData, DataFrames.DataFrame, PeTabModel}","page":"Home","title":"PEtab.changeExperimentalCond!","text":"changeExperimentalCond!(paramVec,\n                        stateVec,\n                        expID::String,\n                        parameterData::ParamData,\n                        experimentalConditions::DataFrame,\n                        peTabModel::PeTabModel)\n\nChange the ODE parameter vector (paramVec) and initial value vector (stateVec) values to the values specified for the experimental ID expID given by the experimentalConditions peTab-file for a specific peTabModel.\n\nparameterData is needed to correctly map the parameters. The function can handle that paramVec is a Float64 vector or a vector of Duals for the gradient calculations. This function is used by the solveOdeModelAllExperimentalCond!.\n\nSee also: [solveOdeModelAllExperimentalCond!]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.changeModelParam!-Tuple{Any, Any, Any, PEtab.ParameterIndices, PeTabModel}","page":"Home","title":"PEtab.changeModelParam!","text":"changeModelParam!(paramVecOdeModel,\n                  stateVecOdeModel,\n                  paramVecEst,\n                  paramEstNames::Array{String, 1},\n                  paramIndices::ParameterIndices,\n                  peTabModel::PeTabModel)\n\nChange the ODE parameter vector (paramVecOdeModel) and initial value vector (stateVecOdeModel)\nvalues to the values in parameter vector used for parameter estimation paramVecEst.\nBasically, map the parameter-estiamtion vector to the ODE model.\n\nThe function can handle that paramVecEst is a Float64 vector or a vector of Duals for the\ngradient calculations. This function is used when computing the cost, and everything\nis set up by `setUpCostGradHess`.\n\nSee also: [`setUpCostGradHess`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.checkForPeTabFile-Tuple{String, String}","page":"Home","title":"PEtab.checkForPeTabFile","text":"checkForPeTabFile(fileSearchFor::String, dirModel::String)::String\n\nHelper function to check in dirModel if a file starting with fileSearchFor exists.\nIf true return file path.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createBigFloatODEProblem-Tuple{PeTabModel}","page":"Home","title":"PEtab.createBigFloatODEProblem","text":"createBigFloatODEProblem(peTabModel::PeTabModel)::ODEProblem\n\nFrom a PeTab model create its corresponding ODE-problem with BigFloat (long double).\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createBigFloatODEProblem-Tuple{SciMLBase.ODEProblem}","page":"Home","title":"PEtab.createBigFloatODEProblem","text":"createBigFloatODEProblem(odeProb::ODEProblem)::ODEProblem\n\nConvert an ODE problem with arbitrary float to one an ODE-problem with BigFloat.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createFileYmodSdU0-Tuple{String, String, ModelingToolkit.ODESystem, Any, Any}","page":"Home","title":"PEtab.createFileYmodSdU0","text":"createFileYmodSdU0(modelName::String,\n                   dirModel::String,\n                   odeSys::ODESystem,\n                   stateMap,\n                   modelDict)\n\nFor a PeTab model with name modelName with all PeTab-files in dirModel and associated\nModellingToolkit ODESystem (with its stateMap) build a file containing a functions for\ni) computing the observable model value (yMod) ii) compute the initial value u0 (by using the\nstateMap) and iii) computing the standard error (sd) for each observableFormula in the\nobservables PeTab file.\n\nNote - The produced Julia file will go via the JIT-compiler.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createSdFunction-Tuple{String, String, PEtab.ParamData, Any, Vector{String}, Vector{String}, DataFrames.DataFrame}","page":"Home","title":"PEtab.createSdFunction","text":"createSdFunction(modelName::String,\n                      dirModel::String,\n                      paramData::ParamData,\n                      stateNames,\n                      namesParamDyn::Array{String, 1},\n                      observablesData::DataFrame)\n\nFor modelName create a function for computing the standard deviation by translating the observablesData\nPeTab-file into Julia syntax.\n\nTo correctly create the function the state-names, names of dynamic parameters to estiamte\n(namesDynParam) and PeTab parameter-file (to get constant parameters) data are needed.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createU0Function-Tuple{String, String, PEtab.ParamData, Vector{String}, Any}","page":"Home","title":"PEtab.createU0Function","text":"createU0Function(modelName::String,\n                     dirModel::String,\n                     paramData::ParamData,\n                     namesParameter::Array{String, 1},\n                     stateMap)\n\nFor modelName create a function for computing initial value by translating the stateMap\ninto Julia syntax.\n\nTo correctly create the function the name of all parameters, paramData (to get constant parameters)\nare required.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createYmodFunction-Tuple{String, String, Any, PEtab.ParamData, Vector{String}, Vector{String}, DataFrames.DataFrame, Any}","page":"Home","title":"PEtab.createYmodFunction","text":"createYmodFunction(modelName::String,\n                   dirModel::String,\n                   stateNames,\n                   paramData::ParamData,\n                   namesParamDyn::Array{String, 1},\n                   observablesData::DataFrame,\n                   modelDict)\n\nFor modelName create a function for computing yMod by translating the observablesData\nPeTab-file into Julia syntax.\n\nTo correctly create the function the state-names, names of dynamic parameters to estiamte\n(namesDynParam) and PeTab parameter-file (to get constant parameters) data are needed.\n\nThe modelDict is used to define explicit rules to the Ymod file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getIndicesParam-Tuple{PEtab.ParamData, PEtab.MeasurementData, ModelingToolkit.ODESystem, DataFrames.DataFrame}","page":"Home","title":"PEtab.getIndicesParam","text":"getIndicesParam(paramData::ParamData, measurementData::MeasurementData)::ParameterIndices\n\nFor a PeTab-model creates index vectors for extracting the dynamic-, observable- and sd-parameters from\nthe  optimizsing parameter vector, and indices and maps to effectively for an observation, when computing\nthe likelhood, to extract the correct SD- and obs-parameters.\n\nWhen correctly extracting sd- or obs-parameters the `ParamMap` struct is used. This struct has precomputed\nvalues for which parameters belong to a specific observation, for example, which of the to be estimated\nobservable parameters should be used when computing a part of the likelihood.\n\nSee also: [`ParameterIndices`, `ParamMap`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getNoiseParamStr-Tuple{String}","page":"Home","title":"PEtab.getNoiseParamStr","text":"getNoiseParamStr(sdFormula::String)::String\n\nHelper function to extract all the noiseParameter in noiseParameter formula in the PeTab file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getObsParamStr-Tuple{String}","page":"Home","title":"PEtab.getObsParamStr","text":"getObsParamStr(measurmentFormula::String)::String\n\nHelper function to extract all observableParameter in the observableFormula in the PeTab-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getRowExpId-Tuple{String, DataFrames.DataFrame}","page":"Home","title":"PEtab.getRowExpId","text":"getRowExpId(expId::String, data::DataFrame; colSearch=\"conditionId\")\n\nSmall helper function to get which row in a DataFrame corresponds to specific ExpId\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getSimulationInfo-Tuple{DataFrames.DataFrame, PEtab.MeasurementData}","page":"Home","title":"PEtab.getSimulationInfo","text":"getSimulationInfo(measurementData::DataFrame)::SimulationInfo\n\nUsing the PeTab measurementData-file extract information on the foward ODE simulations.\n\nSpecifcially extract the experimental ID:s from the experimentalCondition - PeTab file;\nfirstExpIds (preequilibration ID:s), the shiftExpIds (postequilibration), and\nsimulateSS (whether or not to simulate ODE-model to steady state). Further\nstores a solArray with the ODE solution where conditionIdSol of the ID for\neach forward solution\n\nTODO: Compute t-vec save at from measurementDataFile (instead of providing another struct)\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getTimeMax-Tuple{DataFrames.DataFrame, String}","page":"Home","title":"PEtab.getTimeMax","text":"getTimeMax(measurementData::DataFrame, expId::String)::Float64\n\nSmall helper function to get the time-max value for a specific simulationConditionId when simulating\nthe PeTab ODE-model\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getWord-Tuple{String, Int64, Vector{Char}}","page":"Home","title":"PEtab.getWord","text":"getWord(str::String, iStart, charListTerm)\n\nIn a string starting from position iStart extract the next \"word\", which is the longest\nconcurent occurance of characters that are not in the character list with word termination\ncharacters. Returns the word and iEnd (the position where the word ends).\n\nFor example, if charListTerm = ['(', ')', '+', '-', '/', '*', '^'] abc123 is\nconsidered a word but not abc123*.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.isNumber-Tuple{AbstractString}","page":"Home","title":"PEtab.isNumber","text":"isNumber(x::AbstractString)::Bool\n\nCheck if a string x is a number (Float).\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.peTabFormulaToJulia-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.peTabFormulaToJulia","text":"peTabFormulaToJulia(formula::String, stateNames, paramData::ParamData, namesParamDyn::Array{String, 1}, namesNonDynParam::Array{String, 1}, namesExplicitRules::Array{String, 1})::String\nTranslate a peTab formula (e.g for observable or for sd-parameter) into Julia syntax and output the result\nas a string.\n\nState-names, namesParamDyn and paramData are all required to correctly identify states and parameters in the formula.\nnamesExplicitRules is optional and is only set if there are any explicit rules in the SBML-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.processMeasurementData-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PEtab.processMeasurementData","text":"processMeasurementData(measurementData::DataFrame, observableData::DataFrame)::MeasurementData\n\nProcess the PeTab measurementData file into a type-stable Julia struct.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.processParameterData-Tuple{DataFrames.DataFrame}","page":"Home","title":"PEtab.processParameterData","text":"processParameterData(parameterData::DataFrame)::ParamData\n\nProcess the PeTab parameterData file into a type-stable Julia struct.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.readDataFiles-Tuple{String}","page":"Home","title":"PEtab.readDataFiles","text":"readDataFiles(dirModel::String; readObs::Bool=false)\n\nGiven a directory for a model, e.g ./Beer_MolBioSystems2014, read the associated PeTab files\nfor the measurements, parameters, experimental conditions and (if true) the observables.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParamData}","page":"Home","title":"PEtab.setParamToFileValues!","text":"setParamToFileValues!(paramMap, stateMap, paramData::ParamData)\n\nFunction that sets the parameter and state values in paramMap and stateMap\nto those in the PeTab parameters file.\n\nUsed when setting up the PeTab cost function, and when solving the ODE-system\nfor the values in the parameters-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.setUpCostGradHess-Tuple{PeTabModel, Any, Float64}","page":"Home","title":"PEtab.setUpCostGradHess","text":"setUpCostGradHess(peTabModel::PeTabModel, solver, tol::Float64)\n\nFor a PeTab-model set up functions for computing i) the likelihood, ii) likelhood gradient,\nand iii) likelhood Hessian block approximation. The functions are stored in PeTabOpt-struct\nthat can be used as input to the optimizers.\n\nCurrently the gradient for dynamic parameters (part of ODE-system) is computed via ForwardDiff,\nand ReverseDiff is used for observable and sd parameters. The hessian approximation assumes the\ninteraction betweeen dynamic and (observable, sd) parameters is zero.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.setUpPeTabModel-Tuple{String, String}","page":"Home","title":"PEtab.setUpPeTabModel","text":"setUpPeTabModel(modelName::String, dirModel::String)::PeTabModel\n\nGiven a model directory (dirModel) containing the PeTab files and a\nxml-file on format modelName.xml will return a PeTabModel struct holding\npaths to PeTab files, ode-system in ModellingToolkit format, functions for\nevaluating yMod, u0 and standard deviations, and a parameter and state maps\nfor how parameters and states are mapped in the ModellingToolkit ODE system\nalong with state and parameter names.\n\ndirModel must contain a SBML file named modelName.xml, and files starting with\nmeasurementData, experimentalCondition, parameter, and observables (tsv-files).\nThe latter files must be unique (e.g only one file starting with measurementData)\n\nTODO : Example\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.solveOdeModelAllExperimentalCond!-Tuple{Vector{<:SciMLBase.AbstractODESolution}, SciMLBase.ODEProblem, Function, DataFrames.DataFrame, PEtab.SimulationInfo, Any, Float64, Float64}","page":"Home","title":"PEtab.solveOdeModelAllExperimentalCond!","text":"solveOdeModelAllExperimentalCond!(solArray::Vector{<:SciMLBase.AbstractODESolution},\n                                  prob::ODEProblem,\n                                  changeToExperimentalCondUse!::Function,\n                                  measurementData::DataFrame,\n                                  simulationInfo::SimulationInfo,\n                                  solver,\n                                  tol::Float64;\n                                  nTSave::Int64=0,\n                                  denseSol::Bool=true)::Bool\n\nSolve a PeTab ODE model for all experimental conditions specified in the PeTab experimentaCondition-file\nand store each ODE-soluation into solArray. Returns true if model could be solved succesfully for all\nconditions, else returns false.\n\nAll inputs are automatically computed by the PeTab importer. Each experimental condition is simulated to the\nmaximum time for that condition found in the the measurementData PeTab-file. In case a pre-equlibration condition\nexists the model is first simulated to a steady-state. Then starting from the steady state the solution stored in\nsolArray is calculcated.\n\n# Args\n`solArray`: array storing ODE-solution for each experimental condition. Is pre-allocated by PeTab importer.\n`prob`: ODEProblem struct for the model to be simulated.\n`changeToExperimentalCondUse!`: function that changes the parameters for the ODE-problem to those for a specific experimental condition\n`measurementData`: the PeTab measurementData file\n`simulationInfo`: struct storing simulation info like experimental conditions, whether or not to simulate to a steady state.\n`solver`: ode-solver for solving the ode-problem. Any Julia solver or alg-hint works.\n`tol`: rel- and abs-tol for the ODE solver\n`nTSave`: number of equidistant data-points to save for each ODE-solution. If 0 the ODE-solver outputs a dense solution.\n`denseSol`: whether to have a dense (true) or none-dense (false) ODE-solution for each experimental condition.\n\nSee also: [`setUpCostFunc`, `SimulationInfo`, `changeToExperimentalCond!`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.solveOdeModelAtFileValues-Tuple{PeTabModel, Any, Float64}","page":"Home","title":"PEtab.solveOdeModelAtFileValues","text":"solveOdeModelAtFileValues(peTabModel::PeTabModel)\n\nFor a peTab model solve the ODE:s at the values in the parameters-PeTab-file\nusing a specific solver with absTol=relTol=tol. Returns an array with the\nsolution for each experimenta condition along with a vector with the condition\nname for each solution\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.solveOdeNoSS-Tuple{SciMLBase.ODEProblem, Function, String, Float64, Float64, Any, Float64}","page":"Home","title":"PEtab.solveOdeNoSS","text":"solveOdeNoSS(prob::ODEProblem,\n             changeToExperimentalCondUse!::Function,\n             firstExpId::String,\n             tol::Float64,\n             t_max::Float64,\n             solver;\n             tSave=Float64[],\n             nTSave=0,\n             denseSol=true)\n\nFor an experimentaCondition specifed by firstExpId solve a PeTab ODE-problem using any Julia ODE-solver\n(solver can also be an alg-hint) using absTol and relTol value given by tol. Returns an ODE-solution.\n\nHere the model is not simulated to steady state first first simualted to a steady state\nOptional args are the save as for `solveOdeModelAllExperimentalCond!`, and this function\nis called by `solveOdeModelAllExperimentalCond!`.\n\nSee also: [`solveOdeModelAllExperimentalCond!`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.solveOdeSS-Tuple{SciMLBase.ODEProblem, Function, String, String, Float64, Float64, Float64, Any}","page":"Home","title":"PEtab.solveOdeSS","text":"solveOdeSS(prob::ODEProblem,\n           changeToExperimentalCondUse!::Function,\n           firstExpId::String,\n           shiftExpId::String,\n           tol::Float64,\n           t_max_ss::Float64,\n           solver;\n           tSave=Float64[],\n           nTSave=0,\n           denseSol=true)\n\nFor an experimentaCondition specifed by firstExpId (preequilibration ID) and shiftExpId\n(postequilibration ID) solve a PeTab ODE-problem using any Julia ODE-solver (solver can\nalso be an alg-hint) using absTol and relTol value given by tol. Returns an ODE-solution.\n\nHere the model is first simualted to a steady state using the experimental-condition parameters\ncorresponding to firstExpId in the experimentaCondition peTab-file. Then using the experimental-condition\nparameters specifed by shiftExpId the actual simulation that is saved and returned is produced.\nOptional args are the save as for `solveOdeModelAllExperimentalCond!`, and this function is called\nby solveOdeModelAllExperimentalCond!.\n\nSee also: [`solveOdeModelAllExperimentalCond!`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.transformObsOrData-Tuple{Any, Symbol}","page":"Home","title":"PEtab.transformObsOrData","text":"transformObsOrData(val, transform::Symbol)\n\nTransform val using either :lin (identity), :log10 and :log transforamtions.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.transformParamVec!-Tuple{Any, Vector{String}, PEtab.ParamData}","page":"Home","title":"PEtab.transformParamVec!","text":"transformParamVec!(paramVec, namesParam::Array{String, 1}, paramData::ParamData; revTransform::Bool=false)\n\nHelper function which transforms in-place a parameter vector with parameters specied in namesParam according to the\ntransformation for said parameter specifid in paramData.shouldTransform. In case revTransform is true\nperforms the inverse parameter transformation (e.g exp10 instead of log10)\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.transformParamVec-Tuple{Any, Vector{String}, PEtab.ParamData}","page":"Home","title":"PEtab.transformParamVec","text":"transformParamVec!(paramVec, namesParam::Array{String, 1}, paramData::ParamData; revTransform::Bool=false)\n\nHelper function which returns a transformed parameter vector with parameters specied in namesParam according to the\ntransformation for said parameter specifid in paramData.shouldTransform. In case revTransform is true\nperforms the inverse parameter transformation (e.g exp10 instead of log10).\n\nThe function is fully compatible with Zygote.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.transformYobsOrYmodArr!-Tuple{Any, AbstractVector{<:Symbol}}","page":"Home","title":"PEtab.transformYobsOrYmodArr!","text":"transformYobsOrYmodArr!(vals, transformationArr::Vector{Symbol})\n\nTransform the Yobs or Ymod arrays (vals) in place using for each value in vals the transformation specifed in transformationArr.\n\nCurrently :lin, :log10 and :log transforamtions are supported, see setUpCostFunc.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.wordToJuliaSyntax-Tuple{String, Any, PEtab.ParamData, Vector{String}, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.wordToJuliaSyntax","text":"\"     wordToJuliaSyntax(wordTranslate::String,                            stateNames,                            paramData::ParamData,                            namesParamDyn::Array{String, 1},                            namesExplicitRules::Array{String, 1})::String\n\nTranslate a word (state, parameter, math-expression or number) into Julia syntax\nwhen building Ymod, U0 and Sd functions.\nnamesExplicitRules is optional and is only set if there are any explicit rules in the SBML-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.writeODEModelToFile-Tuple{Any, Any, Any}","page":"Home","title":"PEtab.writeODEModelToFile","text":"writeODEModelToFile(modelDict, modelName, dirModel)\n\nTakes a modelDict as defined by buildODEModelDictionary\nand creates a Julia ModelingToolkit file and stores\nthe resulting file in dirModel with name modelName.jl.\n\n\n\n\n\n","category":"method"}]
}
