var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PEtab","category":"page"},{"location":"#PEtab","page":"Home","title":"PEtab","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PEtab.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PEtab]","category":"page"},{"location":"#PEtab.ODESolverOptions","page":"Home","title":"PEtab.ODESolverOptions","text":"ODESolverOptions\n\nStores ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. \n\nConstructed via `getODESolverOptions`. More info regarding the options and available solvers can be found in the \ndocumentation for DifferentialEquations.jl (https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/), and \nin the documentation for `getODESolverOptions`.\n\n# Fields\n`solver`: Any of the ODE-solvers in DifferentialEquations.jl\n`abstol`: Absolute tolerance when solving the ODE-system. \n`reltol`: Relative tolerance when solving the ODE-system\n`force_dtmin`: Whether or not to force dtmin when solving the ODE-system.\n`dtmin`: Minimal acceptable step-size when solving the ODE-system.\n`maxiters`: Maximum number of iterations when solving the ODE-system.\n\nSee also [`getODESolverOptions`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.PEtabModel","page":"Home","title":"PEtab.PEtabModel","text":"PEtabModel\n\nA PEtab specified problem translated into a Julia compatible format.\n\nCreated from `readPEtabModel` contains helper functions needed to set up cost-, gradient-, hessian-computations, and \nfor handling potential model events (callbacks). \n\nNote1 - Several of the functions in the PEtabModel are not meant to be accessible for the user. For example \ncompute_h (and similar functions) require indices which are built in the background to efficiently map parameter \nbetween experimental (simulation) conditions. Rather, `PEtabModel` holds all information needed to create a \nPEtabODEProblem, and in the future PEtabSDEProblem etc ...\nNote2 - ODEProblem.p refers to the parameters for underlying DifferentialEquations.jl ODEProblem.\n\n# Fields\n`modelName`: Model-name extracted from the PEtab yaml-file. \n`compute_h`: Compute the observable (h) for a specific time-point and simulation condition.\n`compute_u0!`: In-place initial values using the ODEProblem.p for a simulation condition; compute_u0!(u0, p)\n`compute_u0`: As above but not in-place; u0 = compute_u0(p)\n`compute_σ`: Compute the noise parameter σ for specific time-point and simulation condition.\n`compute_∂h∂u!`: Compute the gradient of h with respect to ODE-model states (u) for a specific time-point and \n simulation condition.\n`compute_∂σ∂u!`: As above but for the noise parameter σ\n`compute_∂h∂p!`: As above for h but with respect to ODEProblem.p\n`compute_∂σ∂p!`: As above for σ but with respect to ODEProblem.p\n`computeTStops`: In case the model has DiscreteCallbacks (events) this function computes the event times. \n`convertTspan::Bool`: In case the model has DiscreteCallbacks (events) and the trigger-time is a parameter set to \n be estimated this Bool tracks that for ForwardDiff.jl gradients the time-span should be converted to Dual-numbers. \n`dirModel`: Directory where the model.xml and PEtab files are stored.\n`dirJulia`: Directory where the Julia-model files created by parsing the PEtab files (e.g SBML-file) are stored. \n`odeSystem`: A ModellingToolkit.jl ODE-system obtained from parsing the model SBML-file.  \n`parameterMap`: A ModellingToolkit.jl parameter map for the ODE-system.\n`stateMap`: A ModellingToolkit.jl state map for the ODE-system describing how the inital values are computed, e.g.\n whether or not certain initial values are computed from parameters in the parameterMap.\n`parameterNames`: Names of the parameter in the odeSystem.\n`stateNames`: Names of the states in the odeSystem.\n`pathMeasurements`: Path to the PEtab measurements file\n`pathConditions`: Path to the PEtab conditions file\n`pathObservables`: Path to the PEtab observables file\n`pathParameters`: Path to the PEtab parameters file\n`pathSBML`: Path to the PEtab SBML file\n`pathYAML`: Path to the PEtab yaml file\n`modelCallbackSet`: Stores potential model callbacks (events)\n`checkIfCallbackIsActive`: Piecewise SBML statements are rewritten to DiscreteCallbacks that are activated at a\nspecific time-point. The piecewise callback has a defult value at t0 which is only triggered upon reaching t_activation.\nIn case t_activation ≤ 0 (never reached when solvig the model) this function checks whether or not the callback \nshould be triggered before solving the model. \n\nSee also: [`readPEtabModel`]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.PEtabODEProblem","page":"Home","title":"PEtab.PEtabODEProblem","text":"PEtabODEProblem\n\nAll needed to setup an optimization problem (compute cost, gradient, hessian and parameter bounds) for a PEtab model.\n\nThe PEtabODEproblem for a PEtab problem allows for efficient cost, gradient and hessian computations. Constructed\nvia `setupPEtabODEProblem`, more info on tuneable options can be found in the documentation [add]. \n\n**Note** - the parameter vector θ is **always** assumed to be on parameter scale specified in the PEtab parameters \nfile. If needed θ is transformed to linear scale inside of the function call. \n\n# Fields\n`computeCost`: For θ computes the objective value cost = computeCost(θ)\n`computeGradient!`: For θ computes in-place gradient computeGradient!(gradient, θ)\n`computeHessian!`: For θ computes in-place hessian-(approximation) computeHessian!(hessian, θ)\n`costMethod`: Method for computing the cost (:Standard, :Zygote)\n`gradientMethod`: Method for computing the gradient (:ForwardDiff, :ForwardEquations :Adjoint, :Zygote)\n`hessianMethod`:  Method for computing/approximating the hessian (:ForwardDiff, :BlocForwardDiff :GaussNewton)\n`nParametersToEstimate`: Number of parameter to estimate.\n`θ_estNames`: Names of the parameter in θ\n`θ_nominal`: Nominal θ values as specified in the PEtab parameters-file. \n`θ_nominalT`: Nominal θ values on parameter-scale (e.g log) as specified in the PEtab parameters-file.\n`lowerBounds`: Lower parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.\n`upperBounds`: Upper parameter bounds on parameter-scale for θ as specified in the PEtab parameters-file.\n`petabModel`: PEtabModel used to construct the PEtabODEProblem\n`odeSolverOptions`: ODE-solver options specified when creating the PEtabODEProblem \n`odeSolverGradientOptions`: ODE-solver gradient options specified when creating the PEtabODEProblem \n\nSee also [`setupPEtabODEProblem`](@ref), [`PEtabModel`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.SteadyStateSolverOptions","page":"Home","title":"PEtab.SteadyStateSolverOptions","text":"SteadyStateSolverOptions\n\nStores options (algorithm, tolerances, etc...) to use when computing steady state for models with pre-equlibration.\n\nConstructed via `getSteadyStateSolverOptions` with several potential user options.\n\n# Fields\n`method`: Approach to find steady-state u*; du = f(u*, p, t) ≈ 0. Either :Rootfinding to directly solve the problem \n via optimisation, or :Simulate to via ODE solver simulate model to steady state.\n`rootfindingAlgorithm`: In case of :Rootfinding which algorithm to use. Supports any of the NonlinearSolve algorithms \n (https://docs.sciml.ai/NonlinearSolve/stable/tutorials/nonlinear/).\n`howCheckSimulationReachedSteadyState`: For :Simulate which method to check steady state been reached, options;\n    wrms : Weighted root-mean square : √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) < 1\n    Newton : If Newton-step Δu is sufficiently small : √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) < 1\n`abstol`: Absolute tolerance when checking if steady state has been found. Defaults to 1e-8 for :Rootfinding and\n ODE-solver tolerance divided by 100 for :Simulate\n`reltol`: Relative tolerance when checking if steady state has been found. As for abstol.\n`maxiters`: Maximum number of root-finding or ODE-solver steps when solving for steady state. Defaults to 1e4\n for :Rootfinding and ODE-solver options for :Simulate.\n\nSee also [`getSteadyStateSolverOptions`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.JLToModellingToolkit-Tuple{String, String}","page":"Home","title":"PEtab.JLToModellingToolkit","text":"JLToModellingToolkit(modelName::String, dirModel::String)\nChecks and fixes a Julia ModelingToolkit file and store \nthe fixed file in dirModel with name modelName_fix.jl.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.XmlToModellingToolkit-Tuple{String, AbstractString, AbstractString}","page":"Home","title":"PEtab.XmlToModellingToolkit","text":"XmlToModellingToolkit(pathXml::String, modelName::String, dirModel::String)\nConvert a SBML file in pathXml to a Julia ModelingToolkit file and store \nthe resulting file in dirModel with name modelName.jl. \nThe SBML importer goes via libsbml in Python and currently likelly only \nworks with SBML level 3.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.checkDataFrameColumns-NTuple{5, Any}","page":"Home","title":"PEtab.checkDataFrameColumns","text":"checkDataFrameColumns(dataFrame, dataFrameName, colsToCheck, allowedTypesVec, requiredCols)\n\nGoes through each column from colsToCheck in dataFrame and checks\nif each column is of any of the DataTypes specified in allowedTypesVec[colIndex].\nReturns true if all columns are ok and false otherwise.\nrequiredCols is an array of mandatory columns. If a mandatory column is missing\nan error is thrown, and if a mandatory column contains missing rows a warning is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createDerivative_σ_h_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Dict}","page":"Home","title":"PEtab.createDerivative_σ_h_File","text":"createFileDYmodSdU0(modelName::String, \n                   dirModel::String, \n                   odeSys::ODESystem, \n                   stateMap,\n                   SBMLDict::Dict)\n\nFor a PeTab model with name modelName with all PeTab-files in dirModel and associated \nModellingToolkit ODESystem (with its stateMap) build a file containing a functions for \ni) computing the observable model value (yMod) ii) compute the initial value u0 (by using the \nstateMap) and iii) computing the standard error (sd) for each observableFormula in the \nobservables PeTab file.\nNote - The produced Julia file will go via the JIT-compiler.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createTopOfFunction_h-Tuple{Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.createTopOfFunction_h","text":"createTopOfFunction_h(modelStateNames::Vector{String},\n                      paramData::ParametersInfo,\n                      namesParamODEProb::Vector{String},\n                      namesNonDynParam::Vector{String})\n\nExtracts all variables needed for the observable h function.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createTopOf∂h∂_Function-Tuple{Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame}","page":"Home","title":"PEtab.createTopOf∂h∂_Function","text":"createTopOf∂h∂_Function(modelStateNames::Vector{String}, \n                        pODEProblemNames::Vector{String}, \n                        θ_nonDynamicNames::Vector{String},\n                        observablesData::DataFrame)\n\nExtracts all variables needed for the functions and add them as variables for Symbolics.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_h_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create_h_Function","text":"create_h_Function(modelName::String,\n                  dirModel::String,\n                  modelStateNames::Vector{String},\n                  paramData::ParametersInfo,\n                  namesParamDyn::Vector{String},\n                  namesNonDynParam::Vector{String},\n                  observablesData::DataFrame,\n                  SBMLDict::Dict)\n\nFor modelName create a function for computing yMod by translating the observablesData\nPeTab-file into Julia syntax.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_u0_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Any}","page":"Home","title":"PEtab.create_u0_Function","text":"create_u0_Function(modelName::String,\n                   dirModel::String,\n                   parameterInfo::ParametersInfo,\n                   pODEProblemNames::Vector{String},\n                   stateMap;\n                   inPlace::Bool=true)\n\nFor modelName create a function for computing initial value by translating the stateMap\ninto Julia syntax.\n\nTo correctly create the function the name of all parameters, paramData (to get constant parameters)\nare required.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_σ_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create_σ_Function","text":"create_σ_Function(modelName::String,\n                  dirModel::String,\n                  parameterInfo::ParametersInfo,\n                  modelStateNames::Vector{String},\n                  pODEProblemNames::Vector{String},\n                  θ_nonDynamicNames::Vector{String},\n                  observablesData::DataFrame,\n                  SBMLDict::Dict)\n\nFor modelName create a function for computing the standard deviation σ by translating the observablesData\nPeTab-file into Julia syntax.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_σ_h_u0_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Any, Dict}","page":"Home","title":"PEtab.create_σ_h_u0_File","text":"create_σ_h_u0_File(modelName::String,\n                   dirModel::String,\n                   odeSystem::ODESystem,\n                   stateMap,\n                   SBMLDict::Dict;\n                   verbose::Bool=false)\n\nFor a PeTab model with name modelName with all PeTab-files in dirModel and associated\nModellingToolkit ODESystem (with its stateMap) build a file containing a functions for\ni) computing the observable model value (h) ii) compute the initial value u0 (by using the\nstateMap) and iii) computing the standard error (σ) for each observableFormula in the\nobservables PeTab file.\n\nNote - The produced Julia file will go via the JIT-compiler. The SBML-dict is needed as\nsometimes variables are encoded via explicit-SBML rules.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create∂h∂_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create∂h∂_Function","text":"create∂h∂_Function(modelName::String, \n                   dirModel::String, \n                   modelStateNames::Vector{String}, \n                   parameterInfo::ParametersInfo, \n                   pODEProblemNames::Vector{String}, \n                   θ_nonDynamicNames::Vector{String},\n                   observablesData::DataFrame,\n                   SBMLDict::Dict)\n\nFor modelName create using Symbolics function for computing ∂h/∂u and ∂h/∂p where \nu = modelStates and p = pODEProblem (parameters for ODE problem)\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create∂σ∂_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create∂σ∂_Function","text":"create∂σ∂_Function(modelName::String, \n                        dirModel::String, \n                        parameterInfo::ParametersInfo, \n                        modelStateNames::Vector{String}, \n                        pODEProblemNames::Vector{String}, \n                        θ_nonDynamicNames::Vector{String},\n                        observablesData::DataFrame,\n                        SBMLDict::Dict)\n\nFor modelName create a function for computing the standard deviation by translating the observablesData\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.dualToFloat-Tuple{AbstractFloat}","page":"Home","title":"PEtab.dualToFloat","text":"dualToFloat(x::AbstractFloat)::AbstractFloat\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.dualToFloat-Tuple{ForwardDiff.Dual}","page":"Home","title":"PEtab.dualToFloat","text":"dualToFloat(x::ForwardDiff.Dual)::Real\n\nVia recursion convert a Dual to a Float.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getNoiseParametersStr-Tuple{String}","page":"Home","title":"PEtab.getNoiseParametersStr","text":"getNoiseParametersStr(formula::String)::String\n\nHelper function to extract all the noiseParameter in noiseParameter formula in the PEtab file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getODESolverOptions-Tuple{T1} where T1<:SciMLBase.AbstractSciMLAlgorithm","page":"Home","title":"PEtab.getODESolverOptions","text":"getODESolverOptions(solver, <keyword arguments>)\n\nSetup ODE-solver options (solver, tolerances, etc...) to use when computing gradient/cost for a PEtabODEProblem. \n\nMore info of about the options and available solvers can be found in the documentation for DifferentialEquations.jl \n(https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/). Recommendeded settings for which solver and options \nto use for different problems can be found below and in the documentation.\n\n# Arguments\n`solver`: Any of the ODE-solvers in DifferentialEquations.jl. For small (≤20 states) mildly stiff models \n composite solvers such as `AutoVern7(Rodas5P())` perform well. For stiff small models `Rodas5P()` performs \n well. For medium sized models (≤75states) `QNDF()`, `FBDF()` and `CVODE_BDF()` perform well. `CVODE_BDF()` is \n not compatible with automatic differentiation and thus cannot be used if the gradient is computed via automatic \n differentiation, or if the Gauss-Newton hessian approximation is used. If the gradient is computed via adjoint \n sensitivity analysis `CVODE_BDF()` is often the best choices as it typically is more relaible than `QNDF()` and \n `FBDF()` (fails less often).\n`abstol=1e-8`: Absolute tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. \n`reltol=1e-8`: Relative tolerance when solving the ODE-system. Not recommended to increase above 1e-6 for gradients. \n`force_dtmin=false`: Whether or not to force dtmin when solving the ODE-system.\n`dtmin=nothing`: Minimal acceptable step-size when solving the ODE-system.\n`maxiters=10000`: Maximum number of iterations when solving the ODE-system. Increasing above the default value can \n cause the optimization to take substantial time.\n\nSee also [`ODESolverOptions`](@ref).\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getObservableParametersStr-Tuple{String}","page":"Home","title":"PEtab.getObservableParametersStr","text":"getObservableParametersStr(formula::String)::String\n\nHelper function to extract all observableParameter in the observableFormula in the PEtab-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getSteadyStateSolverOptions-Tuple{Symbol}","page":"Home","title":"PEtab.getSteadyStateSolverOptions","text":"getSteadyStateSolverOptions(method::Symbol;\n                            howCheckSimulationReachedSteadyState::Symbol=:wrms,\n                            rootfindingAlgorithm::Union{Nothing, NonlinearSolve.AbstractNonlinearSolveAlgorithm}=nothing,\n                            abstol=nothing, \n                            reltol=nothing, \n                            maxiters=nothing)::SteadyStateSolverOptions\n\nSetup steady-state solver options for finding steady-state via **either** method=:Rootfinding or method=:Simulate.\n\nFor :Rootfinding the steady state u* is found by solving the problem du = f(u, p, t) ≈ 0 with tolerances \nabstol and reltol via an automatically choosen optimisation algorithm (rootfindingAlgorithm=nothing) or via any \nalgorithm in NonlinearSolve.jl (https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/), e.g. \nrootfindingAlgorithm=NonlinearSolve.TrustRegion(). (abstol, reltol, maxiters) defaults to (1e-8, 1e-8, 1e4).\n\nFor :Simulate the steady state u* is found by simulating the ODE-system until du = f(u, p, t) ≈ 0.\nTwo options are availble for howCheckSimulationReachedSteadyState;\n    - :wrms : Weighted root-mean square √(∑((du ./ (reltol * u .+ abstol)).^2) / length(u)) < 1\n    - :Newton : If Newton-step Δu is sufficiently small √(∑((Δu ./ (reltol * u .+ abstol)).^2) / length(u)) < 1. \nNewton often perform better but requires an invertible Jacobian. In case not fulfilled code switches automatically\nto wrms. (abstol, reltol) defaults to ODE solver tolerances divided by 100 and maxiters to ODE solver value.\n    \nmaxiters refers to either maximum number of rootfinding steps, or maximum number of integration steps.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getWord-Tuple{String, Int64, Vector{Char}}","page":"Home","title":"PEtab.getWord","text":"getWord(str::String, iStart::Int, charTerminate::Vector{Char})\n\nIn a string starting from position iStart extract the next \"word\", which is the longest\nconcurent occurance of characters that are not in the character list with word termination\ncharacters. Returns the word and iEnd (the position where the word ends).\n\nFor example, if charListTerm = ['(', ')', '+', '-', '/', '*', '^'] abc123 is\nconsidered a word but not abc123*.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.isNumber-Tuple{AbstractString}","page":"Home","title":"PEtab.isNumber","text":"isNumber(x::String)::Bool\n\nCheck if a string x is a number (Float) taking sciencetific notation into account.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.isNumber-Tuple{SubString{String}}","page":"Home","title":"PEtab.isNumber","text":"isNumber(x::SubString{String})::Bool\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.petabFormulaToJulia-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.petabFormulaToJulia","text":"petabFormulaToJulia(formula::String, stateNames, paramData::ParametersInfo, namesParamDyn::Vector{String}, namesNonDynParam::Vector{String})::String\n\nTranslate a peTab formula (e.g for observable or for sd-parameter) into Julia syntax and output the result\nas a string.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.processMeasurements-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PEtab.processMeasurements","text":"processMeasurements(measurementsFile::DataFrame, observableData::DataFrame)::MeasurementData\n\nProcess the PeTab measurementsFile file into a type-stable Julia struct.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.processParameters-Tuple{DataFrames.DataFrame}","page":"Home","title":"PEtab.processParameters","text":"processParameters(parametersFile::DataFrame)::ParameterInfo\n\nProcess the PeTab parametersFile file into a type-stable Julia struct.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.readPEtabModel-Tuple{String}","page":"Home","title":"PEtab.readPEtabModel","text":"readPEtabModel(pathYAML::String;\n               forceBuildJuliaFiles::Bool=false,\n               verbose::Bool=true,\n               ifElseToEvent::Bool=true)::PEtabModel\n\nParses a PEtab specified problem with yaml-file at `pathYAML` into a Julia accessible format. \n\nWhen parsing a PEtab problem several things happens under the hood;\n1) The SBML file is translated into ModelingToolkit.jl format (e.g allow symbolic computations of the ODE-model \n   Jacobian). Piecewise and model events are further written into DifferentialEquations.jl callbacks.\n2) The observable PEtab-table is translated into Julia-file with functions for computing the observable (h), \n   noise parameter (σ) and initial values (u0). \n3) To allow gradients via adjoint sensitivity analysis and/or forward sensitivity equations the gradients of \n   h and σ are computed symbolically with respect to the ODE-models states (u) and parameters (odeProblem.p).\nAll this happens automatically, and resulting files are stored under petabModel.dirJulia. To save time \n`forceBuildJlFiles=false` meaning that Julia files are not rebuilt in case the already exist.\n\nIn the future we plan to allow the user to also provide a Julia file instead of a SBML file.\n\nSee also: [`PEtabModel`]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.replaceExplicitVariableWithRule-Tuple{String, Dict}","page":"Home","title":"PEtab.replaceExplicitVariableWithRule","text":"replaceExplicitVariableWithRule(formula::String, SBMLDict::Dict)::String\n\nReplace the explicit rule variable with the explicit rule\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.replaceVariablesWithArrayIndex-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.replaceVariablesWithArrayIndex","text":"replaceVariablesWithArrayIndex(formula,stateNames,parameterNames,namesNonDynParam,paramData)::String\n\nReplaces any state or parameter from formula with their corresponding index in the ODE system\nSymbolics can return strings without multiplication sign, e.g. 100.0STAT5 instead of 100.0*STAT5\nso replaceWholeWord cannot be used here\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.replaceWholeWordWithNumberPrefix-Tuple{Any, Any, Any}","page":"Home","title":"PEtab.replaceWholeWordWithNumberPrefix","text":"replaceWholeWordWithNumberPrefix(formula, from, to)::String\n\nReplaces variables that can be prefixed with numbers, e.g.,\nreplaceWholeWordWithNumberPrefix(\"4STAT5 + 100.0STAT5 + RE*STAT5 + STAT5\",\"STAT5\",\"u[1]\") gives\n4u[1] + 100.0u[1] + RE*u[1] + u[1]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParametersInfo}","page":"Home","title":"PEtab.setParamToFileValues!","text":"setParamToFileValues!(paramMap, stateMap, paramData::ParamData)\n\nFunction that sets the parameter and state values in paramMap and stateMap\nto those in the PeTab parameters file.\n\nUsed when setting up the PeTab cost function, and when solving the ODE-system\nfor the values in the parameters-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.setupPEtabODEProblem-Tuple{PEtabModel, ODESolverOptions}","page":"Home","title":"PEtab.setupPEtabODEProblem","text":"setupPEtabODEProblem(petabModel::PEtabModel, \n                     odeSolverOptions::ODESolverOptions; \n                     <keyword arguments>)\n\nFor a PEtabModel and ODE-solver options (e.g. solver and tolerances) returns a PEtabODEProblem.\n\nThe PEtabODEproblem allows for efficient cost, gradient and hessian computations for a PEtab specified problem.  \nUsing the keyword arguments (see below) the user can select cost method, gradient method, hessian method, ODE \nsolver options, and a few tuneable options that potentially can make computations more efficient for a subset of \n\"edge-case\" models. A discussion about the most efficient option for different model types can be found in the \ndocumentation [add]. \n\n# Arguments\n- `petabModel::PEtabModel`: a PEtab-specified problem processed into Julia syntax by `readPEtabModel`\n- `odeSolverOptions::ODESolverOptions`: ODE-solver options when computing the cost (e.g solver and tolerances)\n- `odeSolverGradientOptions=nothing` : ODE-solver options when computing the gradient, e.g. the ODE solver options \n   used when doing adjoint sensitivity analysis. If nothing defaults to `odeSolverOptions`. \n- `ssSolverOptions=nothing` : Options used when solving for steady-state for models with pre-equlibrium. Steady-state\n   can be found either via simulation or rootfinding and can be set via `getSteadyStateSolverOptions` (see \n   documentation), if nothing defaults to simulation with wrms < 1 termination.\n   used when doing adjoint sensitivity analysis. If nothing defaults to `odeSolverOptions`. \n- `ssSolverGradientOptions=nothing` : Options used when solving for steady-state for models with pre-equlibrium when\n   doing gradient computations. If nothing defaults to `ssSolverOptions` value.\n- `costMethod::Symbol=:Standard` : method for computing the cost (objective). Two options are available, :Standard is \n   most efficient, while :Zygote is less efficient but compatible with the Zygote automatic differentiation library.\n- `gradientMethod::Symbol=:ForwardDiff` : method for computing the gradient of the (objective). Four availble options:\n    * :ForwardDiff - Compute the gradient via forward-mode automatic differentiation using ForwardDiff.jl. Most \n      efficient for models with ≤50 parameters. Optionally the number of chunks can be set by `chunkSize`.\n    * :ForwardEquations - Compute the gradient via the model sensitivities, where `sensealg` species how to solve \n      for the sensitivities. Most efficient if the hessian is approximated via the Gauss-Newton method, and if in the \n      optimizer we can reuse the sensitives (see `reuseS`) from the gradient computations in the hessian computations \n      (e.g when the optimizer always computes the gradient before the hessian). \n    * :Adjoint - Compute the gradient via adjoint sensitivity analysis, where `sensealg` specifies which algorithm \n      to use. Most efficient for large models (≥75 parameters). \n    * :Zygote - Compute the gradient via the Zygote package, where `sensealg` specifies which sensitivity algorithm \n      to use when solving the ODE-model. Most inefficient option and not recommended to use at all. \n- `hessianMethod::Symbol=:ForwardDiff` : method for computing the hessian of the cost. Three available options:\n    * :ForwardDiff - Compute the hessian via forward-mode automatic differentiation using ForwardDiff.jl. Often only \n      computationally feasible for models with ≤20 parameters, but often greatly improves optimizer convergence. \n    * :BlockForwardDiff - Compute hessian block approximation via forward-mode automatic differentiation using \n      ForwardDiff.jl. Approximation consists of two block matrices, the first is the hessian for only the dynamic \n      parameters (parameter part of the ODE system), and the second for the non-dynamic parameters (e.g noise \n      parameters). Computationally feasible for models with ≤ 20 dynamic parameters and often performs better than \n      BFGS-methods. \n    * :GaussNewton - Approximate the hessian via the Gauss-Newton method. Often performs better than the BFGS method.\n      If in the optimizer we can reuse the sensitives from the gradient (see `reuseS`) this method is best paired with \n      `gradientMethod=:ForwardEquations`. \n- `sparseJacobian::Bool=false` : when solving the ODE du/dt=f(u, p, t) whether or not for implicit solvers use a \n   sparse-jacobian. Sparse jacobian often performs best for large models (≥100 states). \n- `specializeLevel=SciMLBase.FullSpecialize` : specialization level when building the ODE-problem. Not recommended \n   to change (see https://docs.sciml.ai/SciMLBase/stable/interfaces/Problems/)\n- `sensealg=InterpolatingAdjoint()` : Sensitivity algorithm for gradient computations. Available options for each \n   gradient method are:\n    * :ForwardDiff : None (as ForwardDiff takes care of all computation steps)\n    * :ForwardEquations : :ForwardDiff (uses ForwardDiff.jl) or ForwardDiffSensitivity() and ForwardSensitivity() \n      from SciMLSensitivity.jl (https://github.com/SciML/SciMLSensitivity.jl). \n    * :Adjoint : InterpolatingAdjoint() and QuadratureAdjoint() from SciMLSensitivity.jl\n    * :Zygote : all sensealg in SciMLSensitivity.jl \n- `sensealgSS=InterpolatingAdjoint()` : Sensitivity algorithm for adjoint gradient compuations for steady state \n   simulations. Availble options are SteadyStateAdjoint() InterpolatingAdjoint() and QuadratureAdjoint() from \n   SciMLSensitivity.jl. SteadyStateAdjoint() is most efficient but requires a non-singular jacobian, and in case\n   of non-singular jacobian the code automatically switches to InterpolatingAdjoint(). \n- `chunkSize=nothing` : Chunk-size for ForwardDiff.jl when computing the gradient and hessian via forward mode \n   automatic different. If nothing default value is used. Tuning chunkSize is non-trivial and we plan to add \n   automatic functionality for this.\n- `splitOverConditions::Bool=false` : For gradient and hessian via ForwardDiff.jl whether or not to split calls to \n  to ForwardDiff across experimental (simulation) conditions. Should only be set to true in case the model has many \n  parameters tgat are specific to an experimental condition, else the overhead from the calls will increase run time. \n  See the Beer-example for an example where this is needed.\n- `reuseS::Bool=false` : Reuse the sensitives from the gradient computations for the Gauss-Newton hessian approximation.\n  Only applicable when `hessianMethod=:GaussNewton` and `gradientMethod=:ForwardEquations` and should **only** be used \n  when the optimizer **always** computes the gradient before the hessian.\n- `verbose::Bool=true` : Print progress when setting up PEtab ODEProblem\n\nSee also [`PEtabODEProblem`](@ref), [`PEtabModel`](@ref), [`getODESolverOptions`](@ref).\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.transformMeasurementOrH-Tuple{Real, Symbol}","page":"Home","title":"PEtab.transformMeasurementOrH","text":"transformMeasurementOrH(val::Real, transformationArr::Array{Symbol, 1})\n\nTransform val using either :lin (identify), :log10 and :log transforamtions.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.wordToJuliaSyntax-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.wordToJuliaSyntax","text":"\"     wordToJuliaSyntax(wordTranslate::String,                       stateNames,                       paramData::ParametersInfo,                       namesParamDyn::Vector{String})::String\n\nTranslate a word (state, parameter, math-expression or number) into Julia syntax\nwhen building Ymod, U0 and Sd functions.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.writeODEModelToFile-NTuple{4, Any}","page":"Home","title":"PEtab.writeODEModelToFile","text":"writeODEModelToFile(modelDict, modelName, dirModel)\nTakes a modelDict as defined by buildODEModelDictionary\nand creates a Julia ModelingToolkit file and stores \nthe resulting file in dirModel with name modelName.jl.\n\n\n\n\n\n","category":"method"}]
}
