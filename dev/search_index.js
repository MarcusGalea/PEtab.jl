var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PEtab","category":"page"},{"location":"#PEtab","page":"Home","title":"PEtab","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PEtab.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PEtab]","category":"page"},{"location":"#PEtab.MeasurementsInfo","page":"Home","title":"PEtab.MeasurementsInfo","text":"MeasurementData\n\nStruct storing the data in the PeTab measurementData-file in type-stable manner.\n\nSee also: [`processMeasurementData`]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.PEtabModel","page":"Home","title":"PEtab.PEtabModel","text":"PEtabModel\n\nStruct storing information about a PeTab-model. Create by the `setUpCostFunc` function.\n\n# Args\n`modelName`: PeTab model name (must match the xml-file name)\n`evalYmod`: Function to evaluate yMod for the log-likelhood.\n`evalU0!`: Function that computes the initial u0 value for the ODE-system.\n`evalSd!`: Function that computes the standard deviation value for the log-likelhood.\n`odeSystem`: ModellingToolkit ODE-system for the PeTab model.\n`paramMap`: A map to correctly map model parameters to the ODE-system.\n`stateMap`: A map to correctly mapping the parameters to the u0 values.\n`paramNames`: Names of the model parameters (both fixed and those to be estimated).\n`stateNames`: Names of the model states.\n`dirModel`: Directory where the model.xml and PeTab files are stored.\n`pathMeasurementData`: Path to the measurementData PeTab file.\n`pathMeasurementData`: Path to the experimentaCondition PeTab file\n`pathMeasurementData`: Path to the observables PeTab file\n`pathMeasurementData`: Path to the parameters PeTab file\n\nSee also: [`setUpCostFunc`]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.ParameterIndices","page":"Home","title":"PEtab.ParameterIndices","text":"ParameterIndices\n\nStruct storing names and mapping indices for mapping the parameter provided\nto the optimizers correctly.\n\nOptimizers require a single vector input of parameters (pVecEst). However, the PeTab\nmodel has three kind of parameters, Dynmaic (part of the ODE-system),\nObservable (only part of the observation model) and Standard-deviation\n(only part of the standard deviation expression in the log-likelhood). This\nstruct stores mapping indices (starting with i) to map pVecEst\ncorrectly when computing the likelihood (e.g map the SD-parameters in pVecEst\ncorrectly to a vector of SD-vals). Also stores the name of each parameter.\n\nFurthermore, when computing yMod or SD the correct observable and sd parameters\nhas to be used for each observation. The mapArrays effectively contains precomputed\nmaps allowing said parameter to be effectively be extracted by the getObsOrSdParam\nfunction.\n\nSee also: [`getIndicesParam`, `ParamMap`]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.ParametersInfo","page":"Home","title":"PEtab.ParametersInfo","text":"ParameterInfo\n\nStruct storing the data in the PeTab parameter-file in type-stable manner.\n\nCurrently logScale notices whether or not parameters are estimated on the\nlog10 scale or not.\n\nSee also: [`processParameterData`]\n\n\n\n\n\n","category":"type"},{"location":"#PEtab.JLToModellingToolkit-Tuple{String, String}","page":"Home","title":"PEtab.JLToModellingToolkit","text":"JLToModellingToolkit(modelName::String, dirModel::String)\nChecks and fixes a Julia ModelingToolkit file and store \nthe fixed file in dirModel with name modelName_fix.jl.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.XmlToModellingToolkit-Tuple{String, AbstractString, AbstractString}","page":"Home","title":"PEtab.XmlToModellingToolkit","text":"XmlToModellingToolkit(pathXml::String, modelName::String, dirModel::String)\nConvert a SBML file in pathXml to a Julia ModelingToolkit file and store \nthe resulting file in dirModel with name modelName.jl. \nThe SBML importer goes via libsbml in Python and currently likelly only \nworks with SBML level 3.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.checkDataFrameColumns-NTuple{5, Any}","page":"Home","title":"PEtab.checkDataFrameColumns","text":"checkDataFrameColumns(dataFrame, dataFrameName, colsToCheck, allowedTypesVec, requiredCols)         Goes through each column from colsToCheck in dataFrame and checks         if each column is of any of the DataTypes specified in allowedTypesVec[colIndex].         Returns true if all columns are ok and false otherwise.         requiredCols is an array of mandatory columns. If a mandatory column is missing         an error is thrown, and if a mandatory column contains missing rows a warning is         thrown.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.checkForPeTabFile-Tuple{String, String}","page":"Home","title":"PEtab.checkForPeTabFile","text":"checkForPeTabFile(fileSearchFor::String, dirModel::String)::String\n\nHelper function to check in dirModel if a file starting with fileSearchFor exists. If true return file path.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createDerivative_σ_h_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Dict}","page":"Home","title":"PEtab.createDerivative_σ_h_File","text":"createFileDYmodSdU0(modelName::String, \n                   dirModel::String, \n                   odeSys::ODESystem, \n                   stateMap,\n                   SBMLDict::Dict)\n\nFor a PeTab model with name modelName with all PeTab-files in dirModel and associated \nModellingToolkit ODESystem (with its stateMap) build a file containing a functions for \ni) computing the observable model value (yMod) ii) compute the initial value u0 (by using the \nstateMap) and iii) computing the standard error (sd) for each observableFormula in the \nobservables PeTab file.\nNote - The produced Julia file will go via the JIT-compiler.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createTopOfFunction_h-Tuple{Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.createTopOfFunction_h","text":"createTopOfFunction_h(modelStateNames::Vector{String},\n                      paramData::ParametersInfo,\n                      namesParamODEProb::Vector{String},\n                      namesNonDynParam::Vector{String})\n\nExtracts all variables needed for the observable h function.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.createTopOf∂h∂_Function-Tuple{Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame}","page":"Home","title":"PEtab.createTopOf∂h∂_Function","text":"createTopOf∂h∂_Function(modelStateNames::Vector{String}, \n                        pODEProblemNames::Vector{String}, \n                        θ_nonDynamicNames::Vector{String},\n                        observablesData::DataFrame)\n\nExtracts all variables needed for the functions and add them as variables for Symbolics.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_h_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create_h_Function","text":"create_h_Function(modelName::String,\n                  dirModel::String,\n                  modelStateNames::Vector{String},\n                  paramData::ParametersInfo,\n                  namesParamDyn::Vector{String},\n                  namesNonDynParam::Vector{String},\n                  observablesData::DataFrame,\n                  SBMLDict::Dict)\n\nFor modelName create a function for computing yMod by translating the observablesData\nPeTab-file into Julia syntax.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_u0_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Any}","page":"Home","title":"PEtab.create_u0_Function","text":"create_u0_Function(modelName::String,\n                   dirModel::String,\n                   parameterInfo::ParametersInfo,\n                   pODEProblemNames::Vector{String},\n                   stateMap;\n                   inPlace::Bool=true)\n\nFor modelName create a function for computing initial value by translating the stateMap\ninto Julia syntax.\n\nTo correctly create the function the name of all parameters, paramData (to get constant parameters)\nare required.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_σ_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create_σ_Function","text":"create_σ_Function(modelName::String,\n                  dirModel::String,\n                  parameterInfo::ParametersInfo,\n                  modelStateNames::Vector{String},\n                  pODEProblemNames::Vector{String},\n                  θ_nonDynamicNames::Vector{String},\n                  observablesData::DataFrame,\n                  SBMLDict::Dict)\n\nFor modelName create a function for computing the standard deviation σ by translating the observablesData\nPeTab-file into Julia syntax.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create_σ_h_u0_File-Tuple{String, String, String, ModelingToolkit.ODESystem, Any, Dict}","page":"Home","title":"PEtab.create_σ_h_u0_File","text":"create_σ_h_u0_File(modelName::String,\n                   dirModel::String,\n                   odeSystem::ODESystem,\n                   stateMap,\n                   SBMLDict::Dict;\n                   verbose::Bool=false)\n\nFor a PeTab model with name modelName with all PeTab-files in dirModel and associated\nModellingToolkit ODESystem (with its stateMap) build a file containing a functions for\ni) computing the observable model value (h) ii) compute the initial value u0 (by using the\nstateMap) and iii) computing the standard error (σ) for each observableFormula in the\nobservables PeTab file.\n\nNote - The produced Julia file will go via the JIT-compiler. The SBML-dict is needed as\nsometimes variables are encoded via explicit-SBML rules.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create∂h∂_Function-Tuple{String, String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create∂h∂_Function","text":"create∂h∂_Function(modelName::String, \n                   dirModel::String, \n                   modelStateNames::Vector{String}, \n                   parameterInfo::ParametersInfo, \n                   pODEProblemNames::Vector{String}, \n                   θ_nonDynamicNames::Vector{String},\n                   observablesData::DataFrame,\n                   SBMLDict::Dict)\n\nFor modelName create using Symbolics function for computing ∂h/∂u and ∂h/∂p where \nu = modelStates and p = pODEProblem (parameters for ODE problem)\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.create∂σ∂_Function-Tuple{String, String, PEtab.ParametersInfo, Vector{String}, Vector{String}, Vector{String}, DataFrames.DataFrame, Dict}","page":"Home","title":"PEtab.create∂σ∂_Function","text":"create∂σ∂_Function(modelName::String, \n                        dirModel::String, \n                        parameterInfo::ParametersInfo, \n                        modelStateNames::Vector{String}, \n                        pODEProblemNames::Vector{String}, \n                        θ_nonDynamicNames::Vector{String},\n                        observablesData::DataFrame,\n                        SBMLDict::Dict)\n\nFor modelName create a function for computing the standard deviation by translating the observablesData\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.dualToFloat-Tuple{AbstractFloat}","page":"Home","title":"PEtab.dualToFloat","text":"dualToFloat(x::AbstractFloat)::AbstractFloat\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.dualToFloat-Tuple{ForwardDiff.Dual}","page":"Home","title":"PEtab.dualToFloat","text":"dualToFloat(x::ForwardDiff.Dual)::Real\n\nVia recursion convert a Dual to a Float.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getNoiseParametersStr-Tuple{String}","page":"Home","title":"PEtab.getNoiseParametersStr","text":"getNoiseParametersStr(formula::String)::String\n\nHelper function to extract all the noiseParameter in noiseParameter formula in the PEtab file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getObservableParametersStr-Tuple{String}","page":"Home","title":"PEtab.getObservableParametersStr","text":"getObservableParametersStr(formula::String)::String\n\nHelper function to extract all observableParameter in the observableFormula in the PEtab-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.getWord-Tuple{String, Int64, Vector{Char}}","page":"Home","title":"PEtab.getWord","text":"getWord(str::String, iStart::Int, charTerminate::Vector{Char})\n\nIn a string starting from position iStart extract the next \"word\", which is the longest\nconcurent occurance of characters that are not in the character list with word termination\ncharacters. Returns the word and iEnd (the position where the word ends).\n\nFor example, if charListTerm = ['(', ')', '+', '-', '/', '*', '^'] abc123 is\nconsidered a word but not abc123*.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.isNumber-Tuple{AbstractString}","page":"Home","title":"PEtab.isNumber","text":"isNumber(x::String)::Bool\n\nCheck if a string x is a number (Float) taking sciencetific notation into account.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.isNumber-Tuple{SubString{String}}","page":"Home","title":"PEtab.isNumber","text":"isNumber(x::SubString{String})::Bool\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.petabFormulaToJulia-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.petabFormulaToJulia","text":"petabFormulaToJulia(formula::String, stateNames, paramData::ParametersInfo, namesParamDyn::Vector{String}, namesNonDynParam::Vector{String})::String\n\nTranslate a peTab formula (e.g for observable or for sd-parameter) into Julia syntax and output the result\nas a string.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.processMeasurements-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PEtab.processMeasurements","text":"processMeasurements(measurementsFile::DataFrame, observableData::DataFrame)::MeasurementData\n\nProcess the PeTab measurementsFile file into a type-stable Julia struct.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.processParameters-Tuple{DataFrames.DataFrame}","page":"Home","title":"PEtab.processParameters","text":"processParameters(parametersFile::DataFrame)::ParameterInfo\n\nProcess the PeTab parametersFile file into a type-stable Julia struct.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.readPEtabModel-Tuple{String}","page":"Home","title":"PEtab.readPEtabModel","text":"setUpPeTabModel(modelName::String, dirModel::String)::PEtabModel\nGiven a model directory (dirModel) containing the PeTab files and a\nxml-file on format modelName.xml will return a PEtabModel struct holding\npaths to PeTab files, ode-system in ModellingToolkit format, functions for\nevaluating yMod, u0 and standard deviations, and a parameter and state maps\nfor how parameters and states are mapped in the ModellingToolkit ODE system\nalong with state and parameter names.\ndirModel must contain a SBML file named modelName.xml, and files starting with\nmeasurementData, experimentalCondition, parameter, and observables (tsv-files).\nThe latter files must be unique (e.g only one file starting with measurementData)\nTODO : Example\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.replaceExplicitVariableWithRule-Tuple{String, Dict}","page":"Home","title":"PEtab.replaceExplicitVariableWithRule","text":"replaceExplicitVariableWithRule(formula::String, SBMLDict::Dict)::String\n\nReplace the explicit rule variable with the explicit rule\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.replaceVariablesWithArrayIndex-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.replaceVariablesWithArrayIndex","text":"replaceVariablesWithArrayIndex(formula,stateNames,parameterNames,namesNonDynParam,paramData)::String\n\nReplaces any state or parameter from formula with their corresponding index in the ODE system\nSymbolics can return strings without multiplication sign, e.g. 100.0STAT5 instead of 100.0*STAT5\nso replaceWholeWord cannot be used here\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.replaceWholeWordWithNumberPrefix-Tuple{Any, Any, Any}","page":"Home","title":"PEtab.replaceWholeWordWithNumberPrefix","text":"replaceWholeWordWithNumberPrefix(formula, from, to)::String\n\nReplaces variables that can be prefixed with numbers, e.g.,\nreplaceWholeWordWithNumberPrefix(\"4STAT5 + 100.0STAT5 + RE*STAT5 + STAT5\",\"STAT5\",\"u[1]\") gives\n4u[1] + 100.0u[1] + RE*u[1] + u[1]\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.setParamToFileValues!-Tuple{Any, Any, PEtab.ParametersInfo}","page":"Home","title":"PEtab.setParamToFileValues!","text":"setParamToFileValues!(paramMap, stateMap, paramData::ParamData)\n\nFunction that sets the parameter and state values in paramMap and stateMap\nto those in the PeTab parameters file.\n\nUsed when setting up the PeTab cost function, and when solving the ODE-system\nfor the values in the parameters-file.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.transformMeasurementOrH-Tuple{Real, Symbol}","page":"Home","title":"PEtab.transformMeasurementOrH","text":"transformMeasurementOrH(val::Real, transformationArr::Array{Symbol, 1})\n\nTransform val using either :lin (identify), :log10 and :log transforamtions.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.wordToJuliaSyntax-Tuple{String, Vector{String}, PEtab.ParametersInfo, Vector{String}, Vector{String}}","page":"Home","title":"PEtab.wordToJuliaSyntax","text":"\"     wordToJuliaSyntax(wordTranslate::String,                       stateNames,                       paramData::ParametersInfo,                       namesParamDyn::Vector{String})::String\n\nTranslate a word (state, parameter, math-expression or number) into Julia syntax\nwhen building Ymod, U0 and Sd functions.\n\n\n\n\n\n","category":"method"},{"location":"#PEtab.writeODEModelToFile-NTuple{4, Any}","page":"Home","title":"PEtab.writeODEModelToFile","text":"writeODEModelToFile(modelDict, modelName, dirModel)\nTakes a modelDict as defined by buildODEModelDictionary\nand creates a Julia ModelingToolkit file and stores \nthe resulting file in dirModel with name modelName.jl.\n\n\n\n\n\n","category":"method"}]
}
