<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Choosing the best options for a PEtab problem · PEtab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/Best_options/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li><li><a class="tocitem" href="../Beer_julia_import/">Providing the model as a Julia file instead of an SBML File</a></li><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li class="is-active"><a class="tocitem" href>Choosing the best options for a PEtab problem</a><ul class="internal"><li><a class="tocitem" href="#Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)"><span>Small models (<span>$\leq 20$</span> parameters and <span>$\leq 15$</span> ODE:s)</span></a></li><li><a class="tocitem" href="#Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)"><span>Medium-sized models (<span>$\leq 75$</span> parameters and <span>$\leq 50$</span> ODE:s)</span></a></li><li><a class="tocitem" href="#Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)"><span>Large models (<span>$\geq 75$</span> parameters and <span>$\geq 50$</span> ODE:s)</span></a></li></ul></li><li><a class="tocitem" href="../API_choosen/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Choosing the best options for a PEtab problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Choosing the best options for a PEtab problem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/Best_options.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="best_options"><a class="docs-heading-anchor" href="#best_options">Choosing the best options for a PEtab problem</a><a id="best_options-1"></a><a class="docs-heading-anchor-permalink" href="#best_options" title="Permalink"></a></h1><p>PEtab.jl provides several gradient and hessian methods that can be used with the ODE solvers in the DifferentialEquations.jl package. You can choose from a variety of options when creating a <code>PEtabODEProblem</code> using the <code>createPEtabODEProblem</code> function. If you don&#39;t specify any of these options, appropriate options will be selected automatically based on an extensive benchmark study. These default options usually work well for specific problem types. In the following section, we will discuss the main findings of the benchmark study.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These recommendations often work well for specific problem types, they may not be optimal for every model, as each problem is unique.</p></div></div><h2 id="Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)"><a class="docs-heading-anchor" href="#Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)">Small models (<span>$\leq 20$</span> parameters and <span>$\leq 15$</span> ODE:s)</a><a id="Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)-1"></a><a class="docs-heading-anchor-permalink" href="#Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)" title="Permalink"></a></h2><p><strong>ODE solver</strong>: For small stiff models, the Rosenbrock <code>Rodas5P()</code> solver is often the fastest and most accurate option. While Julia bdf-solvers such as <code>QNDF()</code> can also perform well, they are often less reliable and less accurate than <code>Rodas5P()</code>. If the model is &quot;mildly&quot; stiff, composite solvers such as <code>AutoVern7(Rodas5P())</code> often perform best. Regardless of solver, we recommend using low tolerances (around <code>abstol, reltol = 1e-8, 1e-8</code>) to obtain accurate gradients.</p><p><strong>Gradient method</strong>: For small models, forward-mode automatic differentiation via <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> tends to be the best performing option, and is often twice as fast as the forward-sensitivity equations approach in AMICI. Therefore, we recommend using <code>gradientMethod=:ForwardDiff</code>.</p><ul><li><strong>Note1</strong> - For <code>:ForwardDiff</code>, the user can set the <a href="https://juliadiff.org/ForwardDiff.jl/stable/">chunk-size</a>, which can substantially improve performance. We plan to add automatic tuning of this in the future.</li><li><strong>Note2</strong> - If the model has many simulation condition-specific parameters (parameters that only appear in a subset of simulation conditions), it can be efficient to set <code>splitOverConditions=true</code> (see <a href="../Beer/#Beer_tut">this</a> tutorial).</li></ul><p><strong>Hessian method</strong>: For small models, it is computationally feasible to compute an accurate full Hessian via <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. For most models we benchmarked, using a provided Hessian improved convergence. Therefore, we recommend using <code>hessianMethod=:ForwardDiff</code>.</p><ul><li><strong>Note1</strong> - For models with pre-equilibration (steady-state simulations), our benchmarks suggest that it might be better to use the Gauss-Newton Hessian approximation.</li><li><strong>Note2</strong> - For models where it is too expensive to compute the full Hessian (e.g. due to many simulation conditions), the Hessian <a href="../Gradient_hessian_support/#gradient_support">block approximation</a> can be a good option.</li><li><strong>Note3</strong> - In particular, the interior-point Newton method from <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> performs well if provided with a full Hessian.</li></ul><p>Overall, for a small model, a good setup often includes:</p><pre><code class="language-julia hljs">petabProblem = createPEtabODEProblem(petabModel, 
                                     odeSolverOptions=ODESolverOptions(Rodas5P(), abstol=1e-8, reltol=1e-8), 
                                     gradientMethod=:ForwardDiff, 
                                     hessianMethod=:ForwardDiff)</code></pre><h2 id="Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)"><a class="docs-heading-anchor" href="#Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)">Medium-sized models (<span>$\leq 75$</span> parameters and <span>$\leq 50$</span> ODE:s)</a><a id="Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)-1"></a><a class="docs-heading-anchor-permalink" href="#Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)" title="Permalink"></a></h2><p><strong>ODE solver</strong>: For medium-sized stiff models, bdf-solvers like <code>QNDF()</code> are often fast enough and accurate. However, they can fail for certain models with many events when low tolerances are used. In such cases, <code>KenCarp4()</code> is a good alternative. Another option is Sundials&#39; <code>CVODE_BDF()</code>, but it&#39;s written in C++ and not compatible with forward-mode automatic differentiation. To obtain accurate gradients, we recommend using low tolerances (around <code>abstol, reltol = 1e-8, 1e-8</code>) regardless of solver.</p><p><strong>Gradient method</strong>: For medium-sized models, when using the Gauss-Newton method to approximate the Hessian, we recommend computing the gradient via the forward sensitivities (<code>gradientMethod=:ForwardEquations</code>), where the sensitivities are computed via forward-mode automatic differentiation (<code>sensealg=:ForwardDiff</code>). This way, the sensitivities can be reused when computing the Hessian if the optimizer always computes the gradient first. Otherwise, if a BFGS Hessian-approximation is used, <code>gradientMethod=:ForwardDiff</code> often performs best.</p><ul><li><strong>Note1</strong> - For <code>:ForwardDiff</code>, the user can set the <a href="https://juliadiff.org/ForwardDiff.jl/stable/">chunk-size</a> to improve performance, and we plan to add automatic tuning of it.</li><li><strong>Note2</strong> - If the model has many simulation condition-specific parameters (parameters that only appear in a subset of simulation conditions), it can be efficient to set <code>splitOverConditions=true</code> (see <a href="../Beer/#Beer_tut">this</a> tutorial).</li></ul><p><strong>Hessian method</strong>: For medium-sized models, it&#39;s often computationally infeasible to compute an accurate full Hessian via <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. Instead, we recommend the Gauss-Newton Hessian approximation, which often performs better than the commonly used (L)-BFGS approximation. Thus, we recommend <code>hessianMethod=:GaussNewton</code>.</p><ul><li><strong>Note1</strong> - Trust-region Newton methods like <a href="https://github.com/fides-dev/fides">Fides.py</a> perform well if provided with a full Hessian. Interior-point methods don&#39;t perform as well.</li></ul><p>Overall, when the gradient is always computed before the Hessian in the optimizer, a good setup is often:</p><pre><code class="language-julia hljs">petabProblem = createPEtabODEProblem(petabModel, 
                                     odeSolverOptions=ODESolverOptions(QNDF(), abstol=1e-8, reltol=1e-8),
                                     gradientMethod=:ForwardEquations, 
                                     hessianMethod=:GaussNewton, 
                                     reuseS=true)</code></pre><p>Otherwise, a good setup is:</p><pre><code class="language-julia hljs">petabProblem = createPEtabODEProblem(petabModel, 
                                     odeSolverOptions=ODESolverOptions(QNDF(), abstol=1e-8, reltol=1e-8),
                                     gradientMethod=:ForwardDiff, 
                                     hessianMethod=:GaussNewton)</code></pre><h2 id="Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)"><a class="docs-heading-anchor" href="#Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)">Large models (<span>$\geq 75$</span> parameters and <span>$\geq 50$</span> ODE:s)</a><a id="Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)-1"></a><a class="docs-heading-anchor-permalink" href="#Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)" title="Permalink"></a></h2><p><strong>ODE solver</strong>: To efficiently solve large models, we recommend benchmarking different ODE solvers such as <code>QNDF()</code>, <code>FBDF()</code>, <code>KenCarp4()</code>, and <code>CVODE_BDF()</code>. You can also try providing the ODE solver with a sparse Jacobian (<code>sparseJacobian::Bool=false</code>) and testing different linear solvers such as <code>CVODE_BDF(linsolve=:KLU)</code>. Check out <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/advanced_ode_example/">this link</a> for more information on solving large stiff models.</p><ul><li><strong>Note</strong> - It&#39;s important to compare different ODE solvers, as this can significantly reduce runtime.</li></ul><p><strong>Gradient method</strong>: For large models, the most scalable approach is adjoint sensitivity analysis (<code>gradientMethod=:Adjoint</code>). We support <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> from SciMLSensitivity (see their <a href="https://github.com/SciML/SciMLSensitivity.jl">documentation</a> for info), but we recommend <code>InterpolatingAdjoint()</code> because it&#39;s more reliable.</p><ul><li><strong>Note1</strong> - When using adjoint sensitivity analysis, we recommend manually setting the ODE solver gradient options. Currently, <code>CVODE_BDF()</code> outperforms all native Julia solvers.</li><li><strong>Note2</strong> - You can provide any options that <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> accept.</li><li><strong>Note3</strong> - Adjoint sensitivity analysis is not as reliable in Julia as in AMICI (<a href="https://github.com/SciML/SciMLSensitivity.jl/issues/795">see</a>), but our benchmarks show that SciMLSensitivity has the potential to be faster.</li></ul><p><strong>Hessian method</strong>: For large models, computing the sensitives (Gauss-Newton) or a full hessian is not computationally feasible. Thus, the best option is often to use an L-(BFGS) approximation. BFGS support is built into most available optimizers such as <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>, <a href="https://github.com/jump-dev/Ipopt.jl">Ipopt.jl</a>, and <a href="https://github.com/fides-dev/fides">Fides.py</a>.</p><p>All in all, for a large model, a good setup often is:</p><pre><code class="language-julia hljs">petabProblem = createPEtabODEProblem(petabModel, 
                                     odeSolverOptions=ODESolverOptions(CVODE_BDF(), abstol=1e-8, reltol=1e-8), 
                                     odeSolverGradientOptions=ODESolverOptions(CVODE_BDF(), abstol=1e-8, reltol=1e-8),
                                     gradientMethod=:Adjoint, 
                                     sensealg=InterpolatingAdjoint()) </code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Gradient_hessian_support/">« Supported gradient and hessian methods</a><a class="docs-footer-nextpage" href="../API_choosen/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 31 August 2023 09:36">Thursday 31 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
