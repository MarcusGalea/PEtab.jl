<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Choosing the best options for a PEtab problem · PEtab.jl</title><meta name="title" content="Choosing the best options for a PEtab problem · PEtab.jl"/><meta property="og:title" content="Choosing the best options for a PEtab problem · PEtab.jl"/><meta property="twitter:title" content="Choosing the best options for a PEtab problem · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><meta property="og:url" content="https://sebapersson.github.io/PEtab.jl/Best_options/"/><meta property="twitter:url" content="https://sebapersson.github.io/PEtab.jl/Best_options/"/><link rel="canonical" href="https://sebapersson.github.io/PEtab.jl/Best_options/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Boehm/">Importing a PEtab problem</a></li><li><span class="tocitem">Defining a PEtab problem in Julia</span><ul><li><a class="tocitem" href="../Define_in_julia/">Getting started</a></li><li><a class="tocitem" href="../Julia_steady_state/">Pre-equilibration (steady-state simulations)</a></li><li><a class="tocitem" href="../Julia_obs_noise/">Noise and observable parameters</a></li><li><a class="tocitem" href="../Julia_condition_specific/">Condition specific system/model parameters</a></li><li><a class="tocitem" href="../Julia_event/">Events (callbacks, dosages etc...)</a></li></ul></li><li><span class="tocitem">Selecting options for a PEtab-problem</span><ul><li><a class="tocitem" href="../Brannmark/">Models with pre-equilibration (steady-state simulation)</a></li><li><a class="tocitem" href="../Bachmann/">Medium sized models and adjoint sensitivity analysis</a></li><li><a class="tocitem" href="../Beer/">Models with many conditions specific parameters</a></li></ul></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../Parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../Avaible_optimisers/">Available optimisers</a></li><li><a class="tocitem" href="../Model_selection/">Model selection (PEtab select)</a></li><li><a class="tocitem" href="../optimisation_output_plotting/">Plots evaluating parameter estimation</a></li></ul></li><li><a class="tocitem" href="../Gradient_hessian_support/">Supported gradient and hessian methods</a></li><li class="is-active"><a class="tocitem" href>Choosing the best options for a PEtab problem</a><ul class="internal"><li><a class="tocitem" href="#Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)"><span>Small models (<span>$\leq 20$</span> parameters and <span>$\leq 15$</span> ODE:s)</span></a></li><li><a class="tocitem" href="#Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)"><span>Medium-sized models (<span>$\leq 75$</span> parameters and <span>$\leq 50$</span> ODE:s)</span></a></li><li><a class="tocitem" href="#Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)"><span>Large models (<span>$\geq 75$</span> parameters and <span>$\geq 50$</span> ODE:s)</span></a></li></ul></li><li><a class="tocitem" href="../API_choosen/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Choosing the best options for a PEtab problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Choosing the best options for a PEtab problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/Best_options.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="best_options"><a class="docs-heading-anchor" href="#best_options">Choosing the best options for a PEtab problem</a><a id="best_options-1"></a><a class="docs-heading-anchor-permalink" href="#best_options" title="Permalink"></a></h1><p>PEtab.jl provides several gradient and hessian methods that can be used with the ODE solvers in the DifferentialEquations.jl package. You can choose from a variety of options when creating a <code>PEtabODEProblem</code>. If you do not specify any of these options, appropriate options will be selected automatically based on an extensive benchmark study. These default options usually work well for specific problem types. In the following section, we will discuss the main findings of the benchmark study.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These recommendations often work well for specific problem types, they may not be optimal for every model, as each problem is unique.</p></div></div><h2 id="Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)"><a class="docs-heading-anchor" href="#Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)">Small models (<span>$\leq 20$</span> parameters and <span>$\leq 15$</span> ODE:s)</a><a id="Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)-1"></a><a class="docs-heading-anchor-permalink" href="#Small-models-(\\leq-20-parameters-and-\\leq-15-ODE:s)" title="Permalink"></a></h2><p><strong>ODE solver</strong>: For small stiff models, the Rosenbrock <code>Rodas5P()</code> solver is often the fastest and most accurate option. While Julia bdf-solvers such as <code>QNDF()</code> can also perform well, they are often less reliable and less accurate than <code>Rodas5P()</code>. If the model is &quot;mildly&quot; stiff, composite solvers such as <code>AutoVern7(Rodas5P())</code> often perform best. Regardless of solver, we recommend using low tolerances (around <code>abstol, reltol = 1e-8, 1e-8</code>) to obtain accurate gradients.</p><p><strong>Gradient method</strong>: For small models, forward-mode automatic differentiation via <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> tends to be the best performing option, and is often twice as fast as the forward-sensitivity equations approach in AMICI. Therefore, we recommend using <code>gradient_method=:ForwardDiff</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For <code>:ForwardDiff</code>, the user can set the <a href="https://juliadiff.org/ForwardDiff.jl/stable/">chunk-size</a>, which can substantially improve performance. We plan to add automatic tuning of this in the future.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the model has many simulation condition-specific parameters (parameters that only appear in a subset of simulation conditions), it can be efficient to set <code>split_over_conditions=true</code> (see <a href="../Beer/#Beer_tut">this</a> tutorial).</p></div></div><p><strong>Hessian method</strong>: For small models, it is computationally feasible to compute an accurate full Hessian via <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. For most models we benchmarked, using a provided Hessian improved convergence. Therefore, we recommend using <code>hessian_method=:ForwardDiff</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For models with pre-equilibration (steady-state simulations), our benchmarks suggest that it might be better to use the Gauss-Newton Hessian approximation.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For models where it is too expensive to compute the full Hessian (e.g. due to many simulation conditions), the Hessian <a href="../Gradient_hessian_support/#gradient_support">block approximation</a> can be a good option.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In particular, the interior-point Newton method from <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> performs well if provided with a full Hessian.</p></div></div><p>Overall, for a small model, a good setup often is:</p><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model,
                                ode_solver=ODESolver(Rodas5P(), abstol=1e-8, reltol=1e-8),
                                gradient_method=:ForwardDiff,
                                hessian_method=:ForwardDiff)</code></pre><h2 id="Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)"><a class="docs-heading-anchor" href="#Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)">Medium-sized models (<span>$\leq 75$</span> parameters and <span>$\leq 50$</span> ODE:s)</a><a id="Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)-1"></a><a class="docs-heading-anchor-permalink" href="#Medium-sized-models-(\\leq-75-parameters-and-\\leq-50-ODE:s)" title="Permalink"></a></h2><p><strong>ODE solver</strong>: For medium-sized stiff models, bdf-solvers like <code>QNDF()</code> are often fast enough and accurate. However, they can fail for certain models with many events when low tolerances are used. In such cases, <code>KenCarp4()</code> is a good alternative. Another option is Sundials&#39; <code>CVODE_BDF()</code>, but it is written in C++ and not compatible with forward-mode automatic differentiation. To obtain accurate gradients, we recommend using low tolerances (around <code>abstol, reltol = 1e-8, 1e-8</code>) regardless of solver.</p><p><strong>Gradient method</strong>: For medium-sized models, when using the Gauss-Newton method to approximate the Hessian, we recommend computing the gradient via the forward sensitivities (<code>gradient_method=:ForwardEquations</code>), where the sensitivities are computed via forward-mode automatic differentiation (<code>sensealg=:ForwardDiff</code>). This way, the sensitivities can be reused when computing the Hessian if the optimizer always computes the gradient first. Otherwise, if a BFGS Hessian-approximation is used, <code>gradient_method=:ForwardDiff</code> often performs best.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For <code>:ForwardDiff</code>, the user can set the <a href="https://juliadiff.org/ForwardDiff.jl/stable/">chunk-size</a> to improve performance, and we plan to add automatic tuning of it.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the model has many simulation condition-specific parameters (parameters that only appear in a subset of simulation conditions), it can be efficient to set <code>split_over_conditions=true</code> (see <a href="../Beer/#Beer_tut">this</a> tutorial).</p></div></div><p><strong>Hessian method</strong>: For medium-sized models, it is often computationally infeasible to compute an accurate full Hessian via <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. Instead, we recommend the Gauss-Newton Hessian approximation, which often performs better than the commonly used (L)-BFGS approximation. Thus, we recommend <code>hessian_method=:GaussNewton</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Trust-region Newton methods like <a href="https://github.com/fides-dev/fides">Fides.py</a> perform well if provided with a full Hessian. Interior-point methods don&#39;t perform as well.</p></div></div><p>Overall, when the gradient is always computed before the Hessian in the optimizer, a good setup is often:</p><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model,
                                ode_solver=ODESolver(QNDF(), abstol=1e-8, reltol=1e-8),
                                gradient_method=:ForwardEquations,
                                hessian_method=:GaussNewton,
                                reuse_sensitivities=true)</code></pre><p>Otherwise, a good setup is:</p><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model,
                                ode_solver=ODESolver(QNDF(), abstol=1e-8, reltol=1e-8),
                                gradient_method=:ForwardDiff,
                                hessian_method=:GaussNewton)</code></pre><h2 id="Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)"><a class="docs-heading-anchor" href="#Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)">Large models (<span>$\geq 75$</span> parameters and <span>$\geq 50$</span> ODE:s)</a><a id="Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)-1"></a><a class="docs-heading-anchor-permalink" href="#Large-models-(\\geq-75-parameters-and-\\geq-50-ODE:s)" title="Permalink"></a></h2><p><strong>ODE solver</strong>: To efficiently solve large models, we recommend benchmarking different ODE solvers that are suitble for large problems; such as <code>QNDF()</code>, <code>FBDF()</code>, <code>KenCarp4()</code>, and <code>CVODE_BDF()</code>. You can also try providing the ODE solver with a sparse Jacobian (<code>sparse_jacobian::Bool=false</code>) and testing different linear solvers such as <code>CVODE_BDF(linsolve=:KLU)</code>. Check out <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/advanced_ode_example/">this link</a> for more information on solving large stiff models in Julia.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important to compare different ODE solvers, as this can significantly reduce runtime.</p></div></div><p><strong>Gradient method</strong>: For large models, the most scalable approach is adjoint sensitivity analysis (<code>gradient_method=:Adjoint</code>). We support <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> from SciMLSensitivity (see their <a href="https://github.com/SciML/SciMLSensitivity.jl">documentation</a> for info), but we recommend <code>InterpolatingAdjoint()</code> because it&#39;s more reliable.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When using adjoint sensitivity analysis, we recommend manually setting the ODE solver gradient options. Currently, <code>CVODE_BDF()</code> outperforms all native Julia solvers.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can provide any options that <code>InterpolatingAdjoint()</code> and <code>QuadratureAdjoint()</code> accept.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Adjoint sensitivity analysis is not as reliable in Julia as in AMICI (<a href="https://github.com/SciML/SciMLSensitivity.jl/issues/795">see</a>), but our benchmarks show that SciMLSensitivity has the potential to be faster.</p></div></div><p><strong>Hessian method</strong>: For large models, computing the sensitives (Gauss-Newton) or a full hessian is not computationally feasible. Thus, the best option is often to use an L-(BFGS) approximation. BFGS support is built into most available optimizers such as <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>, <a href="https://github.com/jump-dev/Ipopt.jl">Ipopt.jl</a>, and <a href="https://github.com/fides-dev/fides">Fides.py</a>.</p><p>All in all, for a large model, a good setup often is:</p><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model,
                                ode_solver=ODESolver(CVODE_BDF(), abstol=1e-8, reltol=1e-8),
                                ode_solver_gradient=ODESolver(CVODE_BDF(), abstol=1e-8, reltol=1e-8),
                                gradient_method=:Adjoint,
                                sensealg=InterpolatingAdjoint())</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Gradient_hessian_support/">« Supported gradient and hessian methods</a><a class="docs-footer-nextpage" href="../API_choosen/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Sunday 15 October 2023 14:04">Sunday 15 October 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
