#=
    Check the accruacy of the PeTab importer for a simple linear ODE;
    x' = a - bx + cy; x(0) = 0
    y' = bx - cy - dy;  y(0) = 0
    where the model has a pre-equilibrium condition. That is he simulated data for
    this ODE model is generated by starting from the steady state;
    x* = a / b + ( a * c ) / ( b * d )
    y* = a / d
    and when computing the cost in the PeTab importer the model is first simualted
    to a steady state, and then the mian simulation matched against data is
    performed.
    This test compares the ODE-solution, cost, gradient and hessian when
    i) solving the ODE using the SS-equations as initial condition, and ii) when
    first simulating the model to the steady state.
    Accruacy of both the hessian and gradient are strongly dependent on the tolerances
    used in the TerminateSteadyState callback.
 =#


using PEtab
using Test
using OrdinaryDiffEq
using Zygote 
using SciMLSensitivity
using CSV
using ForwardDiff
using LinearAlgebra
using Sundials

import PEtab: read_petab_files, process_measurements, process_parameters, compute_θ_indices, process_simulationinfo, set_parameters_to_file_values!
import PEtab: _change_simulation_condition!, solve_ODE_all_conditions, _get_steady_state_solver


include(joinpath(@__DIR__, "Common.jl"))


function getSolAlgebraicSS(petab_model::PEtabModel, solver, tol::Float64, a::T1, b::T1, c::T1, d::T1) where T1<:Real

    # ODE solution with algebraically computed initial values (instead of ss pre-simulation)
    odeProb = ODEProblem(petab_model.system, petab_model.state_map, (0.0, 9.7), petab_model.parameter_map, jac=true)
    odeProb = remake(odeProb, p = convert.(eltype(a), odeProb.p), u0 = convert.(eltype(a), odeProb.u0))
    solArray = Array{ODESolution, 1}(undef, 2)

    # Set model parameter values to ensure initial steady state
    odeProb.p[4], odeProb.p[2], odeProb.p[1], odeProb.p[5] = a, b, c, d
    odeProb.u0[1] = a / b + ( a * c ) / ( b * d ) # x0
    odeProb.u0[2] = a / d # y0

    odeProb.p[3] = 2.0 # a_scale
    solArray[1] = solve(odeProb, solver, abstol=tol, reltol=tol)
    odeProb.p[3] = 0.5 # a_scale
    solArray[2] = solve(odeProb, solver, abstol=tol, reltol=tol)

    return solArray
end


function compute_costAlgebraic(paramVec, petab_model, solver, tol)

    a, b, c, d = paramVec

    experimental_conditions_file, measurementDataFile, parameterDataFile, observables_dataFile = read_petab_files(petab_model)
    measurementData = process_measurements(measurementDataFile, observables_dataFile)

    solArrayAlg = getSolAlgebraicSS(petab_model, solver, tol, a, b, c, d)
    loglik = 0.0
    for i in eachindex(measurementData.time)
        y_obs = measurementData.measurement[i]
        t = measurementData.time[i]
        if measurementData.simulation_condition_id[i] == :double
            y_model = solArrayAlg[1](t)[1]
        else
            y_model = solArrayAlg[2](t)[2]
        end
        sigma = 0.04
        loglik += log(sigma) + 0.5*log(2*pi) + 0.5 * ((y_obs - y_model) / sigma)^2
    end

    return loglik
end


function test_ode_solver_test_model3(petab_model::PEtabModel, solverOptions::ODESolver, ss_options::SteadyStateSolver)

    # Set values to PeTab file values
    experimental_conditions_file, measurementDataFile, parameterDataFile, observables_dataFile = read_petab_files(petab_model)
    measurementData = process_measurements(measurementDataFile, observables_dataFile)
    paramData = process_parameters(parameterDataFile)
    set_parameters_to_file_values!(petab_model.parameter_map, petab_model.state_map, paramData)
    θ_indices = compute_θ_indices(paramData, measurementData, petab_model)

    # Extract experimental conditions for simulations
    simulation_info = process_simulationinfo(petab_model, measurementData, sensealg=nothing)

    # Parameter values where to teast accuracy. Each column is a alpha, beta, gamma and delta
    # a, b, c, d
    parametersTest = reshape([1.0, 2.0, 3.0, 4.0,
                              0.1, 0.2, 0.3, 0.4,
                              4.0, 3.0, 2.0, 1.0,
                              1.0, 1.0, 1.0, 1.0,
                              2.5, 7.0, 3.0, 3.0,], (4, 5))

    for i in 1:5
        a, b, c, d = parametersTest[:, i]
        # Set parameter values for ODE
        petab_model.parameter_map[1] = Pair(petab_model.parameter_map[1].first, c)
        petab_model.parameter_map[2] = Pair(petab_model.parameter_map[2].first, b)
        petab_model.parameter_map[4] = Pair(petab_model.parameter_map[4].first, a)
        petab_model.parameter_map[5] = Pair(petab_model.parameter_map[5].first, d)

        prob = ODEProblem(petab_model.system, petab_model.state_map, (0.0, 9.7), petab_model.parameter_map, jac=true)
        prob = remake(prob, p = convert.(Float64, prob.p), u0 = convert.(Float64, prob.u0))
        θ_dynamic = get_file_ode_values(petab_model)[1:4]
        petab_ODESolver_cache = PEtabODESolverCache(:nothing, :nothing, petab_model, simulation_info, θ_indices, nothing)
        _ss_options = _get_steady_state_solver(ss_options, prob, ss_options.abstol, ss_options.reltol, ss_options.maxiters)

        # Solve ODE system
        ode_sols, success = solve_ODE_all_conditions(prob, petab_model, θ_dynamic, petab_ODESolver_cache, simulation_info, θ_indices, solverOptions, _ss_options)
        # Solve ODE system with algebraic intial values
        algebraicODESolutions = getSolAlgebraicSS(petab_model, solverOptions.solver, solverOptions.abstol, a, b, c, d)

        # Compare against analytical solution
        sqDiff = 0.0
        for i in eachindex(simulation_info.experimental_condition_id)
            solNum = ode_sols[simulation_info.experimental_condition_id[i]]
            solAlg = algebraicODESolutions[i]
            sqDiff += sum((Array(solNum) - Array(solAlg(solNum.t))).^2)
        end

        @test sqDiff ≤ 1e-6
    end
end


function test_cost_gradient_hessian_test_model3(petab_model::PEtabModel, solverOptions, ss_options)

    _compute_costAlgebraic = (pArg) -> compute_costAlgebraic(pArg, petab_model, solverOptions.solver, solverOptions.abstol)

    cube = CSV.File(joinpath(@__DIR__, "Test_model3", "Julia_model_files", "CubeTest_model3.csv"))

    for i in 1:1

        p = Float64.(collect(cube[i]))

        referenceCost = _compute_costAlgebraic(p)
        referenceGradient = ForwardDiff.gradient(_compute_costAlgebraic, p)
        referenceHessian = ForwardDiff.hessian(_compute_costAlgebraic, p)

        # Test both the standard and Zygote approach to compute the cost
        cost = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_cost=true, cost_method=:Standard, ss_options=ss_options)
        @test cost ≈ referenceCost atol=1e-3
        costZygote = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_cost=true, cost_method=:Zygote, ss_options=ss_options)
        @test costZygote ≈ referenceCost atol=1e-3

        # Test all gradient combinations. Note we test sensitivity equations with and without autodiff
        gradientForwardDiff = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_gradient=true, gradient_method=:ForwardDiff, ss_options=ss_options)
        @test norm(gradientForwardDiff - referenceGradient) ≤ 1e-2
        gradientZygote = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_gradient=true, gradient_method=:Zygote, sensealg=ForwardDiffSensitivity(), ss_options=ss_options)
        @test norm(gradientZygote - referenceGradient) ≤ 1e-2
        gradient_adjoint = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_gradient=true, gradient_method=:Adjoint, sensealg=QuadratureAdjoint(autojacvec=ReverseDiffVJP(false)), ss_options=ss_options)
        @test norm(normalize(gradient_adjoint) - normalize((referenceGradient))) ≤ 1e-2
        gradientForward1 = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_gradient=true, gradient_method=:ForwardEquations, sensealg=:ForwardDiff, ss_options=ss_options)
        @test norm(gradientForward1 - referenceGradient) ≤ 1e-2
        gradientForward2 = _testCostGradientOrHessian(petab_model, ODESolver(CVODE_BDF(), abstol=1e-12, reltol=1e-12), p, compute_gradient=true, gradient_method=:ForwardEquations, sensealg=ForwardSensitivity(), ss_options=ss_options)
        @test norm(gradientForward2 - referenceGradient) ≤ 1e-2

        # Testing "exact" hessian via autodiff
        hessian = _testCostGradientOrHessian(petab_model, solverOptions, p, compute_hessian=true, hessian_method=:ForwardDiff, ss_options=ss_options)
        @test norm(hessian - referenceHessian) ≤ 1e-2
    end

    return true
end


petab_model = PEtabModel(joinpath(@__DIR__, "Test_model3", "Test_model3.yaml"), build_julia_files=true, write_to_file=true)

@testset "ODE solver Simulate wrms termination" begin
    ss_optionsTest1 = SteadyStateSolver(:Simulate, check_simulation_steady_state=:wrms, abstol=1e-12, reltol=1e-10)
    test_ode_solver_test_model3(petab_model, ODESolver(Rodas4P(), abstol=1e-12, reltol=1e-12), ss_optionsTest1)
end

@testset "ODE solver Simulate Newton SS termination" begin
    ss_optionsTest2 = SteadyStateSolver(:Simulate, check_simulation_steady_state=:Newton, abstol=1e-12, reltol=1e-10)
    test_ode_solver_test_model3(petab_model, ODESolver(Rodas4P(), abstol=1e-12, reltol=1e-12), ss_optionsTest2)
end

@testset "Cost gradient and hessian" begin
    ss_optionsTest3 = SteadyStateSolver(:Simulate, check_simulation_steady_state=:wrms, abstol=1e-12, reltol=1e-10)
    test_cost_gradient_hessian_test_model3(petab_model, ODESolver(Rodas5P(), abstol=1e-12, reltol=1e-12, maxiters=Int(1e5)), ss_optionsTest3)
end

@testset "Gradient of residuals" begin
    check_gradient_residuals(petab_model, ODESolver(Rodas4P(), abstol=1e-9, reltol=1e-9))
end
